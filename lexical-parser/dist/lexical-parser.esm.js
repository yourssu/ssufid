var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
  get: (a2, b3) => (typeof require !== "undefined" ? require : a2)[b3]
}) : x4)(function(x4) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x4 + '" is not supported');
});
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb, mod11) => function __require2() {
  return mod11 || (0, cb[__getOwnPropNames(cb)[0]])((mod11 = { exports: {} }).exports, mod11), mod11.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key2) && key2 !== except)
        __defProp(to2, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod11, isNodeMode, target) => (target = mod11 != null ? __create(__getProtoOf(mod11)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod11 || !mod11.__esModule ? __defProp(target, "default", { value: mod11, enumerable: true }) : target,
  mod11
));

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/commonjs/perf_hooks.cjs
var require_perf_hooks = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/commonjs/perf_hooks.cjs"(exports) {
    try {
      const { performance: performance3 } = __require("perf_hooks");
      exports.performance = performance3;
    } catch (fallback) {
      exports.performance = { now() {
        return +/* @__PURE__ */ new Date();
      } };
    }
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/boolbase@1.0.0/node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/boolbase@1.0.0/node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/types.js
var require_types = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeAction = exports.IgnoreCaseMode = exports.SelectorType = void 0;
    var SelectorType4;
    (function(SelectorType5) {
      SelectorType5["Attribute"] = "attribute";
      SelectorType5["Pseudo"] = "pseudo";
      SelectorType5["PseudoElement"] = "pseudo-element";
      SelectorType5["Tag"] = "tag";
      SelectorType5["Universal"] = "universal";
      SelectorType5["Adjacent"] = "adjacent";
      SelectorType5["Child"] = "child";
      SelectorType5["Descendant"] = "descendant";
      SelectorType5["Parent"] = "parent";
      SelectorType5["Sibling"] = "sibling";
      SelectorType5["ColumnCombinator"] = "column-combinator";
    })(SelectorType4 = exports.SelectorType || (exports.SelectorType = {}));
    exports.IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    var AttributeAction2;
    (function(AttributeAction3) {
      AttributeAction3["Any"] = "any";
      AttributeAction3["Element"] = "element";
      AttributeAction3["End"] = "end";
      AttributeAction3["Equals"] = "equals";
      AttributeAction3["Exists"] = "exists";
      AttributeAction3["Hyphen"] = "hyphen";
      AttributeAction3["Not"] = "not";
      AttributeAction3["Start"] = "start";
    })(AttributeAction2 = exports.AttributeAction || (exports.AttributeAction = {}));
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/parse.js
var require_parse = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.isTraversal = void 0;
    var types_1 = require_types();
    var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    var actionTypes = /* @__PURE__ */ new Map([
      [126, types_1.AttributeAction.Element],
      [94, types_1.AttributeAction.Start],
      [36, types_1.AttributeAction.End],
      [42, types_1.AttributeAction.Any],
      [33, types_1.AttributeAction.Not],
      [124, types_1.AttributeAction.Hyphen]
    ]);
    var unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    function isTraversal2(selector) {
      switch (selector.type) {
        case types_1.SelectorType.Adjacent:
        case types_1.SelectorType.Child:
        case types_1.SelectorType.Descendant:
        case types_1.SelectorType.Parent:
        case types_1.SelectorType.Sibling:
        case types_1.SelectorType.ColumnCombinator:
          return true;
        default:
          return false;
      }
    }
    exports.isTraversal = isTraversal2;
    var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
    function funescape(_5, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? (
        // BMP codepoint
        String.fromCharCode(high + 65536)
      ) : (
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
      );
    }
    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }
    function isQuote(c2) {
      return c2 === 39 || c2 === 34;
    }
    function isWhitespace2(c2) {
      return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
    }
    function parse6(selector) {
      var subselects2 = [];
      var endIndex = parseSelector(subselects2, "".concat(selector), 0);
      if (endIndex < selector.length) {
        throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
      }
      return subselects2;
    }
    exports.parse = parse6;
    function parseSelector(subselects2, selector, selectorIndex) {
      var tokens = [];
      function getName3(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
          throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length && isWhitespace2(selector.charCodeAt(selectorIndex))) {
          selectorIndex++;
        }
      }
      function readValueWithParenthesis() {
        selectorIndex += 1;
        var start = selectorIndex;
        var counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
          if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
            counter++;
          } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
            counter--;
          }
        }
        if (counter) {
          throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charCodeAt(--pos) === 92)
          slashCount++;
        return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal2(tokens[tokens.length - 1])) {
          throw new Error("Did not expect successive traversals.");
        }
      }
      function addTraversal(type) {
        if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens[tokens.length - 1].type = type;
          return;
        }
        ensureNotTraversal();
        tokens.push({ type });
      }
      function addSpecialAttribute(name, action2) {
        tokens.push({
          type: types_1.SelectorType.Attribute,
          name,
          action: action2,
          value: getName3(1),
          namespace: null,
          ignoreCase: "quirks"
        });
      }
      function finalizeSubselector() {
        if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens.pop();
        }
        if (tokens.length === 0) {
          throw new Error("Empty sub-selector");
        }
        subselects2.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
        return selectorIndex;
      }
      loop: while (selectorIndex < selector.length) {
        var firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
          // Whitespace
          case 32:
          case 9:
          case 10:
          case 12:
          case 13: {
            if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
              ensureNotTraversal();
              tokens.push({ type: types_1.SelectorType.Descendant });
            }
            stripWhitespace(1);
            break;
          }
          // Traversals
          case 62: {
            addTraversal(types_1.SelectorType.Child);
            stripWhitespace(1);
            break;
          }
          case 60: {
            addTraversal(types_1.SelectorType.Parent);
            stripWhitespace(1);
            break;
          }
          case 126: {
            addTraversal(types_1.SelectorType.Sibling);
            stripWhitespace(1);
            break;
          }
          case 43: {
            addTraversal(types_1.SelectorType.Adjacent);
            stripWhitespace(1);
            break;
          }
          // Special attribute selectors: .class, #id
          case 46: {
            addSpecialAttribute("class", types_1.AttributeAction.Element);
            break;
          }
          case 35: {
            addSpecialAttribute("id", types_1.AttributeAction.Equals);
            break;
          }
          case 91: {
            stripWhitespace(1);
            var name_1 = void 0;
            var namespace = null;
            if (selector.charCodeAt(selectorIndex) === 124) {
              name_1 = getName3(1);
            } else if (selector.startsWith("*|", selectorIndex)) {
              namespace = "*";
              name_1 = getName3(2);
            } else {
              name_1 = getName3(0);
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                namespace = name_1;
                name_1 = getName3(1);
              }
            }
            stripWhitespace(0);
            var action = types_1.AttributeAction.Exists;
            var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
            if (possibleAction) {
              action = possibleAction;
              if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                throw new Error("Expected `=`");
              }
              stripWhitespace(2);
            } else if (selector.charCodeAt(selectorIndex) === 61) {
              action = types_1.AttributeAction.Equals;
              stripWhitespace(1);
            }
            var value = "";
            var ignoreCase2 = null;
            if (action !== "exists") {
              if (isQuote(selector.charCodeAt(selectorIndex))) {
                var quote = selector.charCodeAt(selectorIndex);
                var sectionEnd = selectorIndex + 1;
                while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                  sectionEnd += 1;
                }
                if (selector.charCodeAt(sectionEnd) !== quote) {
                  throw new Error("Attribute value didn't end");
                }
                value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                selectorIndex = sectionEnd + 1;
              } else {
                var valueStart = selectorIndex;
                while (selectorIndex < selector.length && (!isWhitespace2(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                  selectorIndex += 1;
                }
                value = unescapeCSS(selector.slice(valueStart, selectorIndex));
              }
              stripWhitespace(0);
              var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
              if (forceIgnore === 115) {
                ignoreCase2 = false;
                stripWhitespace(1);
              } else if (forceIgnore === 105) {
                ignoreCase2 = true;
                stripWhitespace(1);
              }
            }
            if (selector.charCodeAt(selectorIndex) !== 93) {
              throw new Error("Attribute selector didn't terminate");
            }
            selectorIndex += 1;
            var attributeSelector = {
              type: types_1.SelectorType.Attribute,
              name: name_1,
              action,
              value,
              namespace,
              ignoreCase: ignoreCase2
            };
            tokens.push(attributeSelector);
            break;
          }
          case 58: {
            if (selector.charCodeAt(selectorIndex + 1) === 58) {
              tokens.push({
                type: types_1.SelectorType.PseudoElement,
                name: getName3(2).toLowerCase(),
                data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
              });
              continue;
            }
            var name_2 = getName3(1).toLowerCase();
            var data = null;
            if (selector.charCodeAt(selectorIndex) === 40) {
              if (unpackPseudos.has(name_2)) {
                if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                  throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                }
                data = [];
                selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                if (selector.charCodeAt(selectorIndex) !== 41) {
                  throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                }
                selectorIndex += 1;
              } else {
                data = readValueWithParenthesis();
                if (stripQuotesFromPseudos.has(name_2)) {
                  var quot = data.charCodeAt(0);
                  if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                    data = data.slice(1, -1);
                  }
                }
                data = unescapeCSS(data);
              }
            }
            tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
            break;
          }
          case 44: {
            finalizeSubselector();
            tokens = [];
            stripWhitespace(1);
            break;
          }
          default: {
            if (selector.startsWith("/*", selectorIndex)) {
              var endIndex = selector.indexOf("*/", selectorIndex + 2);
              if (endIndex < 0) {
                throw new Error("Comment was not terminated");
              }
              selectorIndex = endIndex + 2;
              if (tokens.length === 0) {
                stripWhitespace(0);
              }
              break;
            }
            var namespace = null;
            var name_3 = void 0;
            if (firstChar === 42) {
              selectorIndex += 1;
              name_3 = "*";
            } else if (firstChar === 124) {
              name_3 = "";
              if (selector.charCodeAt(selectorIndex + 1) === 124) {
                addTraversal(types_1.SelectorType.ColumnCombinator);
                stripWhitespace(2);
                break;
              }
            } else if (reName.test(selector.slice(selectorIndex))) {
              name_3 = getName3(0);
            } else {
              break loop;
            }
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
              namespace = name_3;
              if (selector.charCodeAt(selectorIndex + 1) === 42) {
                name_3 = "*";
                selectorIndex += 2;
              } else {
                name_3 = getName3(1);
              }
            }
            tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
          }
        }
      }
      finalizeSubselector();
      return selectorIndex;
    }
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/stringify.js
var require_stringify = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/stringify.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
        if (ar2 || !(i2 in from)) {
          if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
          ar2[i2] = from[i2];
        }
      }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var types_1 = require_types();
    var attribValChars = ["\\", '"'];
    var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
    var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c2) {
      return c2.charCodeAt(0);
    }));
    var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c2) {
      return c2.charCodeAt(0);
    }));
    var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ], false).map(function(c2) {
      return c2.charCodeAt(0);
    }));
    function stringify(selector) {
      return selector.map(function(token) {
        return token.map(stringifyToken).join("");
      }).join(", ");
    }
    exports.stringify = stringify;
    function stringifyToken(token, index, arr) {
      switch (token.type) {
        // Simple types
        case types_1.SelectorType.Child:
          return index === 0 ? "> " : " > ";
        case types_1.SelectorType.Parent:
          return index === 0 ? "< " : " < ";
        case types_1.SelectorType.Sibling:
          return index === 0 ? "~ " : " ~ ";
        case types_1.SelectorType.Adjacent:
          return index === 0 ? "+ " : " + ";
        case types_1.SelectorType.Descendant:
          return " ";
        case types_1.SelectorType.ColumnCombinator:
          return index === 0 ? "|| " : " || ";
        case types_1.SelectorType.Universal:
          return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
        case types_1.SelectorType.Tag:
          return getNamespacedName(token);
        case types_1.SelectorType.PseudoElement:
          return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
        case types_1.SelectorType.Pseudo:
          return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
        case types_1.SelectorType.Attribute: {
          if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
            return "#".concat(escapeName(token.value, charsToEscapeInName));
          }
          if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
            return ".".concat(escapeName(token.value, charsToEscapeInName));
          }
          var name_1 = getNamespacedName(token);
          if (token.action === types_1.AttributeAction.Exists) {
            return "[".concat(name_1, "]");
          }
          return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
        }
      }
    }
    function getActionValue(action) {
      switch (action) {
        case types_1.AttributeAction.Equals:
          return "";
        case types_1.AttributeAction.Element:
          return "~";
        case types_1.AttributeAction.Start:
          return "^";
        case types_1.AttributeAction.End:
          return "$";
        case types_1.AttributeAction.Any:
          return "*";
        case types_1.AttributeAction.Not:
          return "!";
        case types_1.AttributeAction.Hyphen:
          return "|";
        case types_1.AttributeAction.Exists:
          throw new Error("Shouldn't be here");
      }
    }
    function getNamespacedName(token) {
      return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
    }
    function getNamespace(namespace) {
      return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
    }
    function escapeName(str, charsToEscape) {
      var lastIdx = 0;
      var ret = "";
      for (var i2 = 0; i2 < str.length; i2++) {
        if (charsToEscape.has(str.charCodeAt(i2))) {
          ret += "".concat(str.slice(lastIdx, i2), "\\").concat(str.charAt(i2));
          lastIdx = i2 + 1;
        }
      }
      return ret.length > 0 ? ret + str.slice(lastIdx) : str;
    }
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-what@6.1.0/node_modules/css-what/lib/commonjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m4, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m4, k5);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k5];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m4, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o2[k22] = m4[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m4, exports2) {
      for (var p3 in m4) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m4, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = exports.isTraversal = void 0;
    __exportStar(require_types(), exports);
    var parse_1 = require_parse();
    Object.defineProperty(exports, "isTraversal", { enumerable: true, get: function() {
      return parse_1.isTraversal;
    } });
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var stringify_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/StyleSheet.js
var require_StyleSheet = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/StyleSheet.js"(exports) {
    var CSSOM = {};
    CSSOM.StyleSheet = function StyleSheet() {
      this.parentStyleSheet = null;
    };
    exports.StyleSheet = CSSOM.StyleSheet;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSRule.js
var require_CSSRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSRule.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSRule = function CSSRule() {
      this.parentRule = null;
      this.parentStyleSheet = null;
    };
    CSSOM.CSSRule.UNKNOWN_RULE = 0;
    CSSOM.CSSRule.STYLE_RULE = 1;
    CSSOM.CSSRule.CHARSET_RULE = 2;
    CSSOM.CSSRule.IMPORT_RULE = 3;
    CSSOM.CSSRule.MEDIA_RULE = 4;
    CSSOM.CSSRule.FONT_FACE_RULE = 5;
    CSSOM.CSSRule.PAGE_RULE = 6;
    CSSOM.CSSRule.KEYFRAMES_RULE = 7;
    CSSOM.CSSRule.KEYFRAME_RULE = 8;
    CSSOM.CSSRule.MARGIN_RULE = 9;
    CSSOM.CSSRule.NAMESPACE_RULE = 10;
    CSSOM.CSSRule.COUNTER_STYLE_RULE = 11;
    CSSOM.CSSRule.SUPPORTS_RULE = 12;
    CSSOM.CSSRule.DOCUMENT_RULE = 13;
    CSSOM.CSSRule.FONT_FEATURE_VALUES_RULE = 14;
    CSSOM.CSSRule.VIEWPORT_RULE = 15;
    CSSOM.CSSRule.REGION_STYLE_RULE = 16;
    CSSOM.CSSRule.prototype = {
      constructor: CSSOM.CSSRule
      //FIXME
    };
    exports.CSSRule = CSSOM.CSSRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSStyleRule.js
var require_CSSStyleRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSStyleRule.js"(exports) {
    var CSSOM = {
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSStyleRule = function CSSStyleRule() {
      CSSOM.CSSRule.call(this);
      this.selectorText = "";
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
    CSSOM.CSSStyleRule.prototype.type = 1;
    Object.defineProperty(CSSOM.CSSStyleRule.prototype, "cssText", {
      get: function() {
        var text;
        if (this.selectorText) {
          text = this.selectorText + " {" + this.style.cssText + "}";
        } else {
          text = "";
        }
        return text;
      },
      set: function(cssText) {
        var rule = CSSOM.CSSStyleRule.parse(cssText);
        this.style = rule.style;
        this.selectorText = rule.selectorText;
      }
    });
    CSSOM.CSSStyleRule.parse = function(ruleText) {
      var i2 = 0;
      var state = "selector";
      var index;
      var j5 = i2;
      var buffer = "";
      var SIGNIFICANT_WHITESPACE = {
        "selector": true,
        "value": true
      };
      var styleRule = new CSSOM.CSSStyleRule();
      var name, priority = "";
      for (var character; character = ruleText.charAt(i2); i2++) {
        switch (character) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\f":
            if (SIGNIFICANT_WHITESPACE[state]) {
              switch (ruleText.charAt(i2 - 1)) {
                case " ":
                case "	":
                case "\r":
                case "\n":
                case "\f":
                  break;
                default:
                  buffer += " ";
                  break;
              }
            }
            break;
          // String
          case '"':
            j5 = i2 + 1;
            index = ruleText.indexOf('"', j5) + 1;
            if (!index) {
              throw '" is missing';
            }
            buffer += ruleText.slice(i2, index);
            i2 = index - 1;
            break;
          case "'":
            j5 = i2 + 1;
            index = ruleText.indexOf("'", j5) + 1;
            if (!index) {
              throw "' is missing";
            }
            buffer += ruleText.slice(i2, index);
            i2 = index - 1;
            break;
          // Comment
          case "/":
            if (ruleText.charAt(i2 + 1) === "*") {
              i2 += 2;
              index = ruleText.indexOf("*/", i2);
              if (index === -1) {
                throw new SyntaxError("Missing */");
              } else {
                i2 = index + 1;
              }
            } else {
              buffer += character;
            }
            break;
          case "{":
            if (state === "selector") {
              styleRule.selectorText = buffer.trim();
              buffer = "";
              state = "name";
            }
            break;
          case ":":
            if (state === "name") {
              name = buffer.trim();
              buffer = "";
              state = "value";
            } else {
              buffer += character;
            }
            break;
          case "!":
            if (state === "value" && ruleText.indexOf("!important", i2) === i2) {
              priority = "important";
              i2 += "important".length;
            } else {
              buffer += character;
            }
            break;
          case ";":
            if (state === "value") {
              styleRule.style.setProperty(name, buffer.trim(), priority);
              priority = "";
              buffer = "";
              state = "name";
            } else {
              buffer += character;
            }
            break;
          case "}":
            if (state === "value") {
              styleRule.style.setProperty(name, buffer.trim(), priority);
              priority = "";
              buffer = "";
            } else if (state === "name") {
              break;
            } else {
              buffer += character;
            }
            state = "selector";
            break;
          default:
            buffer += character;
            break;
        }
      }
      return styleRule;
    };
    exports.CSSStyleRule = CSSOM.CSSStyleRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSStyleSheet.js
var require_CSSStyleSheet = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSStyleSheet.js"(exports) {
    var CSSOM = {
      StyleSheet: require_StyleSheet().StyleSheet,
      CSSStyleRule: require_CSSStyleRule().CSSStyleRule
    };
    CSSOM.CSSStyleSheet = function CSSStyleSheet() {
      CSSOM.StyleSheet.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet();
    CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;
    CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
      if (index < 0 || index > this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      var cssRule = CSSOM.parse(rule).cssRules[0];
      cssRule.parentStyleSheet = this;
      this.cssRules.splice(index, 0, cssRule);
      return index;
    };
    CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
      if (index < 0 || index >= this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      this.cssRules.splice(index, 1);
    };
    CSSOM.CSSStyleSheet.prototype.toString = function() {
      var result = "";
      var rules = this.cssRules;
      for (var i2 = 0; i2 < rules.length; i2++) {
        result += rules[i2].cssText + "\n";
      }
      return result;
    };
    exports.CSSStyleSheet = CSSOM.CSSStyleSheet;
    CSSOM.parse = require_parse2().parse;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/MediaList.js
var require_MediaList = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/MediaList.js"(exports) {
    var CSSOM = {};
    CSSOM.MediaList = function MediaList() {
      this.length = 0;
    };
    CSSOM.MediaList.prototype = {
      constructor: CSSOM.MediaList,
      /**
       * @return {string}
       */
      get mediaText() {
        return Array.prototype.join.call(this, ", ");
      },
      /**
       * @param {string} value
       */
      set mediaText(value) {
        var values = value.split(",");
        var length = this.length = values.length;
        for (var i2 = 0; i2 < length; i2++) {
          this[i2] = values[i2].trim();
        }
      },
      /**
       * @param {string} medium
       */
      appendMedium: function(medium) {
        if (Array.prototype.indexOf.call(this, medium) === -1) {
          this[this.length] = medium;
          this.length++;
        }
      },
      /**
       * @param {string} medium
       */
      deleteMedium: function(medium) {
        var index = Array.prototype.indexOf.call(this, medium);
        if (index !== -1) {
          Array.prototype.splice.call(this, index, 1);
        }
      }
    };
    exports.MediaList = CSSOM.MediaList;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSImportRule.js
var require_CSSImportRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSImportRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleSheet: require_CSSStyleSheet().CSSStyleSheet,
      MediaList: require_MediaList().MediaList
    };
    CSSOM.CSSImportRule = function CSSImportRule() {
      CSSOM.CSSRule.call(this);
      this.href = "";
      this.media = new CSSOM.MediaList();
      this.styleSheet = new CSSOM.CSSStyleSheet();
    };
    CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
    CSSOM.CSSImportRule.prototype.type = 3;
    Object.defineProperty(CSSOM.CSSImportRule.prototype, "cssText", {
      get: function() {
        var mediaText = this.media.mediaText;
        return "@import url(" + this.href + ")" + (mediaText ? " " + mediaText : "") + ";";
      },
      set: function(cssText) {
        var i2 = 0;
        var state = "";
        var buffer = "";
        var index;
        for (var character; character = cssText.charAt(i2); i2++) {
          switch (character) {
            case " ":
            case "	":
            case "\r":
            case "\n":
            case "\f":
              if (state === "after-import") {
                state = "url";
              } else {
                buffer += character;
              }
              break;
            case "@":
              if (!state && cssText.indexOf("@import", i2) === i2) {
                state = "after-import";
                i2 += "import".length;
                buffer = "";
              }
              break;
            case "u":
              if (state === "url" && cssText.indexOf("url(", i2) === i2) {
                index = cssText.indexOf(")", i2 + 1);
                if (index === -1) {
                  throw i2 + ': ")" not found';
                }
                i2 += "url(".length;
                var url = cssText.slice(i2, index);
                if (url[0] === url[url.length - 1]) {
                  if (url[0] === '"' || url[0] === "'") {
                    url = url.slice(1, -1);
                  }
                }
                this.href = url;
                i2 = index;
                state = "media";
              }
              break;
            case '"':
              if (state === "url") {
                index = cssText.indexOf('"', i2 + 1);
                if (!index) {
                  throw i2 + `: '"' not found`;
                }
                this.href = cssText.slice(i2 + 1, index);
                i2 = index;
                state = "media";
              }
              break;
            case "'":
              if (state === "url") {
                index = cssText.indexOf("'", i2 + 1);
                if (!index) {
                  throw i2 + `: "'" not found`;
                }
                this.href = cssText.slice(i2 + 1, index);
                i2 = index;
                state = "media";
              }
              break;
            case ";":
              if (state === "media") {
                if (buffer) {
                  this.media.mediaText = buffer.trim();
                }
              }
              break;
            default:
              if (state === "media") {
                buffer += character;
              }
              break;
          }
        }
      }
    });
    exports.CSSImportRule = CSSOM.CSSImportRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSGroupingRule.js
var require_CSSGroupingRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSGroupingRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSGroupingRule = function CSSGroupingRule() {
      CSSOM.CSSRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSGroupingRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSGroupingRule.prototype.constructor = CSSOM.CSSGroupingRule;
    CSSOM.CSSGroupingRule.prototype.insertRule = function insertRule(rule, index) {
      if (index < 0 || index > this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      var cssRule = CSSOM.parse(rule).cssRules[0];
      cssRule.parentRule = this;
      this.cssRules.splice(index, 0, cssRule);
      return index;
    };
    CSSOM.CSSGroupingRule.prototype.deleteRule = function deleteRule(index) {
      if (index < 0 || index >= this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      this.cssRules.splice(index, 1)[0].parentRule = null;
    };
    exports.CSSGroupingRule = CSSOM.CSSGroupingRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSConditionRule.js
var require_CSSConditionRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSConditionRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule
    };
    CSSOM.CSSConditionRule = function CSSConditionRule() {
      CSSOM.CSSGroupingRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSConditionRule.prototype = new CSSOM.CSSGroupingRule();
    CSSOM.CSSConditionRule.prototype.constructor = CSSOM.CSSConditionRule;
    CSSOM.CSSConditionRule.prototype.conditionText = "";
    CSSOM.CSSConditionRule.prototype.cssText = "";
    exports.CSSConditionRule = CSSOM.CSSConditionRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSMediaRule.js
var require_CSSMediaRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSMediaRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule,
      MediaList: require_MediaList().MediaList
    };
    CSSOM.CSSMediaRule = function CSSMediaRule() {
      CSSOM.CSSConditionRule.call(this);
      this.media = new CSSOM.MediaList();
    };
    CSSOM.CSSMediaRule.prototype = new CSSOM.CSSConditionRule();
    CSSOM.CSSMediaRule.prototype.constructor = CSSOM.CSSMediaRule;
    CSSOM.CSSMediaRule.prototype.type = 4;
    Object.defineProperties(CSSOM.CSSMediaRule.prototype, {
      "conditionText": {
        get: function() {
          return this.media.mediaText;
        },
        set: function(value) {
          this.media.mediaText = value;
        },
        configurable: true,
        enumerable: true
      },
      "cssText": {
        get: function() {
          var cssTexts = [];
          for (var i2 = 0, length = this.cssRules.length; i2 < length; i2++) {
            cssTexts.push(this.cssRules[i2].cssText);
          }
          return "@media " + this.media.mediaText + " {" + cssTexts.join("") + "}";
        },
        configurable: true,
        enumerable: true
      }
    });
    exports.CSSMediaRule = CSSOM.CSSMediaRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSSupportsRule.js
var require_CSSSupportsRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSSupportsRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule
    };
    CSSOM.CSSSupportsRule = function CSSSupportsRule() {
      CSSOM.CSSConditionRule.call(this);
    };
    CSSOM.CSSSupportsRule.prototype = new CSSOM.CSSConditionRule();
    CSSOM.CSSSupportsRule.prototype.constructor = CSSOM.CSSSupportsRule;
    CSSOM.CSSSupportsRule.prototype.type = 12;
    Object.defineProperty(CSSOM.CSSSupportsRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i2 = 0, length = this.cssRules.length; i2 < length; i2++) {
          cssTexts.push(this.cssRules[i2].cssText);
        }
        return "@supports " + this.conditionText + " {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSSupportsRule = CSSOM.CSSSupportsRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSFontFaceRule.js
var require_CSSFontFaceRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSFontFaceRule.js"(exports) {
    var CSSOM = {
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSFontFaceRule = function CSSFontFaceRule() {
      CSSOM.CSSRule.call(this);
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSFontFaceRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSFontFaceRule.prototype.constructor = CSSOM.CSSFontFaceRule;
    CSSOM.CSSFontFaceRule.prototype.type = 5;
    Object.defineProperty(CSSOM.CSSFontFaceRule.prototype, "cssText", {
      get: function() {
        return "@font-face {" + this.style.cssText + "}";
      }
    });
    exports.CSSFontFaceRule = CSSOM.CSSFontFaceRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSHostRule.js
var require_CSSHostRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSHostRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSHostRule = function CSSHostRule() {
      CSSOM.CSSRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSHostRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSHostRule.prototype.constructor = CSSOM.CSSHostRule;
    CSSOM.CSSHostRule.prototype.type = 1001;
    Object.defineProperty(CSSOM.CSSHostRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i2 = 0, length = this.cssRules.length; i2 < length; i2++) {
          cssTexts.push(this.cssRules[i2].cssText);
        }
        return "@host {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSHostRule = CSSOM.CSSHostRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSKeyframeRule.js
var require_CSSKeyframeRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSKeyframeRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration
    };
    CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
      CSSOM.CSSRule.call(this);
      this.keyText = "";
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
    CSSOM.CSSKeyframeRule.prototype.type = 8;
    Object.defineProperty(CSSOM.CSSKeyframeRule.prototype, "cssText", {
      get: function() {
        return this.keyText + " {" + this.style.cssText + "} ";
      }
    });
    exports.CSSKeyframeRule = CSSOM.CSSKeyframeRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSKeyframesRule.js
var require_CSSKeyframesRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSKeyframesRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSKeyframesRule = function CSSKeyframesRule() {
      CSSOM.CSSRule.call(this);
      this.name = "";
      this.cssRules = [];
    };
    CSSOM.CSSKeyframesRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSKeyframesRule.prototype.constructor = CSSOM.CSSKeyframesRule;
    CSSOM.CSSKeyframesRule.prototype.type = 7;
    Object.defineProperty(CSSOM.CSSKeyframesRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i2 = 0, length = this.cssRules.length; i2 < length; i2++) {
          cssTexts.push("  " + this.cssRules[i2].cssText);
        }
        return "@" + (this._vendorPrefix || "") + "keyframes " + this.name + " { \n" + cssTexts.join("\n") + "\n}";
      }
    });
    exports.CSSKeyframesRule = CSSOM.CSSKeyframesRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSValue.js
var require_CSSValue = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSValue.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSValue = function CSSValue() {
    };
    CSSOM.CSSValue.prototype = {
      constructor: CSSOM.CSSValue,
      // @see: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
      set cssText(text) {
        var name = this._getConstructorName();
        throw new Error('DOMException: property "cssText" of "' + name + '" is readonly and can not be replaced with "' + text + '"!');
      },
      get cssText() {
        var name = this._getConstructorName();
        throw new Error('getter "cssText" of "' + name + '" is not implemented!');
      },
      _getConstructorName: function() {
        var s2 = this.constructor.toString(), c2 = s2.match(/function\s([^\(]+)/), name = c2[1];
        return name;
      }
    };
    exports.CSSValue = CSSOM.CSSValue;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSValueExpression.js
var require_CSSValueExpression = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSValueExpression.js"(exports) {
    var CSSOM = {
      CSSValue: require_CSSValue().CSSValue
    };
    CSSOM.CSSValueExpression = function CSSValueExpression(token, idx) {
      this._token = token;
      this._idx = idx;
    };
    CSSOM.CSSValueExpression.prototype = new CSSOM.CSSValue();
    CSSOM.CSSValueExpression.prototype.constructor = CSSOM.CSSValueExpression;
    CSSOM.CSSValueExpression.prototype.parse = function() {
      var token = this._token, idx = this._idx;
      var character = "", expression = "", error = "", info, paren = [];
      for (; ; ++idx) {
        character = token.charAt(idx);
        if (character === "") {
          error = "css expression error: unfinished expression!";
          break;
        }
        switch (character) {
          case "(":
            paren.push(character);
            expression += character;
            break;
          case ")":
            paren.pop(character);
            expression += character;
            break;
          case "/":
            if (info = this._parseJSComment(token, idx)) {
              if (info.error) {
                error = "css expression error: unfinished comment in expression!";
              } else {
                idx = info.idx;
              }
            } else if (info = this._parseJSRexExp(token, idx)) {
              idx = info.idx;
              expression += info.text;
            } else {
              expression += character;
            }
            break;
          case "'":
          case '"':
            info = this._parseJSString(token, idx, character);
            if (info) {
              idx = info.idx;
              expression += info.text;
            } else {
              expression += character;
            }
            break;
          default:
            expression += character;
            break;
        }
        if (error) {
          break;
        }
        if (paren.length === 0) {
          break;
        }
      }
      var ret;
      if (error) {
        ret = {
          error
        };
      } else {
        ret = {
          idx,
          expression
        };
      }
      return ret;
    };
    CSSOM.CSSValueExpression.prototype._parseJSComment = function(token, idx) {
      var nextChar = token.charAt(idx + 1), text;
      if (nextChar === "/" || nextChar === "*") {
        var startIdx = idx, endIdx, commentEndChar;
        if (nextChar === "/") {
          commentEndChar = "\n";
        } else if (nextChar === "*") {
          commentEndChar = "*/";
        }
        endIdx = token.indexOf(commentEndChar, startIdx + 1 + 1);
        if (endIdx !== -1) {
          endIdx = endIdx + commentEndChar.length - 1;
          text = token.substring(idx, endIdx + 1);
          return {
            idx: endIdx,
            text
          };
        } else {
          var error = "css expression error: unfinished comment in expression!";
          return {
            error
          };
        }
      } else {
        return false;
      }
    };
    CSSOM.CSSValueExpression.prototype._parseJSString = function(token, idx, sep) {
      var endIdx = this._findMatchedIdx(token, idx, sep), text;
      if (endIdx === -1) {
        return false;
      } else {
        text = token.substring(idx, endIdx + sep.length);
        return {
          idx: endIdx,
          text
        };
      }
    };
    CSSOM.CSSValueExpression.prototype._parseJSRexExp = function(token, idx) {
      var before2 = token.substring(0, idx).replace(/\s+$/, ""), legalRegx = [
        /^$/,
        /\($/,
        /\[$/,
        /\!$/,
        /\+$/,
        /\-$/,
        /\*$/,
        /\/\s+/,
        /\%$/,
        /\=$/,
        /\>$/,
        /<$/,
        /\&$/,
        /\|$/,
        /\^$/,
        /\~$/,
        /\?$/,
        /\,$/,
        /delete$/,
        /in$/,
        /instanceof$/,
        /new$/,
        /typeof$/,
        /void$/
      ];
      var isLegal = legalRegx.some(function(reg) {
        return reg.test(before2);
      });
      if (!isLegal) {
        return false;
      } else {
        var sep = "/";
        return this._parseJSString(token, idx, sep);
      }
    };
    CSSOM.CSSValueExpression.prototype._findMatchedIdx = function(token, idx, sep) {
      var startIdx = idx, endIdx;
      var NOT_FOUND = -1;
      while (true) {
        endIdx = token.indexOf(sep, startIdx + 1);
        if (endIdx === -1) {
          endIdx = NOT_FOUND;
          break;
        } else {
          var text = token.substring(idx + 1, endIdx), matched = text.match(/\\+$/);
          if (!matched || matched[0] % 2 === 0) {
            break;
          } else {
            startIdx = endIdx;
          }
        }
      }
      var nextNewLineIdx = token.indexOf("\n", idx + 1);
      if (nextNewLineIdx < endIdx) {
        endIdx = NOT_FOUND;
      }
      return endIdx;
    };
    exports.CSSValueExpression = CSSOM.CSSValueExpression;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/MatcherList.js
var require_MatcherList = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/MatcherList.js"(exports) {
    var CSSOM = {};
    CSSOM.MatcherList = function MatcherList() {
      this.length = 0;
    };
    CSSOM.MatcherList.prototype = {
      constructor: CSSOM.MatcherList,
      /**
       * @return {string}
       */
      get matcherText() {
        return Array.prototype.join.call(this, ", ");
      },
      /**
       * @param {string} value
       */
      set matcherText(value) {
        var values = value.split(",");
        var length = this.length = values.length;
        for (var i2 = 0; i2 < length; i2++) {
          this[i2] = values[i2].trim();
        }
      },
      /**
       * @param {string} matcher
       */
      appendMatcher: function(matcher) {
        if (Array.prototype.indexOf.call(this, matcher) === -1) {
          this[this.length] = matcher;
          this.length++;
        }
      },
      /**
       * @param {string} matcher
       */
      deleteMatcher: function(matcher) {
        var index = Array.prototype.indexOf.call(this, matcher);
        if (index !== -1) {
          Array.prototype.splice.call(this, index, 1);
        }
      }
    };
    exports.MatcherList = CSSOM.MatcherList;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSDocumentRule.js
var require_CSSDocumentRule = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSDocumentRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      MatcherList: require_MatcherList().MatcherList
    };
    CSSOM.CSSDocumentRule = function CSSDocumentRule() {
      CSSOM.CSSRule.call(this);
      this.matcher = new CSSOM.MatcherList();
      this.cssRules = [];
    };
    CSSOM.CSSDocumentRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSDocumentRule.prototype.constructor = CSSOM.CSSDocumentRule;
    CSSOM.CSSDocumentRule.prototype.type = 10;
    Object.defineProperty(CSSOM.CSSDocumentRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i2 = 0, length = this.cssRules.length; i2 < length; i2++) {
          cssTexts.push(this.cssRules[i2].cssText);
        }
        return "@-moz-document " + this.matcher.matcherText + " {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSDocumentRule = CSSOM.CSSDocumentRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/parse.js
var require_parse2 = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/parse.js"(exports) {
    var CSSOM = {};
    CSSOM.parse = function parse6(token) {
      var i2 = 0;
      var state = "before-selector";
      var index;
      var buffer = "";
      var valueParenthesisDepth = 0;
      var SIGNIFICANT_WHITESPACE = {
        "selector": true,
        "value": true,
        "value-parenthesis": true,
        "atRule": true,
        "importRule-begin": true,
        "importRule": true,
        "atBlock": true,
        "conditionBlock": true,
        "documentRule-begin": true
      };
      var styleSheet = new CSSOM.CSSStyleSheet();
      var currentScope = styleSheet;
      var parentRule;
      var ancestorRules = [];
      var hasAncestors = false;
      var prevScope;
      var name, priority = "", styleRule, mediaRule, supportsRule, importRule, fontFaceRule, keyframesRule, documentRule, hostRule;
      var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;
      var parseError = function(message) {
        var lines = token.substring(0, i2).split("\n");
        var lineCount = lines.length;
        var charCount = lines.pop().length + 1;
        var error = new Error(message + " (line " + lineCount + ", char " + charCount + ")");
        error.line = lineCount;
        error["char"] = charCount;
        error.styleSheet = styleSheet;
        throw error;
      };
      for (var character; character = token.charAt(i2); i2++) {
        switch (character) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\f":
            if (SIGNIFICANT_WHITESPACE[state]) {
              buffer += character;
            }
            break;
          // String
          case '"':
            index = i2 + 1;
            do {
              index = token.indexOf('"', index) + 1;
              if (!index) {
                parseError('Unmatched "');
              }
            } while (token[index - 2] === "\\");
            buffer += token.slice(i2, index);
            i2 = index - 1;
            switch (state) {
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            break;
          case "'":
            index = i2 + 1;
            do {
              index = token.indexOf("'", index) + 1;
              if (!index) {
                parseError("Unmatched '");
              }
            } while (token[index - 2] === "\\");
            buffer += token.slice(i2, index);
            i2 = index - 1;
            switch (state) {
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            break;
          // Comment
          case "/":
            if (token.charAt(i2 + 1) === "*") {
              i2 += 2;
              index = token.indexOf("*/", i2);
              if (index === -1) {
                parseError("Missing */");
              } else {
                i2 = index + 1;
              }
            } else {
              buffer += character;
            }
            if (state === "importRule-begin") {
              buffer += " ";
              state = "importRule";
            }
            break;
          // At-rule
          case "@":
            if (token.indexOf("@-moz-document", i2) === i2) {
              state = "documentRule-begin";
              documentRule = new CSSOM.CSSDocumentRule();
              documentRule.__starts = i2;
              i2 += "-moz-document".length;
              buffer = "";
              break;
            } else if (token.indexOf("@media", i2) === i2) {
              state = "atBlock";
              mediaRule = new CSSOM.CSSMediaRule();
              mediaRule.__starts = i2;
              i2 += "media".length;
              buffer = "";
              break;
            } else if (token.indexOf("@supports", i2) === i2) {
              state = "conditionBlock";
              supportsRule = new CSSOM.CSSSupportsRule();
              supportsRule.__starts = i2;
              i2 += "supports".length;
              buffer = "";
              break;
            } else if (token.indexOf("@host", i2) === i2) {
              state = "hostRule-begin";
              i2 += "host".length;
              hostRule = new CSSOM.CSSHostRule();
              hostRule.__starts = i2;
              buffer = "";
              break;
            } else if (token.indexOf("@import", i2) === i2) {
              state = "importRule-begin";
              i2 += "import".length;
              buffer += "@import";
              break;
            } else if (token.indexOf("@font-face", i2) === i2) {
              state = "fontFaceRule-begin";
              i2 += "font-face".length;
              fontFaceRule = new CSSOM.CSSFontFaceRule();
              fontFaceRule.__starts = i2;
              buffer = "";
              break;
            } else {
              atKeyframesRegExp.lastIndex = i2;
              var matchKeyframes = atKeyframesRegExp.exec(token);
              if (matchKeyframes && matchKeyframes.index === i2) {
                state = "keyframesRule-begin";
                keyframesRule = new CSSOM.CSSKeyframesRule();
                keyframesRule.__starts = i2;
                keyframesRule._vendorPrefix = matchKeyframes[1];
                i2 += matchKeyframes[0].length - 1;
                buffer = "";
                break;
              } else if (state === "selector") {
                state = "atRule";
              }
            }
            buffer += character;
            break;
          case "{":
            if (state === "selector" || state === "atRule") {
              styleRule.selectorText = buffer.trim();
              styleRule.style.__starts = i2;
              buffer = "";
              state = "before-name";
            } else if (state === "atBlock") {
              mediaRule.media.mediaText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = mediaRule;
              mediaRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "conditionBlock") {
              supportsRule.conditionText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = supportsRule;
              supportsRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "hostRule-begin") {
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = hostRule;
              hostRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "fontFaceRule-begin") {
              if (parentRule) {
                fontFaceRule.parentRule = parentRule;
              }
              fontFaceRule.parentStyleSheet = styleSheet;
              styleRule = fontFaceRule;
              buffer = "";
              state = "before-name";
            } else if (state === "keyframesRule-begin") {
              keyframesRule.name = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
                keyframesRule.parentRule = parentRule;
              }
              keyframesRule.parentStyleSheet = styleSheet;
              currentScope = parentRule = keyframesRule;
              buffer = "";
              state = "keyframeRule-begin";
            } else if (state === "keyframeRule-begin") {
              styleRule = new CSSOM.CSSKeyframeRule();
              styleRule.keyText = buffer.trim();
              styleRule.__starts = i2;
              buffer = "";
              state = "before-name";
            } else if (state === "documentRule-begin") {
              documentRule.matcher.matcherText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
                documentRule.parentRule = parentRule;
              }
              currentScope = parentRule = documentRule;
              documentRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            }
            break;
          case ":":
            if (state === "name") {
              name = buffer.trim();
              buffer = "";
              state = "before-value";
            } else {
              buffer += character;
            }
            break;
          case "(":
            if (state === "value") {
              if (buffer.trim() === "expression") {
                var info = new CSSOM.CSSValueExpression(token, i2).parse();
                if (info.error) {
                  parseError(info.error);
                } else {
                  buffer += info.expression;
                  i2 = info.idx;
                }
              } else {
                state = "value-parenthesis";
                valueParenthesisDepth = 1;
                buffer += character;
              }
            } else if (state === "value-parenthesis") {
              valueParenthesisDepth++;
              buffer += character;
            } else {
              buffer += character;
            }
            break;
          case ")":
            if (state === "value-parenthesis") {
              valueParenthesisDepth--;
              if (valueParenthesisDepth === 0) state = "value";
            }
            buffer += character;
            break;
          case "!":
            if (state === "value" && token.indexOf("!important", i2) === i2) {
              priority = "important";
              i2 += "important".length;
            } else {
              buffer += character;
            }
            break;
          case ";":
            switch (state) {
              case "value":
                styleRule.style.setProperty(name, buffer.trim(), priority);
                priority = "";
                buffer = "";
                state = "before-name";
                break;
              case "atRule":
                buffer = "";
                state = "before-selector";
                break;
              case "importRule":
                importRule = new CSSOM.CSSImportRule();
                importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
                importRule.cssText = buffer + character;
                styleSheet.cssRules.push(importRule);
                buffer = "";
                state = "before-selector";
                break;
              default:
                buffer += character;
                break;
            }
            break;
          case "}":
            switch (state) {
              case "value":
                styleRule.style.setProperty(name, buffer.trim(), priority);
                priority = "";
              /* falls through */
              case "before-name":
              case "name":
                styleRule.__ends = i2 + 1;
                if (parentRule) {
                  styleRule.parentRule = parentRule;
                }
                styleRule.parentStyleSheet = styleSheet;
                currentScope.cssRules.push(styleRule);
                buffer = "";
                if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
                  state = "keyframeRule-begin";
                } else {
                  state = "before-selector";
                }
                break;
              case "keyframeRule-begin":
              case "before-selector":
              case "selector":
                if (!parentRule) {
                  parseError("Unexpected }");
                }
                hasAncestors = ancestorRules.length > 0;
                while (ancestorRules.length > 0) {
                  parentRule = ancestorRules.pop();
                  if (parentRule.constructor.name === "CSSMediaRule" || parentRule.constructor.name === "CSSSupportsRule") {
                    prevScope = currentScope;
                    currentScope = parentRule;
                    currentScope.cssRules.push(prevScope);
                    break;
                  }
                  if (ancestorRules.length === 0) {
                    hasAncestors = false;
                  }
                }
                if (!hasAncestors) {
                  currentScope.__ends = i2 + 1;
                  styleSheet.cssRules.push(currentScope);
                  currentScope = styleSheet;
                  parentRule = null;
                }
                buffer = "";
                state = "before-selector";
                break;
            }
            break;
          default:
            switch (state) {
              case "before-selector":
                state = "selector";
                styleRule = new CSSOM.CSSStyleRule();
                styleRule.__starts = i2;
                break;
              case "before-name":
                state = "name";
                break;
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            buffer += character;
            break;
        }
      }
      return styleSheet;
    };
    exports.parse = CSSOM.parse;
    CSSOM.CSSStyleSheet = require_CSSStyleSheet().CSSStyleSheet;
    CSSOM.CSSStyleRule = require_CSSStyleRule().CSSStyleRule;
    CSSOM.CSSImportRule = require_CSSImportRule().CSSImportRule;
    CSSOM.CSSGroupingRule = require_CSSGroupingRule().CSSGroupingRule;
    CSSOM.CSSMediaRule = require_CSSMediaRule().CSSMediaRule;
    CSSOM.CSSConditionRule = require_CSSConditionRule().CSSConditionRule;
    CSSOM.CSSSupportsRule = require_CSSSupportsRule().CSSSupportsRule;
    CSSOM.CSSFontFaceRule = require_CSSFontFaceRule().CSSFontFaceRule;
    CSSOM.CSSHostRule = require_CSSHostRule().CSSHostRule;
    CSSOM.CSSStyleDeclaration = require_CSSStyleDeclaration().CSSStyleDeclaration;
    CSSOM.CSSKeyframeRule = require_CSSKeyframeRule().CSSKeyframeRule;
    CSSOM.CSSKeyframesRule = require_CSSKeyframesRule().CSSKeyframesRule;
    CSSOM.CSSValueExpression = require_CSSValueExpression().CSSValueExpression;
    CSSOM.CSSDocumentRule = require_CSSDocumentRule().CSSDocumentRule;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSStyleDeclaration.js
var require_CSSStyleDeclaration = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/CSSStyleDeclaration.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration2() {
      this.length = 0;
      this.parentRule = null;
      this._importants = {};
    };
    CSSOM.CSSStyleDeclaration.prototype = {
      constructor: CSSOM.CSSStyleDeclaration,
      /**
       *
       * @param {string} name
       * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-getPropertyValue
       * @return {string} the value of the property if it has been explicitly set for this declaration block.
       * Returns the empty string if the property has not been set.
       */
      getPropertyValue: function(name) {
        return this[name] || "";
      },
      /**
       *
       * @param {string} name
       * @param {string} value
       * @param {string} [priority=null] "important" or null
       * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-setProperty
       */
      setProperty: function(name, value, priority) {
        if (this[name]) {
          var index = Array.prototype.indexOf.call(this, name);
          if (index < 0) {
            this[this.length] = name;
            this.length++;
          }
        } else {
          this[this.length] = name;
          this.length++;
        }
        this[name] = value + "";
        this._importants[name] = priority;
      },
      /**
       *
       * @param {string} name
       * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-removeProperty
       * @return {string} the value of the property if it has been explicitly set for this declaration block.
       * Returns the empty string if the property has not been set or the property name does not correspond to a known CSS property.
       */
      removeProperty: function(name) {
        if (!(name in this)) {
          return "";
        }
        var index = Array.prototype.indexOf.call(this, name);
        if (index < 0) {
          return "";
        }
        var prevValue = this[name];
        this[name] = "";
        Array.prototype.splice.call(this, index, 1);
        return prevValue;
      },
      getPropertyCSSValue: function() {
      },
      /**
       *
       * @param {String} name
       */
      getPropertyPriority: function(name) {
        return this._importants[name] || "";
      },
      /**
       *   element.style.overflow = "auto"
       *   element.style.getPropertyShorthand("overflow-x")
       *   -> "overflow"
       */
      getPropertyShorthand: function() {
      },
      isPropertyImplicit: function() {
      },
      // Doesn't work in IE < 9
      get cssText() {
        var properties = [];
        for (var i2 = 0, length = this.length; i2 < length; ++i2) {
          var name = this[i2];
          var value = this.getPropertyValue(name);
          var priority = this.getPropertyPriority(name);
          if (priority) {
            priority = " !" + priority;
          }
          properties[i2] = name + ": " + value + priority + ";";
        }
        return properties.join(" ");
      },
      set cssText(text) {
        var i2, name;
        for (i2 = this.length; i2--; ) {
          name = this[i2];
          this[name] = "";
        }
        Array.prototype.splice.call(this, 0, this.length);
        this._importants = {};
        var dummyRule = CSSOM.parse("#bogus{" + text + "}").cssRules[0].style;
        var length = dummyRule.length;
        for (i2 = 0; i2 < length; ++i2) {
          name = dummyRule[i2];
          this.setProperty(dummyRule[i2], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
        }
      }
    };
    exports.CSSStyleDeclaration = CSSOM.CSSStyleDeclaration;
    CSSOM.parse = require_parse2().parse;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/clone.js
var require_clone = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/clone.js"(exports) {
    var CSSOM = {
      CSSStyleSheet: require_CSSStyleSheet().CSSStyleSheet,
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleRule: require_CSSStyleRule().CSSStyleRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule,
      CSSMediaRule: require_CSSMediaRule().CSSMediaRule,
      CSSSupportsRule: require_CSSSupportsRule().CSSSupportsRule,
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSKeyframeRule: require_CSSKeyframeRule().CSSKeyframeRule,
      CSSKeyframesRule: require_CSSKeyframesRule().CSSKeyframesRule
    };
    CSSOM.clone = function clone(stylesheet) {
      var cloned = new CSSOM.CSSStyleSheet();
      var rules = stylesheet.cssRules;
      if (!rules) {
        return cloned;
      }
      for (var i2 = 0, rulesLength = rules.length; i2 < rulesLength; i2++) {
        var rule = rules[i2];
        var ruleClone = cloned.cssRules[i2] = new rule.constructor();
        var style = rule.style;
        if (style) {
          var styleClone = ruleClone.style = new CSSOM.CSSStyleDeclaration();
          for (var j5 = 0, styleLength = style.length; j5 < styleLength; j5++) {
            var name = styleClone[j5] = style[j5];
            styleClone[name] = style[name];
            styleClone._importants[name] = style.getPropertyPriority(name);
          }
          styleClone.length = style.length;
        }
        if (rule.hasOwnProperty("keyText")) {
          ruleClone.keyText = rule.keyText;
        }
        if (rule.hasOwnProperty("selectorText")) {
          ruleClone.selectorText = rule.selectorText;
        }
        if (rule.hasOwnProperty("mediaText")) {
          ruleClone.mediaText = rule.mediaText;
        }
        if (rule.hasOwnProperty("conditionText")) {
          ruleClone.conditionText = rule.conditionText;
        }
        if (rule.hasOwnProperty("cssRules")) {
          ruleClone.cssRules = clone(rule).cssRules;
        }
      }
      return cloned;
    };
    exports.clone = CSSOM.clone;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/index.js
var require_lib = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/cssom@0.5.0/node_modules/cssom/lib/index.js"(exports) {
    "use strict";
    exports.CSSStyleDeclaration = require_CSSStyleDeclaration().CSSStyleDeclaration;
    exports.CSSRule = require_CSSRule().CSSRule;
    exports.CSSGroupingRule = require_CSSGroupingRule().CSSGroupingRule;
    exports.CSSConditionRule = require_CSSConditionRule().CSSConditionRule;
    exports.CSSStyleRule = require_CSSStyleRule().CSSStyleRule;
    exports.MediaList = require_MediaList().MediaList;
    exports.CSSMediaRule = require_CSSMediaRule().CSSMediaRule;
    exports.CSSSupportsRule = require_CSSSupportsRule().CSSSupportsRule;
    exports.CSSImportRule = require_CSSImportRule().CSSImportRule;
    exports.CSSFontFaceRule = require_CSSFontFaceRule().CSSFontFaceRule;
    exports.CSSHostRule = require_CSSHostRule().CSSHostRule;
    exports.StyleSheet = require_StyleSheet().StyleSheet;
    exports.CSSStyleSheet = require_CSSStyleSheet().CSSStyleSheet;
    exports.CSSKeyframesRule = require_CSSKeyframesRule().CSSKeyframesRule;
    exports.CSSKeyframeRule = require_CSSKeyframeRule().CSSKeyframeRule;
    exports.MatcherList = require_MatcherList().MatcherList;
    exports.CSSDocumentRule = require_CSSDocumentRule().CSSDocumentRule;
    exports.CSSValue = require_CSSValue().CSSValue;
    exports.CSSValueExpression = require_CSSValueExpression().CSSValueExpression;
    exports.parse = require_parse2().parse;
    exports.clone = require_clone().clone;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/commonjs/canvas-shim.cjs
var require_canvas_shim = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/commonjs/canvas-shim.cjs"(exports, module) {
    var Canvas2 = class {
      constructor(width, height) {
        this.width = width;
        this.height = height;
      }
      getContext() {
        return null;
      }
      toDataURL() {
        return "";
      }
    };
    module.exports = {
      createCanvas: (width, height) => new Canvas2(width, height)
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/commonjs/canvas.cjs
var require_canvas = __commonJS({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/commonjs/canvas.cjs"(exports, module) {
    try {
      module.exports = __require("canvas");
    } catch (fallback) {
      module.exports = require_canvas_shim();
    }
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/lexical@0.32.1/node_modules/lexical/Lexical.dev.mjs
var Lexical_dev_exports = {};
__export(Lexical_dev_exports, {
  $addUpdateTag: () => $addUpdateTag,
  $applyNodeReplacement: () => $applyNodeReplacement,
  $caretFromPoint: () => $caretFromPoint,
  $caretRangeFromSelection: () => $caretRangeFromSelection,
  $cloneWithProperties: () => $cloneWithProperties,
  $comparePointCaretNext: () => $comparePointCaretNext,
  $copyNode: () => $copyNode,
  $createLineBreakNode: () => $createLineBreakNode,
  $createNodeSelection: () => $createNodeSelection,
  $createParagraphNode: () => $createParagraphNode,
  $createPoint: () => $createPoint,
  $createRangeSelection: () => $createRangeSelection,
  $createRangeSelectionFromDom: () => $createRangeSelectionFromDom,
  $createTabNode: () => $createTabNode,
  $createTextNode: () => $createTextNode,
  $extendCaretToRange: () => $extendCaretToRange,
  $getAdjacentChildCaret: () => $getAdjacentChildCaret,
  $getAdjacentNode: () => $getAdjacentNode,
  $getAdjacentSiblingOrParentSiblingCaret: () => $getAdjacentSiblingOrParentSiblingCaret,
  $getCaretInDirection: () => $getCaretInDirection,
  $getCaretRange: () => $getCaretRange,
  $getCaretRangeInDirection: () => $getCaretRangeInDirection,
  $getCharacterOffsets: () => $getCharacterOffsets,
  $getChildCaret: () => $getChildCaret,
  $getChildCaretAtIndex: () => $getChildCaretAtIndex,
  $getChildCaretOrSelf: () => $getChildCaretOrSelf,
  $getCollapsedCaretRange: () => $getCollapsedCaretRange,
  $getCommonAncestor: () => $getCommonAncestor,
  $getCommonAncestorResultBranchOrder: () => $getCommonAncestorResultBranchOrder,
  $getEditor: () => $getEditor,
  $getNearestNodeFromDOMNode: () => $getNearestNodeFromDOMNode,
  $getNearestRootOrShadowRoot: () => $getNearestRootOrShadowRoot,
  $getNodeByKey: () => $getNodeByKey,
  $getNodeByKeyOrThrow: () => $getNodeByKeyOrThrow,
  $getPreviousSelection: () => $getPreviousSelection,
  $getRoot: () => $getRoot,
  $getSelection: () => $getSelection,
  $getSiblingCaret: () => $getSiblingCaret,
  $getState: () => $getState,
  $getStateChange: () => $getStateChange,
  $getTextContent: () => $getTextContent,
  $getTextNodeOffset: () => $getTextNodeOffset,
  $getTextPointCaret: () => $getTextPointCaret,
  $getTextPointCaretSlice: () => $getTextPointCaretSlice,
  $getWritableNodeState: () => $getWritableNodeState,
  $hasAncestor: () => $hasAncestor,
  $hasUpdateTag: () => $hasUpdateTag,
  $insertNodes: () => $insertNodes,
  $isBlockElementNode: () => $isBlockElementNode,
  $isChildCaret: () => $isChildCaret,
  $isDecoratorNode: () => $isDecoratorNode,
  $isElementNode: () => $isElementNode,
  $isExtendableTextPointCaret: () => $isExtendableTextPointCaret,
  $isInlineElementOrDecoratorNode: () => $isInlineElementOrDecoratorNode,
  $isLeafNode: () => $isLeafNode,
  $isLineBreakNode: () => $isLineBreakNode,
  $isNodeCaret: () => $isNodeCaret,
  $isNodeSelection: () => $isNodeSelection,
  $isParagraphNode: () => $isParagraphNode,
  $isRangeSelection: () => $isRangeSelection,
  $isRootNode: () => $isRootNode,
  $isRootOrShadowRoot: () => $isRootOrShadowRoot,
  $isSiblingCaret: () => $isSiblingCaret,
  $isTabNode: () => $isTabNode,
  $isTextNode: () => $isTextNode,
  $isTextPointCaret: () => $isTextPointCaret,
  $isTextPointCaretSlice: () => $isTextPointCaretSlice,
  $isTokenOrSegmented: () => $isTokenOrSegmented,
  $isTokenOrTab: () => $isTokenOrTab,
  $nodesOfType: () => $nodesOfType,
  $normalizeCaret: () => $normalizeCaret,
  $normalizeSelection__EXPERIMENTAL: () => $normalizeSelection,
  $onUpdate: () => $onUpdate,
  $parseSerializedNode: () => $parseSerializedNode,
  $removeTextFromCaretRange: () => $removeTextFromCaretRange,
  $rewindSiblingCaret: () => $rewindSiblingCaret,
  $selectAll: () => $selectAll,
  $setCompositionKey: () => $setCompositionKey,
  $setPointFromCaret: () => $setPointFromCaret,
  $setSelection: () => $setSelection,
  $setSelectionFromCaretRange: () => $setSelectionFromCaretRange,
  $setState: () => $setState,
  $splitAtPointCaretNext: () => $splitAtPointCaretNext,
  $splitNode: () => $splitNode,
  $updateRangeSelectionFromCaretRange: () => $updateRangeSelectionFromCaretRange,
  ArtificialNode__DO_NOT_USE: () => ArtificialNode__DO_NOT_USE,
  BLUR_COMMAND: () => BLUR_COMMAND,
  CAN_REDO_COMMAND: () => CAN_REDO_COMMAND,
  CAN_UNDO_COMMAND: () => CAN_UNDO_COMMAND,
  CLEAR_EDITOR_COMMAND: () => CLEAR_EDITOR_COMMAND,
  CLEAR_HISTORY_COMMAND: () => CLEAR_HISTORY_COMMAND,
  CLICK_COMMAND: () => CLICK_COMMAND,
  COLLABORATION_TAG: () => COLLABORATION_TAG,
  COMMAND_PRIORITY_CRITICAL: () => COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR: () => COMMAND_PRIORITY_EDITOR,
  COMMAND_PRIORITY_HIGH: () => COMMAND_PRIORITY_HIGH,
  COMMAND_PRIORITY_LOW: () => COMMAND_PRIORITY_LOW,
  COMMAND_PRIORITY_NORMAL: () => COMMAND_PRIORITY_NORMAL,
  CONTROLLED_TEXT_INSERTION_COMMAND: () => CONTROLLED_TEXT_INSERTION_COMMAND,
  COPY_COMMAND: () => COPY_COMMAND,
  CUT_COMMAND: () => CUT_COMMAND,
  DELETE_CHARACTER_COMMAND: () => DELETE_CHARACTER_COMMAND,
  DELETE_LINE_COMMAND: () => DELETE_LINE_COMMAND,
  DELETE_WORD_COMMAND: () => DELETE_WORD_COMMAND,
  DRAGEND_COMMAND: () => DRAGEND_COMMAND,
  DRAGOVER_COMMAND: () => DRAGOVER_COMMAND,
  DRAGSTART_COMMAND: () => DRAGSTART_COMMAND,
  DROP_COMMAND: () => DROP_COMMAND,
  DecoratorNode: () => DecoratorNode,
  ElementNode: () => ElementNode,
  FOCUS_COMMAND: () => FOCUS_COMMAND,
  FORMAT_ELEMENT_COMMAND: () => FORMAT_ELEMENT_COMMAND,
  FORMAT_TEXT_COMMAND: () => FORMAT_TEXT_COMMAND,
  HISTORIC_TAG: () => HISTORIC_TAG,
  HISTORY_MERGE_TAG: () => HISTORY_MERGE_TAG,
  HISTORY_PUSH_TAG: () => HISTORY_PUSH_TAG,
  INDENT_CONTENT_COMMAND: () => INDENT_CONTENT_COMMAND,
  INSERT_LINE_BREAK_COMMAND: () => INSERT_LINE_BREAK_COMMAND,
  INSERT_PARAGRAPH_COMMAND: () => INSERT_PARAGRAPH_COMMAND,
  INSERT_TAB_COMMAND: () => INSERT_TAB_COMMAND,
  INTERNAL_$isBlock: () => INTERNAL_$isBlock,
  IS_ALL_FORMATTING: () => IS_ALL_FORMATTING,
  IS_BOLD: () => IS_BOLD,
  IS_CODE: () => IS_CODE,
  IS_HIGHLIGHT: () => IS_HIGHLIGHT,
  IS_ITALIC: () => IS_ITALIC,
  IS_STRIKETHROUGH: () => IS_STRIKETHROUGH,
  IS_SUBSCRIPT: () => IS_SUBSCRIPT,
  IS_SUPERSCRIPT: () => IS_SUPERSCRIPT,
  IS_UNDERLINE: () => IS_UNDERLINE,
  KEY_ARROW_DOWN_COMMAND: () => KEY_ARROW_DOWN_COMMAND,
  KEY_ARROW_LEFT_COMMAND: () => KEY_ARROW_LEFT_COMMAND,
  KEY_ARROW_RIGHT_COMMAND: () => KEY_ARROW_RIGHT_COMMAND,
  KEY_ARROW_UP_COMMAND: () => KEY_ARROW_UP_COMMAND,
  KEY_BACKSPACE_COMMAND: () => KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND: () => KEY_DELETE_COMMAND,
  KEY_DOWN_COMMAND: () => KEY_DOWN_COMMAND,
  KEY_ENTER_COMMAND: () => KEY_ENTER_COMMAND,
  KEY_ESCAPE_COMMAND: () => KEY_ESCAPE_COMMAND,
  KEY_MODIFIER_COMMAND: () => KEY_MODIFIER_COMMAND,
  KEY_SPACE_COMMAND: () => KEY_SPACE_COMMAND,
  KEY_TAB_COMMAND: () => KEY_TAB_COMMAND,
  LineBreakNode: () => LineBreakNode,
  MOVE_TO_END: () => MOVE_TO_END,
  MOVE_TO_START: () => MOVE_TO_START,
  NODE_STATE_KEY: () => NODE_STATE_KEY,
  OUTDENT_CONTENT_COMMAND: () => OUTDENT_CONTENT_COMMAND,
  PASTE_COMMAND: () => PASTE_COMMAND,
  PASTE_TAG: () => PASTE_TAG,
  ParagraphNode: () => ParagraphNode,
  REDO_COMMAND: () => REDO_COMMAND,
  REMOVE_TEXT_COMMAND: () => REMOVE_TEXT_COMMAND,
  RootNode: () => RootNode,
  SELECTION_CHANGE_COMMAND: () => SELECTION_CHANGE_COMMAND,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
  SELECT_ALL_COMMAND: () => SELECT_ALL_COMMAND,
  SKIP_COLLAB_TAG: () => SKIP_COLLAB_TAG,
  SKIP_DOM_SELECTION_TAG: () => SKIP_DOM_SELECTION_TAG,
  SKIP_SCROLL_INTO_VIEW_TAG: () => SKIP_SCROLL_INTO_VIEW_TAG,
  TEXT_TYPE_TO_FORMAT: () => TEXT_TYPE_TO_FORMAT,
  TabNode: () => TabNode,
  TextNode: () => TextNode,
  UNDO_COMMAND: () => UNDO_COMMAND,
  createCommand: () => createCommand,
  createEditor: () => createEditor,
  createState: () => createState,
  flipDirection: () => flipDirection,
  getDOMOwnerDocument: () => getDOMOwnerDocument,
  getDOMSelection: () => getDOMSelection,
  getDOMSelectionFromTarget: () => getDOMSelectionFromTarget,
  getDOMTextNode: () => getDOMTextNode,
  getEditorPropertyFromDOMNode: () => getEditorPropertyFromDOMNode,
  getNearestEditorFromDOMNode: () => getNearestEditorFromDOMNode,
  isBlockDomNode: () => isBlockDomNode,
  isCurrentlyReadOnlyMode: () => isCurrentlyReadOnlyMode,
  isDOMDocumentNode: () => isDOMDocumentNode,
  isDOMNode: () => isDOMNode,
  isDOMTextNode: () => isDOMTextNode,
  isDOMUnmanaged: () => isDOMUnmanaged,
  isDocumentFragment: () => isDocumentFragment,
  isExactShortcutMatch: () => isExactShortcutMatch,
  isHTMLAnchorElement: () => isHTMLAnchorElement,
  isHTMLElement: () => isHTMLElement,
  isInlineDomNode: () => isInlineDomNode,
  isLexicalEditor: () => isLexicalEditor,
  isModifierMatch: () => isModifierMatch,
  isSelectionCapturedInDecoratorInput: () => isSelectionCapturedInDecoratorInput,
  isSelectionWithinEditor: () => isSelectionWithinEditor,
  makeStepwiseIterator: () => makeStepwiseIterator,
  removeFromParent: () => removeFromParent,
  resetRandomKey: () => resetRandomKey,
  setDOMUnmanaged: () => setDOMUnmanaged,
  setNodeIndentFromDOM: () => setNodeIndentFromDOM
});
function formatDevErrorMessage(message) {
  throw new Error(message);
}
function normalizeClassNames(...classNames2) {
  const rval = [];
  for (const className of classNames2) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = editor._pendingDecorators;
  let decorators = pendingDecorators || currentDecorators;
  const nodeMap = pendingEditorState._nodeMap;
  let key2;
  for (key2 in decorators) {
    if (!nodeMap.has(key2)) {
      if (decorators === currentDecorators) {
        decorators = cloneDecorators(editor);
      }
      delete decorators[key2];
    }
  }
}
function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
  let child = node.getFirstChild();
  while (child !== null) {
    const childKey = child.__key;
    if (child.__parent === parentKey) {
      if ($isElementNode(child)) {
        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
      }
      if (!prevNodeMap.has(childKey)) {
        dirtyNodes.delete(childKey);
      }
      nodeMapDelete.push(childKey);
    }
    child = child.getNextSibling();
  }
}
function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
  const prevNodeMap = prevEditorState._nodeMap;
  const nodeMap = editorState._nodeMap;
  const nodeMapDelete = [];
  for (const [nodeKey] of dirtyElements) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0) {
      if (!node.isAttached()) {
        if ($isElementNode(node)) {
          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
        }
        if (!prevNodeMap.has(nodeKey)) {
          dirtyElements.delete(nodeKey);
        }
        nodeMapDelete.push(nodeKey);
      }
    }
  }
  for (const nodeKey of nodeMapDelete) {
    nodeMap.delete(nodeKey);
  }
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0 && !node.isAttached()) {
      if (!prevNodeMap.has(nodeKey)) {
        dirtyLeaves.delete(nodeKey);
      }
      nodeMap.delete(nodeKey);
    }
  }
}
function getIsProcessingMutations() {
  return isProcessingMutations;
}
function updateTimeStamp(event) {
  lastTextEntryTimeStamp = event.timeStamp;
}
function initTextEntryListener(editor) {
  if (lastTextEntryTimeStamp === 0) {
    getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
  }
}
function isManagedLineBreak(dom2, target, editor) {
  const isBR = dom2.nodeName === "BR";
  const lexicalLineBreak = target.__lexicalLineBreak;
  return lexicalLineBreak && (dom2 === lexicalLineBreak || isBR && dom2.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom2, editor) !== void 0;
}
function getLastSelection(editor) {
  return editor.getEditorState().read(() => {
    const selection = $getSelection();
    return selection !== null ? selection.clone() : null;
  });
}
function $handleTextMutation(target, node, editor) {
  const domSelection = getDOMSelection(getWindow(editor));
  let anchorOffset = null;
  let focusOffset = null;
  if (domSelection !== null && domSelection.anchorNode === target) {
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
  }
  const text = target.nodeValue;
  if (text !== null) {
    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);
  }
}
function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
  if ($isRangeSelection(selection)) {
    const anchorNode = selection.anchor.getNode();
    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
      return false;
    }
  }
  return isDOMTextNode(targetDOM) && targetNode.isAttached();
}
function $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {
  for (let dom2 = startingDOM; dom2 && !isDOMUnmanaged(dom2); dom2 = getParentElement(dom2)) {
    const key2 = getNodeKeyFromDOMNode(dom2, editor);
    if (key2 !== void 0) {
      const node = $getNodeByKey(key2, editorState);
      if (node) {
        return $isDecoratorNode(node) || !isHTMLElement(dom2) ? void 0 : [dom2, node];
      }
    } else if (dom2 === rootElement) {
      return [rootElement, internalGetRoot(editorState)];
    }
  }
}
function flushMutations(editor, mutations, observer) {
  isProcessingMutations = true;
  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
  try {
    updateEditorSync(editor, () => {
      const selection = $getSelection() || getLastSelection(editor);
      const badDOMTargets = /* @__PURE__ */ new Map();
      const rootElement = editor.getRootElement();
      const currentEditorState = editor._editorState;
      const blockCursorElement = editor._blockCursorElement;
      let shouldRevertSelection = false;
      let possibleTextForFirefoxPaste = "";
      for (let i2 = 0; i2 < mutations.length; i2++) {
        const mutation = mutations[i2];
        const type = mutation.type;
        const targetDOM = mutation.target;
        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);
        if (!pair) {
          continue;
        }
        const [nodeDOM, targetNode] = pair;
        if (type === "characterData") {
          if (shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {
            $handleTextMutation(targetDOM, targetNode, editor);
          }
        } else if (type === "childList") {
          shouldRevertSelection = true;
          const addedDOMs = mutation.addedNodes;
          for (let s2 = 0; s2 < addedDOMs.length; s2++) {
            const addedDOM = addedDOMs[s2];
            const node = $getNodeFromDOMNode(addedDOM);
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {
              if (IS_FIREFOX) {
                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;
                if (possibleText) {
                  possibleTextForFirefoxPaste += possibleText;
                }
              }
              parentDOM.removeChild(addedDOM);
            }
          }
          const removedDOMs = mutation.removedNodes;
          const removedDOMsLength = removedDOMs.length;
          if (removedDOMsLength > 0) {
            let unremovedBRs = 0;
            for (let s2 = 0; s2 < removedDOMsLength; s2++) {
              const removedDOM = removedDOMs[s2];
              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                targetDOM.appendChild(removedDOM);
                unremovedBRs++;
              }
            }
            if (removedDOMsLength !== unremovedBRs) {
              badDOMTargets.set(nodeDOM, targetNode);
            }
          }
        }
      }
      if (badDOMTargets.size > 0) {
        for (const [nodeDOM, targetNode] of badDOMTargets) {
          targetNode.reconcileObservedMutation(nodeDOM, editor);
        }
      }
      const records = observer.takeRecords();
      if (records.length > 0) {
        for (let i2 = 0; i2 < records.length; i2++) {
          const record = records[i2];
          const addedNodes = record.addedNodes;
          const target = record.target;
          for (let s2 = 0; s2 < addedNodes.length; s2++) {
            const addedDOM = addedNodes[s2];
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
              parentDOM.removeChild(addedDOM);
            }
          }
        }
        observer.takeRecords();
      }
      if (selection !== null) {
        if (shouldRevertSelection) {
          $setSelection(selection);
        }
        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
          selection.insertRawText(possibleTextForFirefoxPaste);
        }
      }
    });
  } finally {
    isProcessingMutations = false;
  }
}
function flushRootMutations(editor) {
  const observer = editor._observer;
  if (observer !== null) {
    const mutations = observer.takeRecords();
    flushMutations(editor, mutations, observer);
  }
}
function initMutationObserver(editor) {
  initTextEntryListener(editor);
  editor._observer = new MutationObserver((mutations, observer) => {
    flushMutations(editor, mutations, observer);
  });
}
function coerceToJSON(v4) {
  return v4;
}
function createState(key2, valueConfig) {
  return new StateConfig(key2, valueConfig);
}
function $getStateChange(node, prevNode, stateConfig) {
  const value = $getState(node, stateConfig, "direct");
  const prevValue = $getState(prevNode, stateConfig, "direct");
  return stateConfig.isEqual(value, prevValue) ? null : [value, prevValue];
}
function $getState(node, stateConfig, version = "latest") {
  const latestOrDirectNode = version === "latest" ? node.getLatest() : node;
  const state = latestOrDirectNode.__state;
  if (state) {
    $checkCollision(node, stateConfig, state);
    return state.getValue(stateConfig);
  }
  return stateConfig.defaultValue;
}
function $checkCollision(node, stateConfig, state) {
  {
    const collision = state.sharedConfigMap.get(stateConfig.key);
    if (collision !== void 0 && collision !== stateConfig) {
      {
        formatDevErrorMessage(`$setState: State key collision ${JSON.stringify(stateConfig.key)} detected in ${node.constructor.name} node with type ${node.getType()} and key ${node.getKey()}. Only one StateConfig with a given key should be used on a node.`);
      }
    }
  }
}
function $setState(node, stateConfig, valueOrUpdater) {
  errorOnReadOnly();
  let value;
  if (typeof valueOrUpdater === "function") {
    const latest = node.getLatest();
    const prevValue = $getState(latest, stateConfig);
    value = valueOrUpdater(prevValue);
    if (stateConfig.isEqual(prevValue, value)) {
      return latest;
    }
  } else {
    value = valueOrUpdater;
  }
  const writable = node.getWritable();
  const state = $getWritableNodeState(writable);
  $checkCollision(node, stateConfig, state);
  state.updateFromKnown(stateConfig, value);
  return writable;
}
function computeSize(sharedConfigMap, unknownState, knownState) {
  let size = knownState.size;
  if (unknownState) {
    for (const k5 in unknownState) {
      const sharedConfig = sharedConfigMap.get(k5);
      if (!sharedConfig || !knownState.has(sharedConfig)) {
        size++;
      }
    }
  }
  return size;
}
function undefinedIfEmpty(obj) {
  if (obj) {
    for (const key2 in obj) {
      return obj;
    }
  }
  return void 0;
}
function cloneUnknownState(unknownState) {
  return undefinedIfEmpty(unknownState) && {
    ...unknownState
  };
}
function $getWritableNodeState(node) {
  const writable = node.getWritable();
  const state = writable.__state ? writable.__state.getWritable(writable) : new NodeState(writable);
  writable.__state = state;
  return state;
}
function $updateStateFromJSON(node, unknownState) {
  const writable = node.getWritable();
  if (unknownState || writable.__state) {
    $getWritableNodeState(node).updateFromJSON(unknownState);
  }
  return writable;
}
function $nodeStatesAreEquivalent(a2, b3) {
  if (a2 === b3) {
    return true;
  }
  if (a2 && b3 && a2.size !== b3.size) {
    return false;
  }
  const keys2 = /* @__PURE__ */ new Set();
  const hasUnequalMapEntry = (sourceState, otherState) => {
    for (const [stateConfig, value] of sourceState.knownState) {
      if (keys2.has(stateConfig.key)) {
        continue;
      }
      keys2.add(stateConfig.key);
      const otherValue = otherState ? otherState.getValue(stateConfig) : stateConfig.defaultValue;
      if (otherValue !== value && !stateConfig.isEqual(otherValue, value)) {
        return true;
      }
    }
    return false;
  };
  const hasUnequalRecordEntry = (sourceState, otherState) => {
    const {
      unknownState
    } = sourceState;
    const otherUnknownState = otherState ? otherState.unknownState : void 0;
    if (unknownState) {
      for (const [key2, value] of Object.entries(unknownState)) {
        if (keys2.has(key2)) {
          continue;
        }
        keys2.add(key2);
        const otherValue = otherUnknownState ? otherUnknownState[key2] : void 0;
        if (value !== otherValue) {
          return true;
        }
      }
    }
    return false;
  };
  return !(a2 && hasUnequalMapEntry(a2, b3) || b3 && hasUnequalMapEntry(b3, a2) || a2 && hasUnequalRecordEntry(a2, b3) || b3 && hasUnequalRecordEntry(b3, a2));
}
function $canSimpleTextNodesBeMerged(node1, node2) {
  const node1Mode = node1.__mode;
  const node1Format = node1.__format;
  const node1Style = node1.__style;
  const node2Mode = node2.__mode;
  const node2Format = node2.__format;
  const node2Style = node2.__style;
  const node1State = node1.__state;
  const node2State = node2.__state;
  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style) && (node1.__state === null || node1State === node2State || $nodeStatesAreEquivalent(node1State, node2State));
}
function $mergeTextNodes(node1, node2) {
  const writableNode1 = node1.mergeWithSibling(node2);
  const normalizedNodes = getActiveEditor()._normalizedNodes;
  normalizedNodes.add(node1.__key);
  normalizedNodes.add(node2.__key);
  return writableNode1;
}
function $normalizeTextNode(textNode) {
  let node = textNode;
  if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
    node.remove();
    return;
  }
  let previousNode;
  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
    if (previousNode.__text === "") {
      previousNode.remove();
    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
      node = $mergeTextNodes(previousNode, node);
      break;
    } else {
      break;
    }
  }
  let nextNode;
  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
    if (nextNode.__text === "") {
      nextNode.remove();
    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
      node = $mergeTextNodes(node, nextNode);
      break;
    } else {
      break;
    }
  }
}
function $normalizeSelection(selection) {
  $normalizePoint(selection.anchor);
  $normalizePoint(selection.focus);
  return selection;
}
function $normalizePoint(point) {
  while (point.type === "element") {
    const node = point.getNode();
    const offset = point.offset;
    let nextNode;
    let nextOffsetAtEnd;
    if (offset === node.getChildrenSize()) {
      nextNode = node.getChildAtIndex(offset - 1);
      nextOffsetAtEnd = true;
    } else {
      nextNode = node.getChildAtIndex(offset);
      nextOffsetAtEnd = false;
    }
    if ($isTextNode(nextNode)) {
      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text", true);
      break;
    } else if (!$isElementNode(nextNode)) {
      break;
    }
    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element", true);
  }
}
function destroyNode(key2, parentDOM) {
  const node = activePrevNodeMap.get(key2);
  if (parentDOM !== null) {
    const dom2 = getPrevElementByKeyOrThrow(key2);
    if (dom2.parentNode === parentDOM) {
      parentDOM.removeChild(dom2);
    }
  }
  if (!activeNextNodeMap.has(key2)) {
    activeEditor$1._keyToDOMMap.delete(key2);
  }
  if ($isElementNode(node)) {
    const children = createChildrenArray(node, activePrevNodeMap);
    destroyChildren(children, 0, children.length - 1, null);
  }
  if (node !== void 0) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
  }
}
function destroyChildren(children, _startIndex, endIndex, dom2) {
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    const child = children[startIndex];
    if (child !== void 0) {
      destroyNode(child, dom2);
    }
  }
}
function setTextAlign(domStyle, value) {
  domStyle.setProperty("text-align", value);
}
function setElementIndent(dom2, indent) {
  const indentClassName = activeEditorConfig.theme.indent;
  if (typeof indentClassName === "string") {
    const elementHasClassName = dom2.classList.contains(indentClassName);
    if (indent > 0 && !elementHasClassName) {
      dom2.classList.add(indentClassName);
    } else if (indent < 1 && elementHasClassName) {
      dom2.classList.remove(indentClassName);
    }
  }
  const indentationBaseValue = getComputedStyle(dom2).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
  dom2.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
}
function setElementFormat(dom2, format) {
  const domStyle = dom2.style;
  if (format === 0) {
    setTextAlign(domStyle, "");
  } else if (format === IS_ALIGN_LEFT) {
    setTextAlign(domStyle, "left");
  } else if (format === IS_ALIGN_CENTER) {
    setTextAlign(domStyle, "center");
  } else if (format === IS_ALIGN_RIGHT) {
    setTextAlign(domStyle, "right");
  } else if (format === IS_ALIGN_JUSTIFY) {
    setTextAlign(domStyle, "justify");
  } else if (format === IS_ALIGN_START) {
    setTextAlign(domStyle, "start");
  } else if (format === IS_ALIGN_END) {
    setTextAlign(domStyle, "end");
  }
}
function $createNode(key2, slot) {
  const node = activeNextNodeMap.get(key2);
  if (node === void 0) {
    {
      formatDevErrorMessage(`createNode: node does not exist in nodeMap`);
    }
  }
  const dom2 = node.createDOM(activeEditorConfig, activeEditor$1);
  storeDOMWithKey(key2, dom2, activeEditor$1);
  if ($isTextNode(node)) {
    dom2.setAttribute("data-lexical-text", "true");
  } else if ($isDecoratorNode(node)) {
    dom2.setAttribute("data-lexical-decorator", "true");
  }
  if ($isElementNode(node)) {
    const indent = node.__indent;
    const childrenSize = node.__size;
    if (indent !== 0) {
      setElementIndent(dom2, indent);
    }
    if (childrenSize !== 0) {
      const endIndex = childrenSize - 1;
      const children = createChildrenArray(node, activeNextNodeMap);
      $createChildrenWithDirection(children, endIndex, node, dom2);
    }
    const format = node.__format;
    if (format !== 0) {
      setElementFormat(dom2, format);
    }
    if (!node.isInline()) {
      reconcileElementTerminatingLineBreak(null, node, dom2);
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = node.getTextContent();
    if ($isDecoratorNode(node)) {
      const decorator = node.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key2, decorator);
      }
      dom2.contentEditable = "false";
    } else if ($isTextNode(node)) {
      if (!node.isDirectionless()) {
        subTreeDirectionedTextContent += text;
      }
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (slot !== null) {
    slot.insertChild(dom2);
  }
  {
    Object.freeze(node);
  }
  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
  return dom2;
}
function $createChildrenWithDirection(children, endIndex, element, dom2) {
  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  $createChildren(children, element, 0, endIndex, element.getDOMSlot(dom2));
  reconcileBlockDirection(element, dom2);
  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
}
function $createChildren(children, element, _startIndex, endIndex, slot) {
  const previousSubTreeTextContent = subTreeTextContent;
  subTreeTextContent = "";
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    $createNode(children[startIndex], slot);
    const node = activeNextNodeMap.get(children[startIndex]);
    if (node !== null && $isTextNode(node)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = node.getFormat();
      }
      if (subTreeTextStyle === "") {
        subTreeTextStyle = node.getStyle();
      }
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  const dom2 = slot.element;
  dom2.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function isLastChildLineBreakOrDecorator(element, nodeMap) {
  if (element) {
    const lastKey = element.__last;
    if (lastKey) {
      const node = nodeMap.get(lastKey);
      if (node) {
        return $isLineBreakNode(node) ? "line-break" : $isDecoratorNode(node) && node.isInline() ? "decorator" : null;
      }
    }
    return "empty";
  }
  return null;
}
function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom2) {
  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);
  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);
  if (prevLineBreak !== nextLineBreak) {
    nextElement.getDOMSlot(dom2).setManagedLineBreak(nextLineBreak);
  }
}
function reconcileTextFormat(element) {
  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {
    element.setTextFormat(subTreeTextFormat);
  }
}
function reconcileTextStyle(element) {
  if (subTreeTextStyle !== "" && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {
    element.setTextStyle(subTreeTextStyle);
  }
}
function reconcileBlockDirection(element, dom2) {
  const previousSubTreeDirectionTextContent = dom2.__lexicalDirTextContent || "";
  const previousDirection = dom2.__lexicalDir || "";
  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === "";
    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);
    if (direction !== previousDirection) {
      const classList = dom2.classList;
      const theme = activeEditorConfig.theme;
      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : void 0;
      let nextDirectionTheme = direction !== null ? theme[direction] : void 0;
      if (previousDirectionTheme !== void 0) {
        if (typeof previousDirectionTheme === "string") {
          const classNamesArr = normalizeClassNames(previousDirectionTheme);
          previousDirectionTheme = theme[previousDirection] = classNamesArr;
        }
        classList.remove(...previousDirectionTheme);
      }
      if (direction === null || hasEmptyDirectionedTextContent && direction === "ltr") {
        dom2.removeAttribute("dir");
      } else {
        if (nextDirectionTheme !== void 0) {
          if (typeof nextDirectionTheme === "string") {
            const classNamesArr = normalizeClassNames(nextDirectionTheme);
            nextDirectionTheme = theme[direction] = classNamesArr;
          }
          if (nextDirectionTheme !== void 0) {
            classList.add(...nextDirectionTheme);
          }
        }
        dom2.dir = direction;
      }
      if (!activeEditorStateReadOnly) {
        const writableNode = element.getWritable();
        writableNode.__dir = direction;
      }
    }
    activeTextDirection = direction;
    dom2.__lexicalDirTextContent = subTreeDirectionedTextContent;
    dom2.__lexicalDir = direction;
  }
}
function $reconcileChildrenWithDirection(prevElement, nextElement, dom2) {
  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  subTreeTextFormat = null;
  subTreeTextStyle = "";
  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom2));
  reconcileBlockDirection(nextElement, dom2);
  reconcileTextFormat(nextElement);
  reconcileTextStyle(nextElement);
  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
}
function createChildrenArray(element, nodeMap) {
  const children = [];
  let nodeKey = element.__first;
  while (nodeKey !== null) {
    const node = nodeMap.get(nodeKey);
    if (node === void 0) {
      {
        formatDevErrorMessage(`createChildrenArray: node does not exist in nodeMap`);
      }
    }
    children.push(nodeKey);
    nodeKey = node.__next;
  }
  return children;
}
function $reconcileChildren(prevElement, nextElement, slot) {
  const previousSubTreeTextContent = subTreeTextContent;
  const prevChildrenSize = prevElement.__size;
  const nextChildrenSize = nextElement.__size;
  subTreeTextContent = "";
  const dom2 = slot.element;
  if (prevChildrenSize === 1 && nextChildrenSize === 1) {
    const prevFirstChildKey = prevElement.__first;
    const nextFirstChildKey = nextElement.__first;
    if (prevFirstChildKey === nextFirstChildKey) {
      $reconcileNode(prevFirstChildKey, dom2);
    } else {
      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
      const replacementDOM = $createNode(nextFirstChildKey, null);
      try {
        dom2.replaceChild(replacementDOM, lastDOM);
      } catch (error) {
        if (typeof error === "object" && error != null) {
          const msg = `${error.toString()} Parent: ${dom2.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;
          throw new Error(msg);
        } else {
          throw error;
        }
      }
      destroyNode(prevFirstChildKey, null);
    }
    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);
    if ($isTextNode(nextChildNode)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = nextChildNode.getFormat();
      }
      if (subTreeTextStyle === "") {
        subTreeTextStyle = nextChildNode.getStyle();
      }
    }
  } else {
    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
    if (!(prevChildren.length === prevChildrenSize)) {
      formatDevErrorMessage(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);
    }
    if (!(nextChildren.length === nextChildrenSize)) {
      formatDevErrorMessage(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);
    }
    if (prevChildrenSize === 0) {
      if (nextChildrenSize !== 0) {
        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);
      }
    } else if (nextChildrenSize === 0) {
      if (prevChildrenSize !== 0) {
        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;
        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom2);
        if (canUseFastPath) {
          dom2.textContent = "";
        }
      }
    } else {
      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom2.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function $reconcileNode(key2, parentDOM) {
  const prevNode = activePrevNodeMap.get(key2);
  let nextNode = activeNextNodeMap.get(key2);
  if (prevNode === void 0 || nextNode === void 0) {
    {
      formatDevErrorMessage(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
    }
  }
  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key2) || activeDirtyElements.has(key2);
  const dom2 = getElementByKeyOrThrow(activeEditor$1, key2);
  if (prevNode === nextNode && !isDirty) {
    if ($isElementNode(prevNode)) {
      const previousSubTreeTextContent = dom2.__lexicalTextContent;
      if (previousSubTreeTextContent !== void 0) {
        subTreeTextContent += previousSubTreeTextContent;
        editorTextContent += previousSubTreeTextContent;
      }
      const previousSubTreeDirectionTextContent = dom2.__lexicalDirTextContent;
      if (previousSubTreeDirectionTextContent !== void 0) {
        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
      }
    } else {
      const text = prevNode.getTextContent();
      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {
        subTreeDirectionedTextContent += text;
      }
      editorTextContent += text;
      subTreeTextContent += text;
    }
    return dom2;
  }
  if (prevNode !== nextNode && isDirty) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
  }
  if (nextNode.updateDOM(prevNode, dom2, activeEditorConfig)) {
    const replacementDOM = $createNode(key2, null);
    if (parentDOM === null) {
      {
        formatDevErrorMessage(`reconcileNode: parentDOM is null`);
      }
    }
    parentDOM.replaceChild(replacementDOM, dom2);
    destroyNode(key2, null);
    return replacementDOM;
  }
  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
    const nextIndent = nextNode.__indent;
    if (nextIndent !== prevNode.__indent) {
      setElementIndent(dom2, nextIndent);
    }
    const nextFormat = nextNode.__format;
    if (nextFormat !== prevNode.__format) {
      setElementFormat(dom2, nextFormat);
    }
    if (isDirty) {
      $reconcileChildrenWithDirection(prevNode, nextNode, dom2);
      if (!$isRootNode(nextNode) && !nextNode.isInline()) {
        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom2);
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = nextNode.getTextContent();
    if ($isDecoratorNode(nextNode)) {
      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key2, decorator);
      }
    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {
      subTreeDirectionedTextContent += text;
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
    const nextRootNode = nextNode.getWritable();
    nextRootNode.__cachedText = editorTextContent;
    nextNode = nextRootNode;
  }
  {
    Object.freeze(nextNode);
  }
  return dom2;
}
function reconcileDecorator(key2, decorator) {
  let pendingDecorators = activeEditor$1._pendingDecorators;
  const currentDecorators = activeEditor$1._decorators;
  if (pendingDecorators === null) {
    if (currentDecorators[key2] === decorator) {
      return;
    }
    pendingDecorators = cloneDecorators(activeEditor$1);
  }
  pendingDecorators[key2] = decorator;
}
function getNextSibling(element) {
  let nextSibling2 = element.nextSibling;
  if (nextSibling2 !== null && nextSibling2 === activeEditor$1._blockCursorElement) {
    nextSibling2 = nextSibling2.nextSibling;
  }
  return nextSibling2;
}
function $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {
  const prevEndIndex = prevChildrenLength - 1;
  const nextEndIndex = nextChildrenLength - 1;
  let prevChildrenSet;
  let nextChildrenSet;
  let siblingDOM = slot.getFirstChild();
  let prevIndex = 0;
  let nextIndex = 0;
  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
    const prevKey = prevChildren[prevIndex];
    const nextKey = nextChildren[nextIndex];
    if (prevKey === nextKey) {
      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
      prevIndex++;
      nextIndex++;
    } else {
      if (prevChildrenSet === void 0) {
        prevChildrenSet = new Set(prevChildren);
      }
      if (nextChildrenSet === void 0) {
        nextChildrenSet = new Set(nextChildren);
      }
      const nextHasPrevKey = nextChildrenSet.has(prevKey);
      const prevHasNextKey = prevChildrenSet.has(nextKey);
      if (!nextHasPrevKey) {
        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
        destroyNode(prevKey, slot.element);
        prevIndex++;
      } else if (!prevHasNextKey) {
        $createNode(nextKey, slot.withBefore(siblingDOM));
        nextIndex++;
      } else {
        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
        if (childDOM === siblingDOM) {
          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
        } else {
          slot.withBefore(siblingDOM).insertChild(childDOM);
          $reconcileNode(nextKey, slot.element);
        }
        prevIndex++;
        nextIndex++;
      }
    }
    const node = activeNextNodeMap.get(nextKey);
    if (node !== null && $isTextNode(node)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = node.getFormat();
      }
      if (subTreeTextStyle === "") {
        subTreeTextStyle = node.getStyle();
      }
    }
  }
  const appendNewChildren = prevIndex > prevEndIndex;
  const removeOldChildren = nextIndex > nextEndIndex;
  if (appendNewChildren && !removeOldChildren) {
    const previousNode = nextChildren[nextEndIndex + 1];
    const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));
  } else if (removeOldChildren && !appendNewChildren) {
    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);
  }
}
function $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
  subTreeTextContent = "";
  editorTextContent = "";
  subTreeDirectionedTextContent = "";
  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
  activeTextDirection = null;
  activeEditor$1 = editor;
  activeEditorConfig = editor._config;
  activeEditorNodes = editor._nodes;
  activeMutationListeners = activeEditor$1._listeners.mutation;
  activeDirtyElements = dirtyElements;
  activeDirtyLeaves = dirtyLeaves;
  activePrevNodeMap = prevEditorState._nodeMap;
  activeNextNodeMap = nextEditorState._nodeMap;
  activeEditorStateReadOnly = nextEditorState._readOnly;
  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
  const currentMutatedNodes = /* @__PURE__ */ new Map();
  mutatedNodes = currentMutatedNodes;
  $reconcileNode("root", null);
  activeEditor$1 = void 0;
  activeEditorNodes = void 0;
  activeDirtyElements = void 0;
  activeDirtyLeaves = void 0;
  activePrevNodeMap = void 0;
  activeNextNodeMap = void 0;
  activeEditorConfig = void 0;
  activePrevKeyToDOMMap = void 0;
  mutatedNodes = void 0;
  return currentMutatedNodes;
}
function storeDOMWithKey(key2, dom2, editor) {
  const keyToDOMMap = editor._keyToDOMMap;
  setNodeKeyOnDOMNode(dom2, editor, key2);
  keyToDOMMap.set(key2, dom2);
}
function getPrevElementByKeyOrThrow(key2) {
  const element = activePrevKeyToDOMMap.get(key2);
  if (element === void 0) {
    {
      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key2}`);
    }
  }
  return element;
}
function warnOnlyOnce(message) {
  {
    let run = false;
    return () => {
      if (!run) {
        console.warn(message);
      }
      run = true;
    };
  }
}
function createCommand(type) {
  return {
    type
  };
}
function $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const editor = getActiveEditor();
  const domSelection = getDOMSelection(getWindow(editor));
  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
  const anchorKey = anchor.key;
  const backingAnchorElement = editor.getElementByKey(anchorKey);
  const textLength = text.length;
  return anchorKey !== focus.key || // If we're working with a non-text node.
  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
  // a recent beforeinput event for "textInput". If there has been one in the last
  // 50ms then we proceed as normal. However, if there is not, then this is likely
  // a dangling `input` event caused by execCommand('insertText').
  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || // TODO consider if there are other scenarios when multiple code units
  //      should be addressed here
  doesContainSurrogatePair(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
  // dealing with this in "beforeinput" or where the node has already recently
  // been changed (thus is dirty).
  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
  // of the editor.
  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
}
function shouldSkipSelectionChange(domNode, offset) {
  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;
}
function onSelectionChange(domSelection, editor, isActive) {
  const {
    anchorNode: anchorDOM,
    anchorOffset,
    focusNode: focusDOM,
    focusOffset
  } = domSelection;
  if (isSelectionChangeFromDOMUpdate) {
    isSelectionChangeFromDOMUpdate = false;
    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset) && !postDeleteSelectionToRestore) {
      return;
    }
  }
  updateEditorSync(editor, () => {
    if (!isActive) {
      $setSelection(null);
      return;
    }
    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return;
    }
    let selection = $getSelection();
    if (postDeleteSelectionToRestore && $isRangeSelection(selection) && selection.isCollapsed()) {
      const curAnchor = selection.anchor;
      const prevAnchor = postDeleteSelectionToRestore.anchor;
      if (
        // Rightward shift in same node
        curAnchor.key === prevAnchor.key && curAnchor.offset === prevAnchor.offset + 1 || // Or rightward shift into sibling node
        curAnchor.offset === 1 && prevAnchor.getNode().is(curAnchor.getNode().getPreviousSibling())
      ) {
        selection = postDeleteSelectionToRestore.clone();
        $setSelection(selection);
      }
    }
    postDeleteSelectionToRestore = null;
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      if (selection.isCollapsed()) {
        if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
          selection.dirty = true;
        }
        const windowEvent = getWindow(editor).event;
        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
        const root = $getRoot();
        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === "";
        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
          $updateSelectionFormatStyle(selection, lastFormat, lastStyle);
        } else {
          if (anchor.type === "text") {
            if (!$isTextNode(anchorNode)) {
              formatDevErrorMessage(`Point.getNode() must return TextNode when type is text`);
            }
            $updateSelectionFormatStyleFromTextNode(selection, anchorNode);
          } else if (anchor.type === "element" && !isRootTextContentEmpty) {
            if (!$isElementNode(anchorNode)) {
              formatDevErrorMessage(`Point.getNode() must return ElementNode when type is element`);
            }
            const lastNode = anchor.getNode();
            if (
              // This previously applied to all ParagraphNode
              lastNode.isEmpty()
            ) {
              $updateSelectionFormatStyleFromElementNode(selection, lastNode);
            } else {
              $updateSelectionFormatStyle(selection, 0, "");
            }
          }
        }
      } else {
        const anchorKey = anchor.key;
        const focus = selection.focus;
        const focusKey = focus.key;
        const nodes = selection.getNodes();
        const nodesLength = nodes.length;
        const isBackward = selection.isBackward();
        const startOffset = isBackward ? focusOffset : anchorOffset;
        const endOffset = isBackward ? anchorOffset : focusOffset;
        const startKey = isBackward ? focusKey : anchorKey;
        const endKey = isBackward ? anchorKey : focusKey;
        let combinedFormat = IS_ALL_FORMATTING;
        let hasTextNodes = false;
        for (let i2 = 0; i2 < nodesLength; i2++) {
          const node = nodes[i2];
          const textContentSize = node.getTextContentSize();
          if ($isTextNode(node) && textContentSize !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
          !(i2 === 0 && node.__key === startKey && startOffset === textContentSize || i2 === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {
            hasTextNodes = true;
            combinedFormat &= node.getFormat();
            if (combinedFormat === 0) {
              break;
            }
          }
        }
        selection.format = hasTextNodes ? combinedFormat : 0;
      }
    }
    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, void 0);
  });
}
function $updateSelectionFormatStyle(selection, format, style) {
  if (selection.format !== format || selection.style !== style) {
    selection.format = format;
    selection.style = style;
    selection.dirty = true;
  }
}
function $updateSelectionFormatStyleFromTextNode(selection, node) {
  const format = node.getFormat();
  const style = node.getStyle();
  $updateSelectionFormatStyle(selection, format, style);
}
function $updateSelectionFormatStyleFromElementNode(selection, node) {
  const format = node.getTextFormat();
  const style = node.getTextStyle();
  $updateSelectionFormatStyle(selection, format, style);
}
function onClick(event, editor) {
  updateEditorSync(editor, () => {
    const selection = $getSelection();
    const domSelection = getDOMSelection(getWindow(editor));
    const lastSelection = $getPreviousSelection();
    if (domSelection) {
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
          domSelection.removeAllRanges();
          selection.dirty = true;
        } else if (event.detail === 3 && !selection.isCollapsed()) {
          const focus = selection.focus;
          const focusNode = focus.getNode();
          if (anchorNode !== focusNode) {
            const parentNode = $findMatchingParent(anchorNode, (node) => $isElementNode(node) && !node.isInline());
            if ($isElementNode(parentNode)) {
              parentNode.select(0);
            }
          }
        }
      } else if (event.pointerType === "touch" || event.pointerType === "pen") {
        const domAnchorNode = domSelection.anchorNode;
        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
          $setSelection(newSelection);
        }
      }
    }
    dispatchCommand(editor, CLICK_COMMAND, event);
  });
}
function onPointerDown(event, editor) {
  const target = event.target;
  const pointerType = event.pointerType;
  if (isDOMNode(target) && pointerType !== "touch" && pointerType !== "pen" && event.button === 0) {
    updateEditorSync(editor, () => {
      if (!$isSelectionCapturedInDecorator(target)) {
        isSelectionChangeFromMouseDown = true;
      }
    });
  }
}
function getTargetRange(event) {
  if (!event.getTargetRanges) {
    return null;
  }
  const targetRanges = event.getTargetRanges();
  if (targetRanges.length === 0) {
    return null;
  }
  return targetRanges[0];
}
function $canRemoveText(anchorNode, focusNode) {
  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrTab(anchorNode) || !$isTokenOrTab(focusNode);
}
function isPossiblyAndroidKeyPress(timeStamp) {
  return lastKeyCode === "MediaLast" && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
}
function onBeforeInput(event, editor) {
  const inputType = event.inputType;
  const targetRange = getTargetRange(event);
  if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
  // as the `paste` event should have triggered, unless the
  // user has dom.event.clipboardevents.enabled disabled in
  // about:config. In that case, we need to process the
  // pasted content in the DOM mutation phase.
  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    return;
  } else if (inputType === "insertCompositionText") {
    return;
  }
  updateEditorSync(editor, () => {
    const selection = $getSelection();
    if (inputType === "deleteContentBackward") {
      if (selection === null) {
        const prevSelection = $getPreviousSelection();
        if (!$isRangeSelection(prevSelection)) {
          return;
        }
        $setSelection(prevSelection.clone());
      }
      if ($isRangeSelection(selection)) {
        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;
        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {
          $setCompositionKey(null);
          lastKeyDownTimeStamp = 0;
          setTimeout(() => {
            updateEditorSync(editor, () => {
              $setCompositionKey(null);
            });
          }, ANDROID_COMPOSITION_LATENCY);
          if ($isRangeSelection(selection)) {
            const anchorNode2 = selection.anchor.getNode();
            anchorNode2.markDirty();
            if (!$isTextNode(anchorNode2)) {
              formatDevErrorMessage(`Anchor node must be a TextNode`);
            }
            $updateSelectionFormatStyleFromTextNode(selection, anchorNode2);
          }
        } else {
          $setCompositionKey(null);
          event.preventDefault();
          const selectedNode = selection.anchor.getNode();
          const selectedNodeText = selectedNode.getTextContent();
          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();
          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;
          let shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;
          if (shouldLetBrowserHandleDelete && selection.isCollapsed()) {
            shouldLetBrowserHandleDelete = !$isDecoratorNode($getAdjacentNode(selection.anchor, true));
          }
          if (!shouldLetBrowserHandleDelete) {
            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
            const selectionAfterDelete = $getSelection();
            if (IS_ANDROID_CHROME && $isRangeSelection(selectionAfterDelete) && selectionAfterDelete.isCollapsed()) {
              postDeleteSelectionToRestore = selectionAfterDelete;
              setTimeout(() => postDeleteSelectionToRestore = null);
            }
          }
        }
        return;
      }
    }
    if (!$isRangeSelection(selection)) {
      return;
    }
    const data = event.data;
    if (unprocessedBeforeInputData !== null) {
      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
    }
    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {
      selection.applyDOMRange(targetRange);
    }
    unprocessedBeforeInputData = null;
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (inputType === "insertText" || inputType === "insertTranspose") {
      if (data === "\n") {
        event.preventDefault();
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
      } else if (data === DOUBLE_LINE_BREAK) {
        event.preventDefault();
        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
      } else if (data == null && event.dataTransfer) {
        const text = event.dataTransfer.getData("text/plain");
        event.preventDefault();
        selection.insertRawText(text);
      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {
        event.preventDefault();
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
      } else {
        unprocessedBeforeInputData = data;
      }
      lastBeforeInputInsertTextTimeStamp = event.timeStamp;
      return;
    }
    event.preventDefault();
    switch (inputType) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText": {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertFromComposition": {
        $setCompositionKey(null);
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertLineBreak": {
        $setCompositionKey(null);
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        break;
      }
      case "insertParagraph": {
        $setCompositionKey(null);
        if (isInsertLineBreak && !IS_IOS) {
          isInsertLineBreak = false;
          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        } else {
          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
        }
        break;
      }
      case "insertFromPaste":
      case "insertFromPasteAsQuotation": {
        dispatchCommand(editor, PASTE_COMMAND, event);
        break;
      }
      case "deleteByComposition": {
        if ($canRemoveText(anchorNode, focusNode)) {
          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        }
        break;
      }
      case "deleteByDrag":
      case "deleteByCut": {
        dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        break;
      }
      case "deleteContent": {
        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
        break;
      }
      case "deleteWordBackward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, true);
        break;
      }
      case "deleteWordForward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, false);
        break;
      }
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, true);
        break;
      }
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, false);
        break;
      }
      case "formatStrikeThrough": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "strikethrough");
        break;
      }
      case "formatBold": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
        break;
      }
      case "formatItalic": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
        break;
      }
      case "formatUnderline": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
        break;
      }
      case "historyUndo": {
        dispatchCommand(editor, UNDO_COMMAND, void 0);
        break;
      }
      case "historyRedo": {
        dispatchCommand(editor, REDO_COMMAND, void 0);
        break;
      }
    }
  });
}
function onInput(event, editor) {
  event.stopPropagation();
  updateEditorSync(editor, () => {
    if (isHTMLElement(event.target) && $isSelectionCapturedInDecorator(event.target)) {
      return;
    }
    const selection = $getSelection();
    const data = event.data;
    const targetRange = getTargetRange(event);
    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {
      if (isFirefoxEndingComposition) {
        $onCompositionEndImpl(editor, data);
        isFirefoxEndingComposition = false;
      }
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      const domSelection = getDOMSelection(getWindow(editor));
      if (domSelection === null) {
        return;
      }
      const isBackward = selection.isBackward();
      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;
      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;
      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
      }
      const textLength = data.length;
      if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
        selection.anchor.offset -= textLength;
      }
      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
        lastKeyDownTimeStamp = 0;
        $setCompositionKey(null);
      }
    } else {
      const characterData = data !== null ? data : void 0;
      $updateSelectedTextFromDOM(false, editor, characterData);
      if (isFirefoxEndingComposition) {
        $onCompositionEndImpl(editor, data || void 0);
        isFirefoxEndingComposition = false;
      }
    }
    $flushMutations();
  }, {
    event
  });
  unprocessedBeforeInputData = null;
}
function onCompositionStart(event, editor) {
  updateEditorSync(editor, () => {
    const selection = $getSelection();
    if ($isRangeSelection(selection) && !editor.isComposing()) {
      const anchor = selection.anchor;
      const node = selection.anchor.getNode();
      $setCompositionKey(anchor.key);
      if (
        // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style
      ) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
      }
    }
  });
}
function $onCompositionEndImpl(editor, data) {
  const compositionKey = editor._compositionKey;
  $setCompositionKey(null);
  if (compositionKey !== null && data != null) {
    if (data === "") {
      const node = $getNodeByKey(compositionKey);
      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
      }
      return;
    }
    if (data[data.length - 1] === "\n") {
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const focus = selection.focus;
        selection.anchor.set(focus.key, focus.offset, focus.type);
        dispatchCommand(editor, KEY_ENTER_COMMAND, null);
        return;
      }
    }
  }
  $updateSelectedTextFromDOM(true, editor, data);
}
function onCompositionEnd(event, editor) {
  if (IS_FIREFOX) {
    isFirefoxEndingComposition = true;
  } else if (!IS_IOS && (IS_SAFARI || IS_APPLE_WEBKIT)) {
    isSafariEndingComposition = true;
    safariEndCompositionEventData = event.data;
  } else {
    updateEditorSync(editor, () => {
      $onCompositionEndImpl(editor, event.data);
    });
  }
}
function onKeyDown(event, editor) {
  lastKeyDownTimeStamp = event.timeStamp;
  lastKeyCode = event.key;
  if (editor.isComposing()) {
    return;
  }
  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {
    return;
  }
  if (event.key == null) {
    return;
  }
  if (isSafariEndingComposition && isBackspace(event)) {
    updateEditorSync(editor, () => {
      $onCompositionEndImpl(editor, safariEndCompositionEventData);
    });
    isSafariEndingComposition = false;
    safariEndCompositionEventData = "";
    return;
  }
  if (isMoveForward(event)) {
    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
  } else if (isMoveToEnd(event)) {
    dispatchCommand(editor, MOVE_TO_END, event);
  } else if (isMoveBackward(event)) {
    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
  } else if (isMoveToStart(event)) {
    dispatchCommand(editor, MOVE_TO_START, event);
  } else if (isMoveUp(event)) {
    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
  } else if (isMoveDown(event)) {
    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
  } else if (isLineBreak(event)) {
    isInsertLineBreak = true;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isSpace(event)) {
    dispatchCommand(editor, KEY_SPACE_COMMAND, event);
  } else if (isOpenLineBreak(event)) {
    event.preventDefault();
    isInsertLineBreak = true;
    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
  } else if (isParagraph(event)) {
    isInsertLineBreak = false;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isDeleteBackward(event)) {
    if (isBackspace(event)) {
      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    }
  } else if (isEscape(event)) {
    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
  } else if (isDeleteForward(event)) {
    if (isDelete(event)) {
      dispatchCommand(editor, KEY_DELETE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    }
  } else if (isDeleteWordBackward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, true);
  } else if (isDeleteWordForward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, false);
  } else if (isDeleteLineBackward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, true);
  } else if (isDeleteLineForward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, false);
  } else if (isBold(event)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
  } else if (isUnderline(event)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
  } else if (isItalic(event)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
  } else if (isTab(event)) {
    dispatchCommand(editor, KEY_TAB_COMMAND, event);
  } else if (isUndo(event)) {
    event.preventDefault();
    dispatchCommand(editor, UNDO_COMMAND, void 0);
  } else if (isRedo(event)) {
    event.preventDefault();
    dispatchCommand(editor, REDO_COMMAND, void 0);
  } else {
    const prevSelection = editor._editorState._selection;
    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {
      if (isCopy(event)) {
        event.preventDefault();
        dispatchCommand(editor, COPY_COMMAND, event);
      } else if (isCut(event)) {
        event.preventDefault();
        dispatchCommand(editor, CUT_COMMAND, event);
      } else if (isSelectAll(event)) {
        event.preventDefault();
        dispatchCommand(editor, SELECT_ALL_COMMAND, event);
      }
    } else if (isSelectAll(event)) {
      event.preventDefault();
      dispatchCommand(editor, SELECT_ALL_COMMAND, event);
    }
  }
  if (isModifier(event)) {
    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
  }
}
function getRootElementRemoveHandles(rootElement) {
  let eventHandles = rootElement.__lexicalEventHandles;
  if (eventHandles === void 0) {
    eventHandles = [];
    rootElement.__lexicalEventHandles = eventHandles;
  }
  return eventHandles;
}
function onDocumentSelectionChange(event) {
  const domSelection = getDOMSelectionFromTarget(event.target);
  if (domSelection === null) {
    return;
  }
  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
  if (nextActiveEditor === null) {
    return;
  }
  if (isSelectionChangeFromMouseDown) {
    isSelectionChangeFromMouseDown = false;
    updateEditorSync(nextActiveEditor, () => {
      const lastSelection = $getPreviousSelection();
      const domAnchorNode = domSelection.anchorNode;
      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);
        $setSelection(newSelection);
      }
    });
  }
  const editors = getEditorsToPropagate(nextActiveEditor);
  const rootEditor = editors[editors.length - 1];
  const rootEditorKey = rootEditor._key;
  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
  const prevActiveEditor = activeNestedEditor || rootEditor;
  if (prevActiveEditor !== nextActiveEditor) {
    onSelectionChange(domSelection, prevActiveEditor, false);
  }
  onSelectionChange(domSelection, nextActiveEditor, true);
  if (nextActiveEditor !== rootEditor) {
    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
  } else if (activeNestedEditor) {
    activeNestedEditorsMap.delete(rootEditorKey);
  }
}
function stopLexicalPropagation(event) {
  event._lexicalHandled = true;
}
function hasStoppedLexicalPropagation(event) {
  const stopped = event._lexicalHandled === true;
  return stopped;
}
function addRootElementEvents(rootElement, editor) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (documentRootElementsCount === void 0 || documentRootElementsCount < 1) {
    doc.addEventListener("selectionchange", onDocumentSelectionChange);
  }
  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);
  rootElement.__lexicalEditor = editor;
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i2 = 0; i2 < rootElementEvents.length; i2++) {
    const [eventName, onEvent] = rootElementEvents[i2];
    const eventHandler = typeof onEvent === "function" ? (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      if (editor.isEditable() || eventName === "click") {
        onEvent(event, editor);
      }
    } : (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      const isEditable = editor.isEditable();
      switch (eventName) {
        case "cut":
          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);
        case "copy":
          return dispatchCommand(editor, COPY_COMMAND, event);
        case "paste":
          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);
        case "dragstart":
          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);
        case "dragover":
          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);
        case "dragend":
          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);
        case "focus":
          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);
        case "blur": {
          return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);
        }
        case "drop":
          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);
      }
    };
    rootElement.addEventListener(eventName, eventHandler);
    removeHandles.push(() => {
      rootElement.removeEventListener(eventName, eventHandler);
    });
  }
}
function removeRootElementEvents(rootElement) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (documentRootElementsCount === void 0) {
    rootElementNotRegisteredWarning();
    return;
  }
  const newCount = documentRootElementsCount - 1;
  if (!(newCount >= 0)) {
    formatDevErrorMessage(`Root element count less than 0`);
  }
  rootElementsRegistered.set(doc, newCount);
  if (newCount === 0) {
    doc.removeEventListener("selectionchange", onDocumentSelectionChange);
  }
  const editor = getEditorPropertyFromDOMNode(rootElement);
  if (isLexicalEditor(editor)) {
    cleanActiveNestedEditorsMap(editor);
    rootElement.__lexicalEditor = null;
  } else if (editor) {
    {
      formatDevErrorMessage(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);
    }
  }
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i2 = 0; i2 < removeHandles.length; i2++) {
    removeHandles[i2]();
  }
  rootElement.__lexicalEventHandles = [];
}
function cleanActiveNestedEditorsMap(editor) {
  if (editor._parentEditor !== null) {
    const editors = getEditorsToPropagate(editor);
    const rootEditor = editors[editors.length - 1];
    const rootEditorKey = rootEditor._key;
    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
      activeNestedEditorsMap.delete(rootEditorKey);
    }
  } else {
    activeNestedEditorsMap.delete(editor._key);
  }
}
function markSelectionChangeFromDOMUpdate() {
  isSelectionChangeFromDOMUpdate = true;
}
function markCollapsedSelectionFormat(format, style, offset, key2, timeStamp) {
  collapsedSelectionFormat = [format, style, offset, key2, timeStamp];
}
function $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
  errorOnReadOnly();
  const key2 = nodeToRemove.__key;
  const parent = nodeToRemove.getParent();
  if (parent === null) {
    return;
  }
  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
  let selectionMoved = false;
  if ($isRangeSelection(selection) && restoreSelection) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    if (anchor.key === key2) {
      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
    if (focus.key === key2) {
      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {
    nodeToRemove.selectPrevious();
  }
  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {
    const index = nodeToRemove.getIndexWithinParent();
    removeFromParent(nodeToRemove);
    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);
  } else {
    removeFromParent(nodeToRemove);
  }
  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
    $removeNode(parent, restoreSelection);
  }
  if (restoreSelection && selection && $isRootNode(parent) && parent.isEmpty()) {
    parent.selectEnd();
  }
}
function errorOnTypeKlassMismatch(type, klass) {
  const registeredNode = getActiveEditor()._nodes.get(type);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
    }
  }
  const editorKlass = registeredNode.klass;
  if (editorKlass !== klass) {
    {
      formatDevErrorMessage(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
    }
  }
}
function insertRangeAfter(node, firstToInsert, lastToInsert) {
  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();
  let current = firstToInsert;
  const nodesToInsert = [firstToInsert];
  while (current !== lastToInsert2) {
    if (!current.getNextSibling()) {
      {
        formatDevErrorMessage(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);
      }
    }
    current = current.getNextSibling();
    nodesToInsert.push(current);
  }
  let currentNode = node;
  for (const nodeToInsert of nodesToInsert) {
    currentNode = currentNode.insertAfter(nodeToInsert);
  }
}
function $convertLineBreakElement(node) {
  return {
    node: $createLineBreakNode()
  };
}
function $createLineBreakNode() {
  return $applyNodeReplacement(new LineBreakNode());
}
function $isLineBreakNode(node) {
  return node instanceof LineBreakNode;
}
function isOnlyChildInBlockNode(node) {
  const parentElement2 = node.parentElement;
  if (parentElement2 !== null && isBlockDomNode(parentElement2)) {
    const firstChild = parentElement2.firstChild;
    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
      const lastChild = parentElement2.lastChild;
      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
        return true;
      }
    }
  }
  return false;
}
function isLastChildInBlockNode(node) {
  const parentElement2 = node.parentElement;
  if (parentElement2 !== null && isBlockDomNode(parentElement2)) {
    const firstChild = parentElement2.firstChild;
    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
      return false;
    }
    const lastChild = parentElement2.lastChild;
    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
      return true;
    }
  }
  return false;
}
function isWhitespaceDomTextNode(node) {
  return isDOMTextNode(node) && /^( |\t|\r?\n)+$/.test(node.textContent || "");
}
function getElementOuterTag(node, format) {
  if (format & IS_CODE) {
    return "code";
  }
  if (format & IS_HIGHLIGHT) {
    return "mark";
  }
  if (format & IS_SUBSCRIPT) {
    return "sub";
  }
  if (format & IS_SUPERSCRIPT) {
    return "sup";
  }
  return null;
}
function getElementInnerTag(node, format) {
  if (format & IS_BOLD) {
    return "strong";
  }
  if (format & IS_ITALIC) {
    return "em";
  }
  return "span";
}
function setTextThemeClassNames(tag, prevFormat, nextFormat, dom2, textClassNames) {
  const domClassList = dom2.classList;
  let classNames2 = getCachedClassNameArray(textClassNames, "base");
  if (classNames2 !== void 0) {
    domClassList.add(...classNames2);
  }
  classNames2 = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
  let hasUnderlineStrikethrough = false;
  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
  if (classNames2 !== void 0) {
    if (nextUnderlineStrikethrough) {
      hasUnderlineStrikethrough = true;
      if (!prevUnderlineStrikethrough) {
        domClassList.add(...classNames2);
      }
    } else if (prevUnderlineStrikethrough) {
      domClassList.remove(...classNames2);
    }
  }
  for (const key2 in TEXT_TYPE_TO_FORMAT) {
    const format = key2;
    const flag = TEXT_TYPE_TO_FORMAT[format];
    classNames2 = getCachedClassNameArray(textClassNames, key2);
    if (classNames2 !== void 0) {
      if (nextFormat & flag) {
        if (hasUnderlineStrikethrough && (key2 === "underline" || key2 === "strikethrough")) {
          if (prevFormat & flag) {
            domClassList.remove(...classNames2);
          }
          continue;
        }
        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key2 === "underline" || key2 === "strikethrough") {
          domClassList.add(...classNames2);
        }
      } else if (prevFormat & flag) {
        domClassList.remove(...classNames2);
      }
    }
  }
}
function diffComposedText(a2, b3) {
  const aLength = a2.length;
  const bLength = b3.length;
  let left = 0;
  let right = 0;
  while (left < aLength && left < bLength && a2[left] === b3[left]) {
    left++;
  }
  while (right + left < aLength && right + left < bLength && a2[aLength - right - 1] === b3[bLength - right - 1]) {
    right++;
  }
  return [left, aLength - left - right, b3.slice(left, bLength - right)];
}
function setTextContent(nextText, dom2, node) {
  const firstChild = dom2.firstChild;
  const isComposing = node.isComposing();
  const suffix = isComposing ? COMPOSITION_SUFFIX : "";
  const text = nextText + suffix;
  if (firstChild == null) {
    dom2.textContent = text;
  } else {
    const nodeValue = firstChild.nodeValue;
    if (nodeValue !== text) {
      if (isComposing || IS_FIREFOX) {
        const [index, remove2, insert2] = diffComposedText(nodeValue, text);
        if (remove2 !== 0) {
          firstChild.deleteData(index, remove2);
        }
        firstChild.insertData(index, insert2);
      } else {
        firstChild.nodeValue = text;
      }
    }
  }
}
function createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {
  setTextContent(text, innerDOM, node);
  const theme = config.theme;
  const textClassNames = theme.text;
  if (textClassNames !== void 0) {
    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
  }
}
function wrapElementWith(element, tag) {
  const el2 = document.createElement(tag);
  el2.appendChild(element);
  return el2;
}
function convertSpanElement(domNode) {
  const span = domNode;
  const style = span.style;
  return {
    forChild: applyTextFormatFromStyle(style),
    node: null
  };
}
function convertBringAttentionToElement(domNode) {
  const b3 = domNode;
  const hasNormalFontWeight = b3.style.fontWeight === "normal";
  return {
    forChild: applyTextFormatFromStyle(b3.style, hasNormalFontWeight ? void 0 : "bold"),
    node: null
  };
}
function isNodePre(node) {
  if (!isHTMLElement(node)) {
    return false;
  } else if (node.nodeName === "PRE") {
    return true;
  }
  const whiteSpace = node.style.whiteSpace;
  return typeof whiteSpace === "string" && whiteSpace.startsWith("pre");
}
function findParentPreDOMNode(node) {
  let cached;
  let parent = node.parentNode;
  const visited = [node];
  while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
    visited.push(parent);
    parent = parent.parentNode;
  }
  const resultNode = cached === void 0 ? parent : cached;
  for (let i2 = 0; i2 < visited.length; i2++) {
    preParentCache.set(visited[i2], resultNode);
  }
  return resultNode;
}
function $convertTextDOMNode(domNode) {
  const domNode_ = domNode;
  const parentDom = domNode.parentElement;
  if (!(parentDom !== null)) {
    formatDevErrorMessage(`Expected parentElement of Text not to be null`);
  }
  let textContent2 = domNode_.textContent || "";
  if (findParentPreDOMNode(domNode_) !== null) {
    const parts = textContent2.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i2 = 0; i2 < length; i2++) {
      const part = parts[i2];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else if (part !== "") {
        nodes.push($createTextNode(part));
      }
    }
    return {
      node: nodes
    };
  }
  textContent2 = textContent2.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
  if (textContent2 === "") {
    return {
      node: null
    };
  }
  if (textContent2[0] === " ") {
    let previousText = domNode_;
    let isStartOfLine = true;
    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
      const previousTextContent = previousText.textContent || "";
      if (previousTextContent.length > 0) {
        if (/[ \t\n]$/.test(previousTextContent)) {
          textContent2 = textContent2.slice(1);
        }
        isStartOfLine = false;
        break;
      }
    }
    if (isStartOfLine) {
      textContent2 = textContent2.slice(1);
    }
  }
  if (textContent2[textContent2.length - 1] === " ") {
    let nextText = domNode_;
    let isEndOfLine = true;
    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
      const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
      if (nextTextContent.length > 0) {
        isEndOfLine = false;
        break;
      }
    }
    if (isEndOfLine) {
      textContent2 = textContent2.slice(0, textContent2.length - 1);
    }
  }
  if (textContent2 === "") {
    return {
      node: null
    };
  }
  return {
    node: $createTextNode(textContent2)
  };
}
function findTextInLine(text, forward) {
  let node = text;
  while (true) {
    let sibling;
    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {
      const parentElement2 = node.parentElement;
      if (parentElement2 === null) {
        return null;
      }
      node = parentElement2;
    }
    node = sibling;
    if (isHTMLElement(node)) {
      const display = node.style.display;
      if (display === "" && !isInlineDomNode(node) || display !== "" && !display.startsWith("inline")) {
        return null;
      }
    }
    let descendant = node;
    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {
      node = descendant;
    }
    if (isDOMTextNode(node)) {
      return node;
    } else if (node.nodeName === "BR") {
      return null;
    }
  }
}
function convertTextFormatElement(domNode) {
  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
  if (format === void 0) {
    return {
      node: null
    };
  }
  return {
    forChild: applyTextFormatFromStyle(domNode.style, format),
    node: null
  };
}
function $createTextNode(text = "") {
  return $applyNodeReplacement(new TextNode(text));
}
function $isTextNode(node) {
  return node instanceof TextNode;
}
function applyTextFormatFromStyle(style, shouldApply) {
  const fontWeight = style.fontWeight;
  const textDecoration = style.textDecoration.split(" ");
  const hasBoldFontWeight = fontWeight === "700" || fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  const verticalAlign = style.verticalAlign;
  return (lexicalNode) => {
    if (!$isTextNode(lexicalNode)) {
      return lexicalNode;
    }
    if (hasBoldFontWeight && !lexicalNode.hasFormat("bold")) {
      lexicalNode.toggleFormat("bold");
    }
    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat("strikethrough")) {
      lexicalNode.toggleFormat("strikethrough");
    }
    if (hasItalicFontStyle && !lexicalNode.hasFormat("italic")) {
      lexicalNode.toggleFormat("italic");
    }
    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat("underline")) {
      lexicalNode.toggleFormat("underline");
    }
    if (verticalAlign === "sub" && !lexicalNode.hasFormat("subscript")) {
      lexicalNode.toggleFormat("subscript");
    }
    if (verticalAlign === "super" && !lexicalNode.hasFormat("superscript")) {
      lexicalNode.toggleFormat("superscript");
    }
    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {
      lexicalNode.toggleFormat(shouldApply);
    }
    return lexicalNode;
  };
}
function $createTabNode() {
  return $applyNodeReplacement(new TabNode());
}
function $isTabNode(node) {
  return node instanceof TabNode;
}
function $createPoint(key2, offset, type) {
  return new Point(key2, offset, type);
}
function selectPointOnNode(point, node) {
  let key2 = node.__key;
  let offset = point.offset;
  let type = "element";
  if ($isTextNode(node)) {
    type = "text";
    const textContentLength = node.getTextContentSize();
    if (offset > textContentLength) {
      offset = textContentLength;
    }
  } else if (!$isElementNode(node)) {
    const nextSibling2 = node.getNextSibling();
    if ($isTextNode(nextSibling2)) {
      key2 = nextSibling2.__key;
      offset = 0;
      type = "text";
    } else {
      const parentNode = node.getParent();
      if (parentNode) {
        key2 = parentNode.__key;
        offset = node.getIndexWithinParent() + 1;
      }
    }
  }
  point.set(key2, offset, type);
}
function $moveSelectionPointToEnd(point, node) {
  if ($isElementNode(node)) {
    const lastNode = node.getLastDescendant();
    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
      selectPointOnNode(point, lastNode);
    } else {
      selectPointOnNode(point, node);
    }
  } else {
    selectPointOnNode(point, node);
  }
}
function $transferStartingElementPointToTextPoint(start, end, format, style) {
  const element = start.getNode();
  const placementNode = element.getChildAtIndex(start.offset);
  const textNode = $createTextNode();
  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;
  textNode.setFormat(format);
  textNode.setStyle(style);
  if (placementNode === null) {
    element.append(target);
  } else {
    placementNode.insertBefore(target);
  }
  if (start.is(end)) {
    end.set(textNode.__key, 0, "text");
  }
  start.set(textNode.__key, 0, "text");
}
function $isRangeSelection(x4) {
  return x4 instanceof RangeSelection;
}
function $isNodeSelection(x4) {
  return x4 instanceof NodeSelection;
}
function getCharacterOffset(point) {
  const offset = point.offset;
  if (point.type === "text") {
    return offset;
  }
  const parent = point.getNode();
  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
}
function $getCharacterOffsets(selection) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (anchorAndFocus === null) {
    return [0, 0];
  }
  const [anchor, focus] = anchorAndFocus;
  if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
    return [0, 0];
  }
  return [getCharacterOffset(anchor), getCharacterOffset(focus)];
}
function $collapseAtStart(selection, startNode) {
  for (let node = startNode; node; node = node.getParent()) {
    if ($isElementNode(node)) {
      if (node.collapseAtStart(selection)) {
        return true;
      }
      if ($isRootOrShadowRoot(node)) {
        break;
      }
    }
    if (node.getPreviousSibling()) {
      break;
    }
  }
  return false;
}
function $swapPoints(selection) {
  const focus = selection.focus;
  const anchor = selection.anchor;
  const anchorKey = anchor.key;
  const anchorOffset = anchor.offset;
  const anchorType = anchor.type;
  anchor.set(focus.key, focus.offset, focus.type, true);
  focus.set(anchorKey, anchorOffset, anchorType, true);
}
function moveNativeSelection(domSelection, alter, direction, granularity) {
  domSelection.modify(alter, direction, granularity);
}
function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
    const anchorOffset = anchor.offset;
    const focusOffset = focus.offset;
    const isBefore = anchorOffset < focusOffset;
    const startOffset = isBefore ? anchorOffset : focusOffset;
    const endOffset = isBefore ? focusOffset : anchorOffset;
    const characterOffset = endOffset - 1;
    if (startOffset !== characterOffset) {
      const text = anchorNode.getTextContent().slice(startOffset, endOffset);
      if (shouldDeleteExactlyOneCodeUnit(text)) {
        if (isBackward) {
          focus.set(focus.key, characterOffset, focus.type);
        } else {
          anchor.set(anchor.key, characterOffset, anchor.type);
        }
      }
    }
  }
}
function shouldDeleteExactlyOneCodeUnit(text) {
  {
    if (!(text.length > 1)) {
      formatDevErrorMessage(`shouldDeleteExactlyOneCodeUnit: expecting to be called only with sequences of two or more code units`);
    }
  }
  return !(doesContainSurrogatePair(text) || doesContainEmoji(text));
}
function $removeSegment(node, isBackward, offset) {
  const textNode = node;
  const textContent2 = textNode.getTextContent();
  const split = textContent2.split(/(?=\s)/g);
  const splitLength = split.length;
  let segmentOffset = 0;
  let restoreOffset = 0;
  for (let i2 = 0; i2 < splitLength; i2++) {
    const text = split[i2];
    const isLast = i2 === splitLength - 1;
    restoreOffset = segmentOffset;
    segmentOffset += text.length;
    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
      split.splice(i2, 1);
      if (isLast) {
        restoreOffset = void 0;
      }
      break;
    }
  }
  const nextTextContent = split.join("").trim();
  if (nextTextContent === "") {
    textNode.remove();
  } else {
    textNode.setTextContent(nextTextContent);
    textNode.select(restoreOffset, restoreOffset);
  }
}
function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
  const parent = resolvedElement.getParent();
  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
}
function $internalResolveSelectionPoint(dom2, offset, lastPoint, editor) {
  let resolvedOffset = offset;
  let resolvedNode;
  if (isHTMLElement(dom2)) {
    let moveSelectionToEnd = false;
    const childNodes = dom2.childNodes;
    const childNodesLength = childNodes.length;
    const blockCursorElement = editor._blockCursorElement;
    if (resolvedOffset === childNodesLength) {
      moveSelectionToEnd = true;
      resolvedOffset = childNodesLength - 1;
    }
    let childDOM = childNodes[resolvedOffset];
    let hasBlockCursor = false;
    if (childDOM === blockCursorElement) {
      childDOM = childNodes[resolvedOffset + 1];
      hasBlockCursor = true;
    } else if (blockCursorElement !== null) {
      const blockCursorElementParent = blockCursorElement.parentNode;
      if (dom2 === blockCursorElementParent) {
        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);
        if (offset > blockCursorOffset) {
          resolvedOffset--;
        }
      }
    }
    resolvedNode = $getNodeFromDOM(childDOM);
    if ($isTextNode(resolvedNode)) {
      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
    } else {
      let resolvedElement = $getNodeFromDOM(dom2);
      if (resolvedElement === null) {
        return null;
      }
      if ($isElementNode(resolvedElement)) {
        const elementDOM = editor.getElementByKey(resolvedElement.getKey());
        if (!(elementDOM !== null)) {
          formatDevErrorMessage(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);
        }
        const slot = resolvedElement.getDOMSlot(elementDOM);
        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom2, offset);
        if (!$isElementNode(resolvedElement)) {
          formatDevErrorMessage(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);
        }
        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {
          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);
        }
        let child = resolvedElement.getChildAtIndex(resolvedOffset);
        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
          if (descendant === null) {
            resolvedElement = child;
          } else {
            child = descendant;
            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
          }
          resolvedOffset = 0;
        }
        if ($isTextNode(child)) {
          resolvedNode = child;
          resolvedElement = null;
          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
          if (!$isElementNode(resolvedElement)) {
            formatDevErrorMessage(`invariant`);
          }
          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);
        }
      } else {
        const index = resolvedElement.getIndexWithinParent();
        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom2) === resolvedElement) {
          resolvedOffset = index;
        } else {
          resolvedOffset = index + 1;
        }
        resolvedElement = resolvedElement.getParentOrThrow();
      }
      if ($isElementNode(resolvedElement)) {
        return $createPoint(resolvedElement.__key, resolvedOffset, "element");
      }
    }
  } else {
    resolvedNode = $getNodeFromDOM(dom2);
  }
  if (!$isTextNode(resolvedNode)) {
    return null;
  }
  return $createPoint(resolvedNode.__key, resolvedOffset, "text");
}
function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
  const offset = point.offset;
  const node = point.getNode();
  if (offset === 0) {
    const prevSibling = node.getPreviousSibling();
    const parent = node.getParent();
    if (!isBackward) {
      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
        point.set(prevSibling.__key, prevSibling.getChildrenSize(), "element");
      } else if ($isTextNode(prevSibling)) {
        point.set(prevSibling.__key, prevSibling.getTextContent().length, "text");
      }
    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
      const parentSibling = parent.getPreviousSibling();
      if ($isTextNode(parentSibling)) {
        point.set(parentSibling.__key, parentSibling.getTextContent().length, "text");
      }
    }
  } else if (offset === node.getTextContent().length) {
    const nextSibling2 = node.getNextSibling();
    const parent = node.getParent();
    if (isBackward && $isElementNode(nextSibling2) && nextSibling2.isInline()) {
      point.set(nextSibling2.__key, 0, "element");
    } else if ((isCollapsed || isBackward) && nextSibling2 === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
      const parentSibling = parent.getNextSibling();
      if ($isTextNode(parentSibling)) {
        point.set(parentSibling.__key, 0, "text");
      }
    }
  }
}
function $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
  if (anchor.type === "text" && focus.type === "text") {
    const isBackward = anchor.isBefore(focus);
    const isCollapsed = anchor.is(focus);
    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
    if (isCollapsed) {
      focus.set(anchor.key, anchor.offset, anchor.type);
    }
    const editor = getActiveEditor();
    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
      const lastAnchor = lastSelection.anchor;
      const lastFocus = lastSelection.focus;
      anchor.set(lastAnchor.key, lastAnchor.offset, lastAnchor.type, true);
      focus.set(lastFocus.key, lastFocus.offset, lastFocus.type, true);
    }
  }
}
function $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    return null;
  }
  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);
  if (resolvedAnchorPoint === null) {
    return null;
  }
  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);
  if (resolvedFocusPoint === null) {
    return null;
  }
  {
    $validatePoint(editor, "anchor", resolvedAnchorPoint);
    $validatePoint(editor, "focus", resolvedAnchorPoint);
  }
  if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
    const anchorNode = $getNodeFromDOM(anchorDOM);
    const focusNode = $getNodeFromDOM(focusDOM);
    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
      return null;
    }
  }
  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
  return [resolvedAnchorPoint, resolvedFocusPoint];
}
function $isBlockElementNode(node) {
  return $isElementNode(node) && !node.isInline();
}
function $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
  const editorState = getActiveEditorState();
  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
  selection.dirty = true;
  editorState._selection = selection;
  return selection;
}
function $createRangeSelection() {
  const anchor = $createPoint("root", 0, "element");
  const focus = $createPoint("root", 0, "element");
  return new RangeSelection(anchor, focus, 0, "");
}
function $createNodeSelection() {
  return new NodeSelection(/* @__PURE__ */ new Set());
}
function $internalCreateSelection(editor, event) {
  const currentEditorState = editor.getEditorState();
  const lastSelection = currentEditorState._selection;
  const domSelection = getDOMSelection(getWindow(editor));
  if ($isRangeSelection(lastSelection) || lastSelection == null) {
    return $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
  }
  return lastSelection.clone();
}
function $createRangeSelectionFromDom(domSelection, editor) {
  return $internalCreateRangeSelection(null, domSelection, editor, null);
}
function $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {
  const windowObj = editor._window;
  if (windowObj === null) {
    return null;
  }
  const windowEvent = event || windowObj.event;
  const eventType = windowEvent ? windowEvent.type : void 0;
  const isSelectionChange = eventType === "selectionchange";
  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
  let anchorDOM, focusDOM, anchorOffset, focusOffset;
  if (!$isRangeSelection(lastSelection) || useDOMSelection) {
    if (domSelection === null) {
      return null;
    }
    anchorDOM = domSelection.anchorNode;
    focusDOM = domSelection.focusNode;
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return lastSelection.clone();
    }
  } else {
    return lastSelection.clone();
  }
  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
  if (resolvedSelectionPoints === null) {
    return null;
  }
  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? "" : lastSelection.style);
}
function $validatePoint(editor, name, point) {
  const node = $getNodeByKey(point.key);
  if (!(node !== void 0)) {
    formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} not found in current editorState`);
  }
  if (point.type === "text") {
    if (!$isTextNode(node)) {
      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not a TextNode`);
    }
    const size = node.getTextContentSize();
    if (!(point.offset <= size)) {
      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);
    }
  } else {
    if (!$isElementNode(node)) {
      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);
    }
    const size = node.getChildrenSize();
    if (!(point.offset <= size)) {
      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);
    }
  }
}
function $getSelection() {
  const editorState = getActiveEditorState();
  return editorState._selection;
}
function $getPreviousSelection() {
  const editor = getActiveEditor();
  return editor._editorState._selection;
}
function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
    return;
  }
  const parentKey = parentNode.__key;
  if (selection.isCollapsed()) {
    const selectionOffset = anchor.offset;
    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
      const newSelectionOffset = Math.max(0, selectionOffset + times);
      anchor.set(parentKey, newSelectionOffset, "element");
      focus.set(parentKey, newSelectionOffset, "element");
      $updateSelectionResolveTextNodes(selection);
    }
  } else {
    const isBackward = selection.isBackward();
    const firstPoint = isBackward ? focus : anchor;
    const firstPointNode = firstPoint.getNode();
    const lastPoint = isBackward ? anchor : focus;
    const lastPointNode = lastPoint.getNode();
    if (parentNode.is(firstPointNode)) {
      const firstPointOffset = firstPoint.offset;
      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
      }
    }
    if (parentNode.is(lastPointNode)) {
      const lastPointOffset = lastPoint.offset;
      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
      }
    }
  }
  $updateSelectionResolveTextNodes(selection);
}
function $updateSelectionResolveTextNodes(selection) {
  const anchor = selection.anchor;
  const anchorOffset = anchor.offset;
  const focus = selection.focus;
  const focusOffset = focus.offset;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (selection.isCollapsed()) {
    if (!$isElementNode(anchorNode)) {
      return;
    }
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
      focus.set(child.__key, newOffset, "text");
    }
    return;
  }
  if ($isElementNode(anchorNode)) {
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
    }
  }
  if ($isElementNode(focusNode)) {
    const childSize = focusNode.getChildrenSize();
    const focusOffsetAtEnd = focusOffset >= childSize;
    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (focusOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      focus.set(child.__key, newOffset, "text");
    }
  }
}
function applySelectionTransforms(nextEditorState, editor) {
  const prevEditorState = editor.getEditorState();
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  if ($isRangeSelection(nextSelection)) {
    const anchor = nextSelection.anchor;
    const focus = nextSelection.focus;
    let anchorNode;
    if (anchor.type === "text") {
      anchorNode = anchor.getNode();
      anchorNode.selectionTransform(prevSelection, nextSelection);
    }
    if (focus.type === "text") {
      const focusNode = focus.getNode();
      if (anchorNode !== focusNode) {
        focusNode.selectionTransform(prevSelection, nextSelection);
      }
    }
  }
}
function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling2) {
  let siblingKey = null;
  let offset = 0;
  let type = null;
  if (prevSibling !== null) {
    siblingKey = prevSibling.__key;
    if ($isTextNode(prevSibling)) {
      offset = prevSibling.getTextContentSize();
      type = "text";
    } else if ($isElementNode(prevSibling)) {
      offset = prevSibling.getChildrenSize();
      type = "element";
    }
  } else {
    if (nextSibling2 !== null) {
      siblingKey = nextSibling2.__key;
      if ($isTextNode(nextSibling2)) {
        type = "text";
      } else if ($isElementNode(nextSibling2)) {
        type = "element";
      }
    }
  }
  if (siblingKey !== null && type !== null) {
    point.set(siblingKey, offset, type);
  } else {
    offset = node.getIndexWithinParent();
    if (offset === -1) {
      offset = parent.getChildrenSize();
    }
    point.set(parent.__key, offset, "element");
  }
}
function adjustPointOffsetForMergedSibling(point, isBefore, key2, target, textLength) {
  if (point.type === "text") {
    point.set(key2, point.offset + (isBefore ? 0 : textLength), "text");
  } else if (point.offset > target.getIndexWithinParent()) {
    point.set(point.key, point.offset - 1, "element");
  }
}
function setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset) {
  try {
    domSelection.setBaseAndExtent(nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset);
  } catch (error) {
    {
      console.warn(error);
    }
  }
}
function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
  const anchorDOMNode = domSelection.anchorNode;
  const focusDOMNode = domSelection.focusNode;
  const anchorOffset = domSelection.anchorOffset;
  const focusOffset = domSelection.focusOffset;
  const activeElement = document.activeElement;
  if (tags.has(COLLABORATION_TAG) && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
    return;
  }
  if (!$isRangeSelection(nextSelection)) {
    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
      domSelection.removeAllRanges();
    }
    return;
  }
  const anchor = nextSelection.anchor;
  const focus = nextSelection.focus;
  const anchorKey = anchor.key;
  const focusKey = focus.key;
  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
  const focusDOM = getElementByKeyOrThrow(editor, focusKey);
  const nextAnchorOffset = anchor.offset;
  const nextFocusOffset = focus.offset;
  const nextFormat = nextSelection.format;
  const nextStyle = nextSelection.style;
  const isCollapsed = nextSelection.isCollapsed();
  let nextAnchorNode = anchorDOM;
  let nextFocusNode = focusDOM;
  let anchorFormatOrStyleChanged = false;
  if (anchor.type === "text") {
    nextAnchorNode = getDOMTextNode(anchorDOM);
    const anchorNode = anchor.getNode();
    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === "text") {
    anchorFormatOrStyleChanged = true;
  }
  if (focus.type === "text") {
    nextFocusNode = getDOMTextNode(focusDOM);
  }
  if (nextAnchorNode === null || nextFocusNode === null) {
    return;
  }
  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
  }
  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
  !(domSelection.type === "Range" && isCollapsed)) {
    if (activeElement === null || !rootElement.contains(activeElement)) {
      rootElement.focus({
        preventScroll: true
      });
    }
    if (anchor.type !== "element") {
      return;
    }
  }
  setDOMSelectionBaseAndExtent(domSelection, nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
  if (!tags.has(SKIP_SCROLL_INTO_VIEW_TAG) && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
    if (selectionTarget !== null) {
      let selectionRect;
      if (selectionTarget instanceof Text) {
        const range = document.createRange();
        range.selectNode(selectionTarget);
        selectionRect = range.getBoundingClientRect();
      } else {
        selectionRect = selectionTarget.getBoundingClientRect();
      }
      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
    }
  }
  markSelectionChangeFromDOMUpdate();
}
function $insertNodes(nodes) {
  let selection = $getSelection() || $getPreviousSelection();
  if (selection === null) {
    selection = $getRoot().selectEnd();
  }
  selection.insertNodes(nodes);
}
function $getTextContent() {
  const selection = $getSelection();
  if (selection === null) {
    return "";
  }
  return selection.getTextContent();
}
function $removeTextAndSplitBlock(selection) {
  let selection_ = selection;
  if (!selection.isCollapsed()) {
    selection_.removeText();
  }
  const newSelection = $getSelection();
  if ($isRangeSelection(newSelection)) {
    selection_ = newSelection;
  }
  if (!$isRangeSelection(selection_)) {
    formatDevErrorMessage(`Unexpected dirty selection to be null`);
  }
  const anchor = selection_.anchor;
  let node = anchor.getNode();
  let offset = anchor.offset;
  while (!INTERNAL_$isBlock(node)) {
    const prevNode = node;
    [node, offset] = $splitNodeAtPoint(node, offset);
    if (prevNode.is(node)) {
      break;
    }
  }
  return offset;
}
function $splitNodeAtPoint(node, offset) {
  const parent = node.getParent();
  if (!parent) {
    const paragraph = $createParagraphNode();
    $getRoot().append(paragraph);
    paragraph.select();
    return [$getRoot(), 0];
  }
  if ($isTextNode(node)) {
    const split = node.splitText(offset);
    if (split.length === 0) {
      return [parent, node.getIndexWithinParent()];
    }
    const x4 = offset === 0 ? 0 : 1;
    const index = split[0].getIndexWithinParent() + x4;
    return [parent, index];
  }
  if (!$isElementNode(node) || offset === 0) {
    return [parent, node.getIndexWithinParent()];
  }
  const firstToAppend = node.getChildAtIndex(offset);
  if (firstToAppend) {
    const insertPoint = new RangeSelection($createPoint(node.__key, offset, "element"), $createPoint(node.__key, offset, "element"), 0, "");
    const newElement = node.insertNewAfter(insertPoint);
    if (newElement) {
      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());
    }
  }
  return [parent, node.getIndexWithinParent() + 1];
}
function $wrapInlineNodes(nodes) {
  const virtualRoot = $createParagraphNode();
  let currentBlock = null;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    const isLineBreakNode = $isLineBreakNode(node);
    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {
      if (currentBlock === null) {
        currentBlock = node.createParentElementNode();
        virtualRoot.append(currentBlock);
        if (isLineBreakNode) {
          continue;
        }
      }
      if (currentBlock !== null) {
        currentBlock.append(node);
      }
    } else {
      virtualRoot.append(node);
      currentBlock = null;
    }
  }
  return virtualRoot;
}
function $getNodesFromCaretRangeCompat(range) {
  const nodes = [];
  const [beforeSlice, afterSlice] = range.getTextSlices();
  if (beforeSlice) {
    nodes.push(beforeSlice.caret.origin);
  }
  const seenAncestors = /* @__PURE__ */ new Set();
  const seenElements = /* @__PURE__ */ new Set();
  for (const caret of range) {
    if ($isChildCaret(caret)) {
      const {
        origin
      } = caret;
      if (nodes.length === 0) {
        seenAncestors.add(origin);
      } else {
        seenElements.add(origin);
        nodes.push(origin);
      }
    } else {
      const {
        origin
      } = caret;
      if (!$isElementNode(origin) || !seenElements.has(origin)) {
        nodes.push(origin);
      }
    }
  }
  if (afterSlice) {
    nodes.push(afterSlice.caret.origin);
  }
  if ($isSiblingCaret(range.focus) && $isElementNode(range.focus.origin) && range.focus.getNodeAtCaret() === null) {
    for (let reverseCaret = $getChildCaret(range.focus.origin, "previous"); $isChildCaret(reverseCaret) && seenAncestors.has(reverseCaret.origin) && !reverseCaret.origin.isEmpty() && reverseCaret.origin.is(nodes[nodes.length - 1]); reverseCaret = $getAdjacentChildCaret(reverseCaret)) {
      seenAncestors.delete(reverseCaret.origin);
      nodes.pop();
    }
  }
  while (nodes.length > 1) {
    const lastIncludedNode = nodes[nodes.length - 1];
    if ($isElementNode(lastIncludedNode)) {
      if (seenElements.has(lastIncludedNode) || lastIncludedNode.isEmpty() || seenAncestors.has(lastIncludedNode)) ;
      else {
        nodes.pop();
        continue;
      }
    }
    break;
  }
  if (nodes.length === 0 && range.isCollapsed()) {
    const normCaret = $normalizeCaret(range.anchor);
    const flippedNormCaret = $normalizeCaret(range.anchor.getFlipped());
    const $getCandidate = (caret) => $isTextPointCaret(caret) ? caret.origin : caret.getNodeAtCaret();
    const node = $getCandidate(normCaret) || $getCandidate(flippedNormCaret) || (range.anchor.getNodeAtCaret() ? normCaret.origin : flippedNormCaret.origin);
    nodes.push(node);
  }
  return nodes;
}
function $modifySelectionAroundDecoratorsAndBlocks(selection, alter, isBackward, granularity, mode = "decorators-and-blocks") {
  if (alter === "move" && granularity === "character" && !selection.isCollapsed()) {
    const [src, dst] = isBackward === selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];
    dst.set(src.key, src.offset, src.type);
    return true;
  }
  const initialFocus = $caretFromPoint(selection.focus, isBackward ? "previous" : "next");
  const isLineBoundary = granularity === "lineboundary";
  const collapse = alter === "move";
  let focus = initialFocus;
  let checkForBlock = mode === "decorators-and-blocks";
  if (!$isExtendableTextPointCaret(focus)) {
    for (const siblingCaret of focus) {
      checkForBlock = false;
      const {
        origin
      } = siblingCaret;
      if ($isDecoratorNode(origin) && !origin.isIsolated()) {
        focus = siblingCaret;
        if (isLineBoundary && origin.isInline()) {
          continue;
        }
      }
      break;
    }
    if (checkForBlock) {
      for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets(alter === "extend" ? "shadowRoot" : "root")) {
        if ($isChildCaret(nextCaret)) {
          if (!nextCaret.origin.isInline()) {
            focus = nextCaret;
          }
        } else if ($isElementNode(nextCaret.origin)) {
          continue;
        } else if ($isDecoratorNode(nextCaret.origin) && !nextCaret.origin.isInline()) {
          focus = nextCaret;
        }
        break;
      }
    }
  }
  if (focus === initialFocus) {
    return false;
  }
  if (collapse && !isLineBoundary && $isDecoratorNode(focus.origin) && focus.origin.isKeyboardSelectable()) {
    const nodeSelection = $createNodeSelection();
    nodeSelection.add(focus.origin.getKey());
    $setSelection(nodeSelection);
    return true;
  }
  focus = $normalizeCaret(focus);
  if (collapse) {
    $setPointFromCaret(selection.anchor, focus);
  }
  $setPointFromCaret(selection.focus, focus);
  return checkForBlock || !isLineBoundary;
}
function isCurrentlyReadOnlyMode() {
  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
}
function errorOnReadOnly() {
  if (isReadOnlyMode) {
    {
      formatDevErrorMessage(`Cannot use method in read-only mode.`);
    }
  }
}
function errorOnInfiniteTransforms() {
  if (infiniteTransformCount > 99) {
    {
      formatDevErrorMessage(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
    }
  }
}
function getActiveEditorState() {
  if (activeEditorState === null) {
    {
      formatDevErrorMessage(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);
    }
  }
  return activeEditorState;
}
function getActiveEditor() {
  if (activeEditor === null) {
    {
      formatDevErrorMessage(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);
    }
  }
  return activeEditor;
}
function collectBuildInformation() {
  let compatibleEditors = 0;
  const incompatibleEditors = /* @__PURE__ */ new Set();
  const thisVersion = LexicalEditor.version;
  if (typeof window !== "undefined") {
    for (const node of document.querySelectorAll("[contenteditable]")) {
      const editor = getEditorPropertyFromDOMNode(node);
      if (isLexicalEditor(editor)) {
        compatibleEditors++;
      } else if (editor) {
        let version = String(editor.constructor.version || "<0.17.1");
        if (version === thisVersion) {
          version += " (separately built, likely a bundler configuration issue)";
        }
        incompatibleEditors.add(version);
      }
    }
  }
  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;
  if (incompatibleEditors.size) {
    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(", ")}`;
  }
  return output;
}
function internalGetActiveEditor() {
  return activeEditor;
}
function internalGetActiveEditorState() {
  return activeEditorState;
}
function $applyTransforms(editor, node, transformsCache) {
  const type = node.__type;
  const registeredNode = getRegisteredNodeOrThrow(editor, type);
  let transformsArr = transformsCache.get(type);
  if (transformsArr === void 0) {
    transformsArr = Array.from(registeredNode.transforms);
    transformsCache.set(type, transformsArr);
  }
  const transformsArrLength = transformsArr.length;
  for (let i2 = 0; i2 < transformsArrLength; i2++) {
    transformsArr[i2](node);
    if (!node.isAttached()) {
      break;
    }
  }
}
function $isNodeValidForTransform(node, compositionKey) {
  return node !== void 0 && // We don't want to transform nodes being composed
  node.__key !== compositionKey && node.isAttached();
}
function $normalizeAllDirtyTextNodes(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const nodeMap = editorState._nodeMap;
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
      $normalizeTextNode(node);
    }
  }
}
function addTags(editor, tags) {
  if (!tags) {
    return;
  }
  const updateTags = editor._updateTags;
  let tags_ = tags;
  if (!Array.isArray(tags)) {
    tags_ = [tags];
  }
  for (const tag of tags_) {
    updateTags.add(tag);
  }
}
function $applyAllTransforms(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const nodeMap = editorState._nodeMap;
  const compositionKey = $getCompositionKey();
  const transformsCache = /* @__PURE__ */ new Map();
  let untransformedDirtyLeaves = dirtyLeaves;
  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
  let untransformedDirtyElements = dirtyElements;
  let untransformedDirtyElementsLength = untransformedDirtyElements.size;
  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
    if (untransformedDirtyLeavesLength > 0) {
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      for (const nodeKey of untransformedDirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
          $normalizeTextNode(node);
        }
        if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
          $applyTransforms(editor, node, transformsCache);
        }
        dirtyLeaves.add(nodeKey);
      }
      untransformedDirtyLeaves = editor._dirtyLeaves;
      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      if (untransformedDirtyLeavesLength > 0) {
        infiniteTransformCount++;
        continue;
      }
    }
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    const rootDirty = untransformedDirtyElements.delete("root");
    if (rootDirty) {
      untransformedDirtyElements.set("root", true);
    }
    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
      const nodeKey = currentUntransformedDirtyElement[0];
      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
      if (!intentionallyMarkedAsDirty) {
        continue;
      }
      const node = nodeMap.get(nodeKey);
      if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
        $applyTransforms(editor, node, transformsCache);
      }
    }
    untransformedDirtyLeaves = editor._dirtyLeaves;
    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    untransformedDirtyElements = editor._dirtyElements;
    untransformedDirtyElementsLength = untransformedDirtyElements.size;
    infiniteTransformCount++;
  }
  editor._dirtyLeaves = dirtyLeaves;
  editor._dirtyElements = dirtyElements;
}
function $parseSerializedNode(serializedNode) {
  const internalSerializedNode = serializedNode;
  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
}
function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
  const type = serializedNode.type;
  const registeredNode = registeredNodes.get(type);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`parseEditorState: type "${type}" + not found`);
    }
  }
  const nodeClass = registeredNode.klass;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
    }
  }
  const node = nodeClass.importJSON(serializedNode);
  const children = serializedNode.children;
  if ($isElementNode(node) && Array.isArray(children)) {
    for (let i2 = 0; i2 < children.length; i2++) {
      const serializedJSONChildNode = children[i2];
      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
      node.append(childNode);
    }
  }
  return node;
}
function parseEditorState(serializedEditorState, editor, updateFn) {
  const editorState = createEmptyEditorState();
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previousDirtyElements = editor._dirtyElements;
  const previousDirtyLeaves = editor._dirtyLeaves;
  const previousCloneNotNeeded = editor._cloneNotNeeded;
  const previousDirtyType = editor._dirtyType;
  editor._dirtyElements = /* @__PURE__ */ new Map();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._cloneNotNeeded = /* @__PURE__ */ new Set();
  editor._dirtyType = 0;
  activeEditorState = editorState;
  isReadOnlyMode = false;
  activeEditor = editor;
  try {
    const registeredNodes = editor._nodes;
    const serializedNode = serializedEditorState.root;
    $parseSerializedNodeImpl(serializedNode, registeredNodes);
    if (updateFn) {
      updateFn();
    }
    editorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(editorState);
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
  } finally {
    editor._dirtyElements = previousDirtyElements;
    editor._dirtyLeaves = previousDirtyLeaves;
    editor._cloneNotNeeded = previousCloneNotNeeded;
    editor._dirtyType = previousDirtyType;
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
  return editorState;
}
function readEditorState(editor, editorState, callbackFn) {
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  activeEditorState = editorState;
  isReadOnlyMode = true;
  activeEditor = editor;
  try {
    return callbackFn();
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
}
function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
  const nodeMap = pendingEditorState._nodeMap;
  nodeMap.set = () => {
    throw new Error("Cannot call set() on a frozen Lexical node map");
  };
  nodeMap.clear = () => {
    throw new Error("Cannot call clear() on a frozen Lexical node map");
  };
  nodeMap.delete = () => {
    throw new Error("Cannot call delete() on a frozen Lexical node map");
  };
}
function $commitPendingUpdates(editor, recoveryEditorState) {
  const pendingEditorState = editor._pendingEditorState;
  const rootElement = editor._rootElement;
  const shouldSkipDOM = editor._headless || rootElement === null;
  if (pendingEditorState === null) {
    return;
  }
  const currentEditorState = editor._editorState;
  const currentSelection = currentEditorState._selection;
  const pendingSelection = pendingEditorState._selection;
  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  const observer = editor._observer;
  let mutatedNodes2 = null;
  editor._pendingEditorState = null;
  editor._editorState = pendingEditorState;
  if (!shouldSkipDOM && needsUpdate && observer !== null) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    isReadOnlyMode = false;
    editor._updating = true;
    try {
      const dirtyType = editor._dirtyType;
      const dirtyElements2 = editor._dirtyElements;
      const dirtyLeaves2 = editor._dirtyLeaves;
      observer.disconnect();
      mutatedNodes2 = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
    } catch (error) {
      if (error instanceof Error) {
        editor._onError(error);
      }
      if (!isAttemptingToRecoverFromReconcilerError) {
        resetEditor(editor, null, rootElement, pendingEditorState);
        initMutationObserver(editor);
        editor._dirtyType = FULL_RECONCILE;
        isAttemptingToRecoverFromReconcilerError = true;
        $commitPendingUpdates(editor, currentEditorState);
        isAttemptingToRecoverFromReconcilerError = false;
      } else {
        throw error;
      }
      return;
    } finally {
      observer.observe(rootElement, observerOptions);
      editor._updating = previouslyUpdating;
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
  }
  if (!pendingEditorState._readOnly) {
    pendingEditorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
      if ($isRangeSelection(pendingSelection)) {
        Object.freeze(pendingSelection.anchor);
        Object.freeze(pendingSelection.focus);
      }
      Object.freeze(pendingSelection);
    }
  }
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const normalizedNodes = editor._normalizedNodes;
  const tags = editor._updateTags;
  const deferred = editor._deferred;
  if (needsUpdate) {
    editor._dirtyType = NO_DIRTY_NODES;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    editor._normalizedNodes = /* @__PURE__ */ new Set();
    editor._updateTags = /* @__PURE__ */ new Set();
  }
  $garbageCollectDetachedDecorators(editor, pendingEditorState);
  const domSelection = shouldSkipDOM ? null : getDOMSelection(getWindow(editor));
  if (editor._editable && // domSelection will be null in headless
  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags.has(SKIP_DOM_SELECTION_TAG)) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    try {
      if (observer !== null) {
        observer.disconnect();
      }
      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
        const blockCursorElement = editor._blockCursorElement;
        if (blockCursorElement !== null) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);
      }
      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
    } finally {
      if (observer !== null) {
        observer.observe(rootElement, observerOptions);
      }
      activeEditor = previousActiveEditor;
      activeEditorState = previousActiveEditorState;
    }
  }
  if (mutatedNodes2 !== null) {
    triggerMutationListeners(editor, mutatedNodes2, tags, dirtyLeaves, currentEditorState);
  }
  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
  }
  const pendingDecorators = editor._pendingDecorators;
  if (pendingDecorators !== null) {
    editor._decorators = pendingDecorators;
    editor._pendingDecorators = null;
    triggerListeners("decorator", editor, true, pendingDecorators);
  }
  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
  triggerListeners("update", editor, true, {
    dirtyElements,
    dirtyLeaves,
    editorState: pendingEditorState,
    mutatedNodes: mutatedNodes2,
    normalizedNodes,
    prevEditorState: recoveryEditorState || currentEditorState,
    tags
  });
  triggerDeferredUpdateCallbacks(editor, deferred);
  $triggerEnqueuedUpdates(editor);
}
function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
  const currentTextContent = getEditorStateTextContent(currentEditorState);
  const latestTextContent = getEditorStateTextContent(pendingEditorState);
  if (currentTextContent !== latestTextContent) {
    triggerListeners("textcontent", editor, true, latestTextContent);
  }
}
function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
  const listeners = Array.from(editor._listeners.mutation);
  const listenersLength = listeners.length;
  for (let i2 = 0; i2 < listenersLength; i2++) {
    const [listener, klass] = listeners[i2];
    const mutatedNodesByType = mutatedNodes2.get(klass);
    if (mutatedNodesByType !== void 0) {
      listener(mutatedNodesByType, {
        dirtyLeaves,
        prevEditorState,
        updateTags
      });
    }
  }
}
function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
  const previouslyUpdating = editor._updating;
  editor._updating = isCurrentlyEnqueuingUpdates;
  try {
    const listeners = Array.from(editor._listeners[type]);
    for (let i2 = 0; i2 < listeners.length; i2++) {
      listeners[i2].apply(null, payload);
    }
  } finally {
    editor._updating = previouslyUpdating;
  }
}
function triggerCommandListeners(editor, type, payload) {
  const editors = getEditorsToPropagate(editor);
  for (let i2 = 4; i2 >= 0; i2--) {
    for (let e2 = 0; e2 < editors.length; e2++) {
      const currentEditor = editors[e2];
      const commandListeners = currentEditor._commands;
      const listenerInPriorityOrder = commandListeners.get(type);
      if (listenerInPriorityOrder !== void 0) {
        const listenersSet = listenerInPriorityOrder[i2];
        if (listenersSet !== void 0) {
          const listeners = Array.from(listenersSet);
          const listenersLength = listeners.length;
          let returnVal = false;
          updateEditorSync(currentEditor, () => {
            for (let j5 = 0; j5 < listenersLength; j5++) {
              if (listeners[j5](payload, editor)) {
                returnVal = true;
                return;
              }
            }
          });
          if (returnVal) {
            return returnVal;
          }
        }
      }
    }
  }
  return false;
}
function $triggerEnqueuedUpdates(editor) {
  const queuedUpdates = editor._updates;
  if (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [updateFn, options] = queuedUpdate;
      $beginUpdate(editor, updateFn, options);
    }
  }
}
function triggerDeferredUpdateCallbacks(editor, deferred) {
  editor._deferred = [];
  if (deferred.length !== 0) {
    const previouslyUpdating = editor._updating;
    editor._updating = true;
    try {
      for (let i2 = 0; i2 < deferred.length; i2++) {
        deferred[i2]();
      }
    } finally {
      editor._updating = previouslyUpdating;
    }
  }
}
function processNestedUpdates(editor, initialSkipTransforms) {
  const queuedUpdates = editor._updates;
  let skipTransforms = initialSkipTransforms || false;
  while (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [nextUpdateFn, options] = queuedUpdate;
      let onUpdate;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        if (options.skipTransforms) {
          skipTransforms = true;
        }
        if (options.discrete) {
          const pendingEditorState = editor._pendingEditorState;
          if (!(pendingEditorState !== null)) {
            formatDevErrorMessage(`Unexpected empty pending editor state on discrete nested update`);
          }
          pendingEditorState._flushSync = true;
        }
        if (onUpdate) {
          editor._deferred.push(onUpdate);
        }
        addTags(editor, options.tag);
      }
      nextUpdateFn();
    }
  }
  return skipTransforms;
}
function $beginUpdate(editor, updateFn, options) {
  const updateTags = editor._updateTags;
  let onUpdate;
  let skipTransforms = false;
  let discrete = false;
  if (options !== void 0) {
    onUpdate = options.onUpdate;
    addTags(editor, options.tag);
    skipTransforms = options.skipTransforms || false;
    discrete = options.discrete || false;
  }
  if (onUpdate) {
    editor._deferred.push(onUpdate);
  }
  const currentEditorState = editor._editorState;
  let pendingEditorState = editor._pendingEditorState;
  let editorStateWasCloned = false;
  if (pendingEditorState === null || pendingEditorState._readOnly) {
    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
    editorStateWasCloned = true;
  }
  pendingEditorState._flushSync = discrete;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  activeEditorState = pendingEditorState;
  isReadOnlyMode = false;
  editor._updating = true;
  activeEditor = editor;
  const headless = editor._headless || editor.getRootElement() === null;
  try {
    if (editorStateWasCloned) {
      if (headless) {
        if (currentEditorState._selection !== null) {
          pendingEditorState._selection = currentEditorState._selection.clone();
        }
      } else {
        pendingEditorState._selection = $internalCreateSelection(editor, options && options.event || null);
      }
    }
    const startingCompositionKey = editor._compositionKey;
    updateFn();
    skipTransforms = processNestedUpdates(editor, skipTransforms);
    applySelectionTransforms(pendingEditorState, editor);
    if (editor._dirtyType !== NO_DIRTY_NODES) {
      if (skipTransforms) {
        $normalizeAllDirtyTextNodes(pendingEditorState, editor);
      } else {
        $applyAllTransforms(pendingEditorState, editor);
      }
      processNestedUpdates(editor);
      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
    }
    const endingCompositionKey = editor._compositionKey;
    if (startingCompositionKey !== endingCompositionKey) {
      pendingEditorState._flushSync = true;
    }
    const pendingSelection = pendingEditorState._selection;
    if ($isRangeSelection(pendingSelection)) {
      const pendingNodeMap = pendingEditorState._nodeMap;
      const anchorKey = pendingSelection.anchor.key;
      const focusKey = pendingSelection.focus.key;
      if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
        {
          formatDevErrorMessage(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
        }
      }
    } else if ($isNodeSelection(pendingSelection)) {
      if (pendingSelection._nodes.size === 0) {
        pendingEditorState._selection = null;
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
    editor._pendingEditorState = currentEditorState;
    editor._dirtyType = FULL_RECONCILE;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements.clear();
    $commitPendingUpdates(editor);
    return;
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
    editor._updating = previouslyUpdating;
    infiniteTransformCount = 0;
  }
  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);
  if (shouldUpdate) {
    if (pendingEditorState._flushSync) {
      pendingEditorState._flushSync = false;
      $commitPendingUpdates(editor);
    } else if (editorStateWasCloned) {
      scheduleMicroTask(() => {
        $commitPendingUpdates(editor);
      });
    }
  } else {
    pendingEditorState._flushSync = false;
    if (editorStateWasCloned) {
      updateTags.clear();
      editor._deferred = [];
      editor._pendingEditorState = null;
    }
  }
}
function updateEditorSync(editor, updateFn, options) {
  if (activeEditor === editor && options === void 0) {
    updateFn();
  } else {
    $beginUpdate(editor, updateFn, options);
  }
}
function updateEditor(editor, updateFn, options) {
  if (editor._updating) {
    editor._updates.push([updateFn, options]);
  } else {
    $beginUpdate(editor, updateFn, options);
  }
}
function indexPath(root, child) {
  const path = [];
  let node = child;
  for (; node !== root && node !== null; node = node.parentNode) {
    let i2 = 0;
    for (let sibling = node.previousSibling; sibling !== null; sibling = sibling.previousSibling) {
      i2++;
    }
    path.push(i2);
  }
  if (!(node === root)) {
    formatDevErrorMessage(`indexPath: root is not a parent of child`);
  }
  return path.reverse();
}
function $isElementNode(node) {
  return node instanceof ElementNode;
}
function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
  let node = point.getNode();
  while (node) {
    const nodeKey = node.__key;
    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
      return true;
    }
    node = node.getParent();
  }
  return false;
}
function $isDecoratorNode(node) {
  return node instanceof DecoratorNode;
}
function $createRootNode() {
  return new RootNode();
}
function $isRootNode(node) {
  return node instanceof RootNode;
}
function editorStateHasDirtySelection(editorState, editor) {
  const currentSelection = editor.getEditorState()._selection;
  const pendingSelection = editorState._selection;
  if (pendingSelection !== null) {
    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
      return true;
    }
  } else if (currentSelection !== null) {
    return true;
  }
  return false;
}
function cloneEditorState(current) {
  return new EditorState(new Map(current._nodeMap));
}
function createEmptyEditorState() {
  return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
}
function exportNodeToJSON(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    }
  }
  if ($isElementNode(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
    const children = node.getChildren();
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      const serializedChildNode = exportNodeToJSON(child);
      serializedChildren.push(serializedChildNode);
    }
  }
  return serializedNode;
}
function $convertParagraphElement(element) {
  const node = $createParagraphNode();
  if (element.style) {
    node.setFormat(element.style.textAlign);
    setNodeIndentFromDOM(element, node);
  }
  return {
    node
  };
}
function $createParagraphNode() {
  return $applyNodeReplacement(new ParagraphNode());
}
function $isParagraphNode(node) {
  return node instanceof ParagraphNode;
}
function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
  const keyNodeMap = editor._keyToDOMMap;
  keyNodeMap.clear();
  editor._editorState = createEmptyEditorState();
  editor._pendingEditorState = pendingEditorState;
  editor._compositionKey = null;
  editor._dirtyType = NO_DIRTY_NODES;
  editor._cloneNotNeeded.clear();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._dirtyElements.clear();
  editor._normalizedNodes = /* @__PURE__ */ new Set();
  editor._updateTags = /* @__PURE__ */ new Set();
  editor._updates = [];
  editor._blockCursorElement = null;
  const observer = editor._observer;
  if (observer !== null) {
    observer.disconnect();
    editor._observer = null;
  }
  if (prevRootElement !== null) {
    prevRootElement.textContent = "";
  }
  if (nextRootElement !== null) {
    nextRootElement.textContent = "";
    keyNodeMap.set("root", nextRootElement);
  }
}
function initializeConversionCache(nodes, additionalConversions) {
  const conversionCache = /* @__PURE__ */ new Map();
  const handledConversions = /* @__PURE__ */ new Set();
  const addConversionsToCache = (map) => {
    Object.keys(map).forEach((key2) => {
      let currentCache = conversionCache.get(key2);
      if (currentCache === void 0) {
        currentCache = [];
        conversionCache.set(key2, currentCache);
      }
      currentCache.push(map[key2]);
    });
  };
  nodes.forEach((node) => {
    const importDOM = node.klass.importDOM;
    if (importDOM == null || handledConversions.has(importDOM)) {
      return;
    }
    handledConversions.add(importDOM);
    const map = importDOM.call(node.klass);
    if (map !== null) {
      addConversionsToCache(map);
    }
  });
  if (additionalConversions) {
    addConversionsToCache(additionalConversions);
  }
  return conversionCache;
}
function createEditor(editorConfig) {
  const config = editorConfig || {};
  const activeEditor2 = internalGetActiveEditor();
  const theme = config.theme || {};
  const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
  const disableEvents = config.disableEvents || false;
  const editorState = createEmptyEditorState();
  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
  const initialEditorState = config.editorState;
  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...config.nodes || []];
  const {
    onError,
    html
  } = config;
  const isEditable = config.editable !== void 0 ? config.editable : true;
  let registeredNodes;
  if (editorConfig === void 0 && activeEditor2 !== null) {
    registeredNodes = activeEditor2._nodes;
  } else {
    registeredNodes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < nodes.length; i2++) {
      let klass = nodes[i2];
      let replace2 = null;
      let replaceWithKlass = null;
      if (typeof klass !== "function") {
        const options = klass;
        klass = options.replace;
        replace2 = options.with;
        replaceWithKlass = options.withKlass || null;
      }
      {
        const nodeType = Object.prototype.hasOwnProperty.call(klass, "getType") && klass.getType();
        const name = klass.name;
        if (replaceWithKlass) {
          if (!(replaceWithKlass.prototype instanceof klass)) {
            formatDevErrorMessage(`${replaceWithKlass.name} doesn't extend the ${name}`);
          }
        }
        if (name !== "RootNode" && nodeType !== "root" && nodeType !== "artificial") {
          const proto = klass.prototype;
          ["getType", "clone"].forEach((method) => {
            if (!klass.hasOwnProperty(method)) {
              console.warn(`${name} must implement static "${method}" method`);
            }
          });
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            klass.hasOwnProperty("exportDOM")
          ) {
            console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
          }
          if ($isDecoratorNode(proto)) {
            if (!proto.hasOwnProperty("decorate")) {
              console.warn(`${proto.constructor.name} must implement "decorate" method`);
            }
          }
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importJSON")
          ) {
            console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
      }
      const type = klass.getType();
      const transform = klass.transform();
      const transforms = /* @__PURE__ */ new Set();
      if (transform !== null) {
        transforms.add(transform);
      }
      registeredNodes.set(type, {
        exportDOM: html && html.export ? html.export.get(klass) : void 0,
        klass,
        replace: replace2,
        replaceWithKlass,
        transforms
      });
    }
  }
  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
    disableEvents,
    namespace,
    theme
  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : void 0), isEditable, editorConfig);
  if (initialEditorState !== void 0) {
    editor._pendingEditorState = initialEditorState;
    editor._dirtyType = FULL_RECONCILE;
  }
  return editor;
}
function resetRandomKey() {
  keyCounter = 1;
}
function generateRandomKey() {
  return "" + keyCounter++;
}
function getRegisteredNodeOrThrow(editor, nodeType) {
  const registeredNode = editor._nodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`registeredNode: Type ${nodeType} not found`);
    }
  }
  return registeredNode;
}
function $isSelectionCapturedInDecorator(node) {
  return $isDecoratorNode($getNearestNodeFromDOMNode(node));
}
function isSelectionCapturedInDecoratorInput(anchorDOM) {
  const activeElement = document.activeElement;
  if (!isHTMLElement(activeElement)) {
    return false;
  }
  const nodeName = activeElement.nodeName;
  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && getEditorPropertyFromDOMNode(activeElement) == null);
}
function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
  const rootElement = editor.getRootElement();
  try {
    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
  } catch (error) {
    return false;
  }
}
function isLexicalEditor(editor) {
  return editor instanceof LexicalEditor;
}
function getNearestEditorFromDOMNode(node) {
  let currentNode = node;
  while (currentNode != null) {
    const editor = getEditorPropertyFromDOMNode(currentNode);
    if (isLexicalEditor(editor)) {
      return editor;
    }
    currentNode = getParentElement(currentNode);
  }
  return null;
}
function getEditorPropertyFromDOMNode(node) {
  return node ? node.__lexicalEditor : null;
}
function getTextDirection(text) {
  if (RTL_REGEX.test(text)) {
    return "rtl";
  }
  if (LTR_REGEX.test(text)) {
    return "ltr";
  }
  return null;
}
function $isTokenOrTab(node) {
  return $isTabNode(node) || node.isToken();
}
function $isTokenOrSegmented(node) {
  return $isTokenOrTab(node) || node.isSegmented();
}
function isDOMTextNode(node) {
  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;
}
function isDOMDocumentNode(node) {
  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;
}
function getDOMTextNode(element) {
  let node = element;
  while (node != null) {
    if (isDOMTextNode(node)) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function toggleTextFormatType(format, type, alignWithFormat) {
  const activeFormat = TEXT_TYPE_TO_FORMAT[type];
  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {
    return format;
  }
  let newFormat = format ^ activeFormat;
  if (type === "subscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;
  } else if (type === "superscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;
  } else if (type === "lowercase") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
  } else if (type === "uppercase") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
  } else if (type === "capitalize") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
  }
  return newFormat;
}
function $isLeafNode(node) {
  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
}
function $setNodeKey(node, existingKey) {
  if (existingKey != null) {
    {
      errorOnNodeKeyConstructorMismatch(node, existingKey);
    }
    node.__key = existingKey;
    return;
  }
  errorOnReadOnly();
  errorOnInfiniteTransforms();
  const editor = getActiveEditor();
  const editorState = getActiveEditorState();
  const key2 = generateRandomKey();
  editorState._nodeMap.set(key2, node);
  if ($isElementNode(node)) {
    editor._dirtyElements.set(key2, true);
  } else {
    editor._dirtyLeaves.add(key2);
  }
  editor._cloneNotNeeded.add(key2);
  editor._dirtyType = HAS_DIRTY_NODES;
  node.__key = key2;
}
function errorOnNodeKeyConstructorMismatch(node, existingKey) {
  const editorState = internalGetActiveEditorState();
  if (!editorState) {
    return;
  }
  const existingNode = editorState._nodeMap.get(existingKey);
  if (existingNode && existingNode.constructor !== node.constructor) {
    if (node.constructor.name !== existingNode.constructor.name) {
      {
        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);
      }
    } else {
      {
        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);
      }
    }
  }
}
function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
  let nextParentKey = parentKey;
  while (nextParentKey !== null) {
    if (dirtyElements.has(nextParentKey)) {
      return;
    }
    const node = nodeMap.get(nextParentKey);
    if (node === void 0) {
      break;
    }
    dirtyElements.set(nextParentKey, false);
    nextParentKey = node.__parent;
  }
}
function removeFromParent(node) {
  const oldParent = node.getParent();
  if (oldParent !== null) {
    const writableNode = node.getWritable();
    const writableParent = oldParent.getWritable();
    const prevSibling = node.getPreviousSibling();
    const nextSibling2 = node.getNextSibling();
    const nextSiblingKey = nextSibling2 !== null ? nextSibling2.__key : null;
    const prevSiblingKey = prevSibling !== null ? prevSibling.__key : null;
    const writablePrevSibling = prevSibling !== null ? prevSibling.getWritable() : null;
    const writableNextSibling = nextSibling2 !== null ? nextSibling2.getWritable() : null;
    if (prevSibling === null) {
      writableParent.__first = nextSiblingKey;
    }
    if (nextSibling2 === null) {
      writableParent.__last = prevSiblingKey;
    }
    if (writablePrevSibling !== null) {
      writablePrevSibling.__next = nextSiblingKey;
    }
    if (writableNextSibling !== null) {
      writableNextSibling.__prev = prevSiblingKey;
    }
    writableNode.__prev = null;
    writableNode.__next = null;
    writableNode.__parent = null;
    writableParent.__size--;
  }
}
function internalMarkNodeAsDirty(node) {
  errorOnInfiniteTransforms();
  const latest = node.getLatest();
  const parent = latest.__parent;
  const editorState = getActiveEditorState();
  const editor = getActiveEditor();
  const nodeMap = editorState._nodeMap;
  const dirtyElements = editor._dirtyElements;
  if (parent !== null) {
    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
  }
  const key2 = latest.__key;
  editor._dirtyType = HAS_DIRTY_NODES;
  if ($isElementNode(node)) {
    dirtyElements.set(key2, true);
  } else {
    editor._dirtyLeaves.add(key2);
  }
}
function internalMarkSiblingsAsDirty(node) {
  const previousNode = node.getPreviousSibling();
  const nextNode = node.getNextSibling();
  if (previousNode !== null) {
    internalMarkNodeAsDirty(previousNode);
  }
  if (nextNode !== null) {
    internalMarkNodeAsDirty(nextNode);
  }
}
function $setCompositionKey(compositionKey) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  const previousCompositionKey = editor._compositionKey;
  if (compositionKey !== previousCompositionKey) {
    editor._compositionKey = compositionKey;
    if (previousCompositionKey !== null) {
      const node = $getNodeByKey(previousCompositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
    if (compositionKey !== null) {
      const node = $getNodeByKey(compositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
  }
}
function $getCompositionKey() {
  if (isCurrentlyReadOnlyMode()) {
    return null;
  }
  const editor = getActiveEditor();
  return editor._compositionKey;
}
function $getNodeByKey(key2, _editorState) {
  const editorState = _editorState || getActiveEditorState();
  const node = editorState._nodeMap.get(key2);
  if (node === void 0) {
    return null;
  }
  return node;
}
function $getNodeFromDOMNode(dom2, editorState) {
  const editor = getActiveEditor();
  const key2 = getNodeKeyFromDOMNode(dom2, editor);
  if (key2 !== void 0) {
    return $getNodeByKey(key2, editorState);
  }
  return null;
}
function setNodeKeyOnDOMNode(dom2, editor, key2) {
  const prop2 = `__lexicalKey_${editor._key}`;
  dom2[prop2] = key2;
}
function getNodeKeyFromDOMNode(dom2, editor) {
  const prop2 = `__lexicalKey_${editor._key}`;
  return dom2[prop2];
}
function $getNearestNodeFromDOMNode(startingDOM, editorState) {
  let dom2 = startingDOM;
  while (dom2 != null) {
    const node = $getNodeFromDOMNode(dom2, editorState);
    if (node !== null) {
      return node;
    }
    dom2 = getParentElement(dom2);
  }
  return null;
}
function cloneDecorators(editor) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = Object.assign({}, currentDecorators);
  editor._pendingDecorators = pendingDecorators;
  return pendingDecorators;
}
function getEditorStateTextContent(editorState) {
  return editorState.read(() => $getRoot().getTextContent());
}
function markNodesWithTypesAsDirty(editor, types) {
  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());
  const dirtyNodeMaps = [];
  for (const type of types) {
    const nodeMap = cachedMap.get(type);
    if (nodeMap) {
      dirtyNodeMaps.push(nodeMap);
    }
  }
  if (dirtyNodeMaps.length === 0) {
    return;
  }
  editor.update(() => {
    for (const nodeMap of dirtyNodeMaps) {
      for (const nodeKey of nodeMap.keys()) {
        const latest = $getNodeByKey(nodeKey);
        if (latest) {
          latest.markDirty();
        }
      }
    }
  }, editor._pendingEditorState === null ? {
    tag: HISTORY_MERGE_TAG
  } : void 0);
}
function $getRoot() {
  return internalGetRoot(getActiveEditorState());
}
function internalGetRoot(editorState) {
  return editorState._nodeMap.get("root");
}
function $setSelection(selection) {
  errorOnReadOnly();
  const editorState = getActiveEditorState();
  if (selection !== null) {
    {
      if (Object.isFrozen(selection)) {
        {
          formatDevErrorMessage(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
        }
      }
    }
    selection.dirty = true;
    selection.setCachedNodes(null);
  }
  editorState._selection = selection;
}
function $flushMutations() {
  errorOnReadOnly();
  const editor = getActiveEditor();
  flushRootMutations(editor);
}
function $getNodeFromDOM(dom2) {
  const editor = getActiveEditor();
  const nodeKey = getNodeKeyFromDOMTree(dom2, editor);
  if (nodeKey === null) {
    const rootElement = editor.getRootElement();
    if (dom2 === rootElement) {
      return $getNodeByKey("root");
    }
    return null;
  }
  return $getNodeByKey(nodeKey);
}
function getTextNodeOffset(node, moveSelectionToEnd) {
  return moveSelectionToEnd ? node.getTextContentSize() : 0;
}
function getNodeKeyFromDOMTree(dom2, editor) {
  let node = dom2;
  while (node != null) {
    const key2 = getNodeKeyFromDOMNode(node, editor);
    if (key2 !== void 0) {
      return key2;
    }
    node = getParentElement(node);
  }
  return null;
}
function doesContainSurrogatePair(str) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
}
function getEditorsToPropagate(editor) {
  const editorsToPropagate = [];
  let currentEditor = editor;
  while (currentEditor !== null) {
    editorsToPropagate.push(currentEditor);
    currentEditor = currentEditor._parentEditor;
  }
  return editorsToPropagate;
}
function createUID() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 5);
}
function getAnchorTextFromDOM(anchorNode) {
  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;
}
function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
  const domSelection = getDOMSelection(getWindow(editor));
  if (domSelection === null) {
    return;
  }
  const anchorNode = domSelection.anchorNode;
  let {
    anchorOffset,
    focusOffset
  } = domSelection;
  if (anchorNode !== null) {
    let textContent2 = getAnchorTextFromDOM(anchorNode);
    const node = $getNearestNodeFromDOMNode(anchorNode);
    if (textContent2 !== null && $isTextNode(node)) {
      if (textContent2 === COMPOSITION_SUFFIX && data) {
        const offset = data.length;
        textContent2 = data;
        anchorOffset = offset;
        focusOffset = offset;
      }
      if (textContent2 !== null) {
        $updateTextNodeFromDOMContent(node, textContent2, anchorOffset, focusOffset, isCompositionEnd);
      }
    }
  }
}
function $updateTextNodeFromDOMContent(textNode, textContent2, anchorOffset, focusOffset, compositionEnd) {
  let node = textNode;
  if (node.isAttached() && (compositionEnd || !node.isDirty())) {
    const isComposing = node.isComposing();
    let normalizedTextContent = textContent2;
    if ((isComposing || compositionEnd) && textContent2[textContent2.length - 1] === COMPOSITION_SUFFIX) {
      normalizedTextContent = textContent2.slice(0, -1);
    }
    const prevTextContent = node.getTextContent();
    if (compositionEnd || normalizedTextContent !== prevTextContent) {
      if (normalizedTextContent === "") {
        $setCompositionKey(null);
        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
          const editor = getActiveEditor();
          setTimeout(() => {
            editor.update(() => {
              if (node.isAttached()) {
                node.remove();
              }
            });
          }, 20);
        } else {
          node.remove();
        }
        return;
      }
      const parent = node.getParent();
      const prevSelection = $getPreviousSelection();
      const prevTextContentSize = node.getTextContentSize();
      const compositionKey = $getCompositionKey();
      const nodeKey = node.getKey();
      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
      // to clear this input from occurring as that action wasn't permitted.
      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {
        node.markDirty();
        return;
      }
      const selection = $getSelection();
      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {
        node.setTextContent(normalizedTextContent);
        return;
      }
      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
      if (node.isSegmented()) {
        const originalTextContent = node.getTextContent();
        const replacement = $createTextNode(originalTextContent);
        node.replace(replacement);
        node = replacement;
      }
      node.setTextContent(normalizedTextContent);
    }
  }
}
function $previousSiblingDoesNotAcceptText(node) {
  const previousSibling2 = node.getPreviousSibling();
  return ($isTextNode(previousSibling2) || $isElementNode(previousSibling2) && previousSibling2.isInline()) && !previousSibling2.canInsertTextAfter();
}
function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
  if (node.isSegmented()) {
    return true;
  }
  if (!selection.isCollapsed()) {
    return false;
  }
  const offset = selection.anchor.offset;
  const parent = node.getParentOrThrow();
  const isToken = $isTokenOrTab(node);
  if (offset === 0) {
    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);
  } else if (offset === node.getTextContentSize()) {
    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;
  } else {
    return false;
  }
}
function matchModifier(event, mask, prop2) {
  const expected = mask[prop2] || false;
  return expected === "any" || expected === event[prop2];
}
function isModifierMatch(event, mask) {
  return matchModifier(event, mask, "altKey") && matchModifier(event, mask, "ctrlKey") && matchModifier(event, mask, "shiftKey") && matchModifier(event, mask, "metaKey");
}
function isExactShortcutMatch(event, expectedKey, mask) {
  return isModifierMatch(event, mask) && event.key.toLowerCase() === expectedKey.toLowerCase();
}
function isTab(event) {
  return isExactShortcutMatch(event, "Tab", {
    shiftKey: "any"
  });
}
function isBold(event) {
  return isExactShortcutMatch(event, "b", CONTROL_OR_META);
}
function isItalic(event) {
  return isExactShortcutMatch(event, "i", CONTROL_OR_META);
}
function isUnderline(event) {
  return isExactShortcutMatch(event, "u", CONTROL_OR_META);
}
function isParagraph(event) {
  return isExactShortcutMatch(event, "Enter", {
    altKey: "any",
    ctrlKey: "any",
    metaKey: "any"
  });
}
function isLineBreak(event) {
  return isExactShortcutMatch(event, "Enter", {
    altKey: "any",
    ctrlKey: "any",
    metaKey: "any",
    shiftKey: true
  });
}
function isOpenLineBreak(event) {
  return IS_APPLE && isExactShortcutMatch(event, "o", {
    ctrlKey: true
  });
}
function isDeleteWordBackward(event) {
  return isExactShortcutMatch(event, "Backspace", CONTROL_OR_ALT);
}
function isDeleteWordForward(event) {
  return isExactShortcutMatch(event, "Delete", CONTROL_OR_ALT);
}
function isDeleteLineBackward(event) {
  return IS_APPLE && isExactShortcutMatch(event, "Backspace", {
    metaKey: true
  });
}
function isDeleteLineForward(event) {
  return IS_APPLE && (isExactShortcutMatch(event, "Delete", {
    metaKey: true
  }) || isExactShortcutMatch(event, "k", {
    ctrlKey: true
  }));
}
function isDeleteBackward(event) {
  return isExactShortcutMatch(event, "Backspace", {
    shiftKey: "any"
  }) || IS_APPLE && isExactShortcutMatch(event, "h", {
    ctrlKey: true
  });
}
function isDeleteForward(event) {
  return isExactShortcutMatch(event, "Delete", {}) || IS_APPLE && isExactShortcutMatch(event, "d", {
    ctrlKey: true
  });
}
function isUndo(event) {
  return isExactShortcutMatch(event, "z", CONTROL_OR_META);
}
function isRedo(event) {
  if (IS_APPLE) {
    return isExactShortcutMatch(event, "z", {
      metaKey: true,
      shiftKey: true
    });
  }
  return isExactShortcutMatch(event, "y", {
    ctrlKey: true
  }) || isExactShortcutMatch(event, "z", {
    ctrlKey: true,
    shiftKey: true
  });
}
function isCopy(event) {
  return isExactShortcutMatch(event, "c", CONTROL_OR_META);
}
function isCut(event) {
  return isExactShortcutMatch(event, "x", CONTROL_OR_META);
}
function isMoveBackward(event) {
  return isExactShortcutMatch(event, "ArrowLeft", {
    shiftKey: "any"
  });
}
function isMoveToStart(event) {
  return isExactShortcutMatch(event, "ArrowLeft", CONTROL_OR_META);
}
function isMoveForward(event) {
  return isExactShortcutMatch(event, "ArrowRight", {
    shiftKey: "any"
  });
}
function isMoveToEnd(event) {
  return isExactShortcutMatch(event, "ArrowRight", CONTROL_OR_META);
}
function isMoveUp(event) {
  return isExactShortcutMatch(event, "ArrowUp", {
    altKey: "any",
    shiftKey: "any"
  });
}
function isMoveDown(event) {
  return isExactShortcutMatch(event, "ArrowDown", {
    altKey: "any",
    shiftKey: "any"
  });
}
function isModifier(event) {
  return event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;
}
function isSpace(event) {
  return event.key === " ";
}
function isBackspace(event) {
  return event.key === "Backspace";
}
function isEscape(event) {
  return event.key === "Escape";
}
function isDelete(event) {
  return event.key === "Delete";
}
function isSelectAll(event) {
  return isExactShortcutMatch(event, "a", CONTROL_OR_META);
}
function $selectAll(selection) {
  const root = $getRoot();
  if ($isRangeSelection(selection)) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const topParent = anchorNode.getTopLevelElementOrThrow();
    const rootNode = topParent.getParentOrThrow();
    anchor.set(rootNode.getKey(), 0, "element");
    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), "element");
    $normalizeSelection(selection);
    return selection;
  } else {
    const newSelection = root.select(0, root.getChildrenSize());
    $setSelection($normalizeSelection(newSelection));
    return newSelection;
  }
}
function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
  if (classNamesTheme.__lexicalClassNameCache === void 0) {
    classNamesTheme.__lexicalClassNameCache = {};
  }
  const classNamesCache = classNamesTheme.__lexicalClassNameCache;
  const cachedClassNames = classNamesCache[classNameThemeType];
  if (cachedClassNames !== void 0) {
    return cachedClassNames;
  }
  const classNames2 = classNamesTheme[classNameThemeType];
  if (typeof classNames2 === "string") {
    const classNamesArr = normalizeClassNames(classNames2);
    classNamesCache[classNameThemeType] = classNamesArr;
    return classNamesArr;
  }
  return classNames2;
}
function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
  if (mutationListeners.size === 0) {
    return;
  }
  const nodeType = node.__type;
  const nodeKey = node.__key;
  const registeredNode = registeredNodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`Type ${nodeType} not in registeredNodes`);
    }
  }
  const klass = registeredNode.klass;
  let mutatedNodesByType = mutatedNodes2.get(klass);
  if (mutatedNodesByType === void 0) {
    mutatedNodesByType = /* @__PURE__ */ new Map();
    mutatedNodes2.set(klass, mutatedNodesByType);
  }
  const prevMutation = mutatedNodesByType.get(nodeKey);
  const isMove = prevMutation === "destroyed" && mutation === "created";
  if (prevMutation === void 0 || isMove) {
    mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
  }
}
function $nodesOfType(klass) {
  const klassType = klass.getType();
  const editorState = getActiveEditorState();
  if (editorState._readOnly) {
    const nodes2 = getCachedTypeToNodeMap(editorState).get(klassType);
    return nodes2 ? Array.from(nodes2.values()) : [];
  }
  const nodes = editorState._nodeMap;
  const nodesOfType = [];
  for (const [, node] of nodes) {
    if (node instanceof klass && node.__type === klassType && node.isAttached()) {
      nodesOfType.push(node);
    }
  }
  return nodesOfType;
}
function resolveElement(element, isBackward, focusOffset) {
  const parent = element.getParent();
  let offset = focusOffset;
  let block = element;
  if (parent !== null) {
    if (isBackward && focusOffset === 0) {
      offset = block.getIndexWithinParent();
      block = parent;
    } else if (!isBackward && focusOffset === block.getChildrenSize()) {
      offset = block.getIndexWithinParent() + 1;
      block = parent;
    }
  }
  return block.getChildAtIndex(isBackward ? offset - 1 : offset);
}
function $getAdjacentNode(focus, isBackward) {
  const focusOffset = focus.offset;
  if (focus.type === "element") {
    const block = focus.getNode();
    return resolveElement(block, isBackward, focusOffset);
  } else {
    const focusNode = focus.getNode();
    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
      if (possibleNode === null) {
        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
      }
      return possibleNode;
    }
  }
  return null;
}
function isFirefoxClipboardEvents(editor) {
  const event = getWindow(editor).event;
  const inputType = event && event.inputType;
  return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
}
function dispatchCommand(editor, command, payload) {
  return triggerCommandListeners(editor, command, payload);
}
function $textContentRequiresDoubleLinebreakAtEnd(node) {
  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
}
function getElementByKeyOrThrow(editor, key2) {
  const element = editor._keyToDOMMap.get(key2);
  if (element === void 0) {
    {
      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key2}`);
    }
  }
  return element;
}
function getParentElement(node) {
  const parentElement2 = node.assignedSlot || node.parentElement;
  return isDocumentFragment(parentElement2) ? parentElement2.host : parentElement2;
}
function getDOMOwnerDocument(target) {
  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;
}
function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
  const doc = getDOMOwnerDocument(rootElement);
  const defaultView = getDefaultView(doc);
  if (doc === null || defaultView === null) {
    return;
  }
  let {
    top: currentTop,
    bottom: currentBottom
  } = selectionRect;
  let targetTop = 0;
  let targetBottom = 0;
  let element = rootElement;
  while (element !== null) {
    const isBodyElement = element === doc.body;
    if (isBodyElement) {
      targetTop = 0;
      targetBottom = getWindow(editor).innerHeight;
    } else {
      const targetRect = element.getBoundingClientRect();
      targetTop = targetRect.top;
      targetBottom = targetRect.bottom;
    }
    let diff = 0;
    if (currentTop < targetTop) {
      diff = -(targetTop - currentTop);
    } else if (currentBottom > targetBottom) {
      diff = currentBottom - targetBottom;
    }
    if (diff !== 0) {
      if (isBodyElement) {
        defaultView.scrollBy(0, diff);
      } else {
        const scrollTop = element.scrollTop;
        element.scrollTop += diff;
        const yOffset = element.scrollTop - scrollTop;
        currentTop -= yOffset;
        currentBottom -= yOffset;
      }
    }
    if (isBodyElement) {
      break;
    }
    element = getParentElement(element);
  }
}
function $hasUpdateTag(tag) {
  const editor = getActiveEditor();
  return editor._updateTags.has(tag);
}
function $addUpdateTag(tag) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._updateTags.add(tag);
}
function $onUpdate(updateFn) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._deferred.push(updateFn);
}
function $maybeMoveChildrenSelectionToParent(parentNode) {
  const selection = $getSelection();
  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {
    return selection;
  }
  const {
    anchor,
    focus
  } = selection;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if ($hasAncestor(anchorNode, parentNode)) {
    anchor.set(parentNode.__key, 0, "element");
  }
  if ($hasAncestor(focusNode, parentNode)) {
    focus.set(parentNode.__key, 0, "element");
  }
  return selection;
}
function $hasAncestor(child, targetNode) {
  let parent = child.getParent();
  while (parent !== null) {
    if (parent.is(targetNode)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}
function getDefaultView(domElem) {
  const ownerDoc = getDOMOwnerDocument(domElem);
  return ownerDoc ? ownerDoc.defaultView : null;
}
function getWindow(editor) {
  const windowObj = editor._window;
  if (windowObj === null) {
    {
      formatDevErrorMessage(`window object not found`);
    }
  }
  return windowObj;
}
function $isInlineElementOrDecoratorNode(node) {
  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
}
function $getNearestRootOrShadowRoot(node) {
  let parent = node.getParentOrThrow();
  while (parent !== null) {
    if ($isRootOrShadowRoot(parent)) {
      return parent;
    }
    parent = parent.getParentOrThrow();
  }
  return parent;
}
function $isRootOrShadowRoot(node) {
  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
}
function $copyNode(node) {
  const copy = node.constructor.clone(node);
  $setNodeKey(copy, null);
  return copy;
}
function $applyNodeReplacement(node) {
  const editor = getActiveEditor();
  const nodeType = node.constructor.getType();
  const registeredNode = editor._nodes.get(nodeType);
  if (!(registeredNode !== void 0)) {
    formatDevErrorMessage(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
  }
  const {
    replace: replace2,
    replaceWithKlass
  } = registeredNode;
  if (replace2 !== null) {
    const replacementNode = replace2(node);
    const replacementNodeKlass = replacementNode.constructor;
    if (replaceWithKlass !== null) {
      if (!(replacementNode instanceof replaceWithKlass)) {
        formatDevErrorMessage(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);
      }
    } else {
      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {
        formatDevErrorMessage(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);
      }
    }
    if (!(replacementNode.__key !== node.__key)) {
      formatDevErrorMessage(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);
    }
    return replacementNode;
  }
  return node;
}
function errorOnInsertTextNodeOnRoot(node, insertNode) {
  const parentNode = node.getParent();
  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
    {
      formatDevErrorMessage(`Only element or decorator nodes can be inserted in to the root node`);
    }
  }
}
function $getNodeByKeyOrThrow(key2) {
  const node = $getNodeByKey(key2);
  if (node === null) {
    {
      formatDevErrorMessage(`Expected node with key ${key2} to exist but it's not in the nodeMap.`);
    }
  }
  return node;
}
function createBlockCursorElement(editorConfig) {
  const theme = editorConfig.theme;
  const element = document.createElement("div");
  element.contentEditable = "false";
  element.setAttribute("data-lexical-cursor", "true");
  let blockCursorTheme = theme.blockCursor;
  if (blockCursorTheme !== void 0) {
    if (typeof blockCursorTheme === "string") {
      const classNamesArr = normalizeClassNames(blockCursorTheme);
      blockCursorTheme = theme.blockCursor = classNamesArr;
    }
    if (blockCursorTheme !== void 0) {
      element.classList.add(...blockCursorTheme);
    }
  }
  return element;
}
function needsBlockCursor(node) {
  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
}
function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
  rootElement.style.removeProperty("caret-color");
  editor._blockCursorElement = null;
  const parentElement2 = blockCursorElement.parentElement;
  if (parentElement2 !== null) {
    parentElement2.removeChild(blockCursorElement);
  }
}
function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
  let blockCursorElement = editor._blockCursorElement;
  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
    const anchor = nextSelection.anchor;
    const elementNode = anchor.getNode();
    const offset = anchor.offset;
    const elementNodeSize = elementNode.getChildrenSize();
    let isBlockCursor = false;
    let insertBeforeElement = null;
    if (offset === elementNodeSize) {
      const child = elementNode.getChildAtIndex(offset - 1);
      if (needsBlockCursor(child)) {
        isBlockCursor = true;
      }
    } else {
      const child = elementNode.getChildAtIndex(offset);
      if (child !== null && needsBlockCursor(child)) {
        const sibling = child.getPreviousSibling();
        if (sibling === null || needsBlockCursor(sibling)) {
          isBlockCursor = true;
          insertBeforeElement = editor.getElementByKey(child.__key);
        }
      }
    }
    if (isBlockCursor) {
      const elementDOM = editor.getElementByKey(elementNode.__key);
      if (blockCursorElement === null) {
        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
      }
      rootElement.style.caretColor = "transparent";
      if (insertBeforeElement === null) {
        elementDOM.appendChild(blockCursorElement);
      } else {
        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
      }
      return;
    }
  }
  if (blockCursorElement !== null) {
    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
  }
}
function getDOMSelection(targetWindow) {
  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
}
function getDOMSelectionFromTarget(eventTarget) {
  const defaultView = getDefaultView(eventTarget);
  return defaultView ? defaultView.getSelection() : null;
}
function $splitNode(node, offset) {
  let startNode = node.getChildAtIndex(offset);
  if (startNode == null) {
    startNode = node;
  }
  if (!!$isRootOrShadowRoot(node)) {
    formatDevErrorMessage(`Can not call $splitNode() on root element`);
  }
  const recurse = (currentNode) => {
    const parent = currentNode.getParentOrThrow();
    const isParentRoot = $isRootOrShadowRoot(parent);
    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
    if (isParentRoot) {
      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {
        formatDevErrorMessage(`Children of a root must be ElementNode`);
      }
      currentNode.insertAfter(nodeToMove);
      return [currentNode, nodeToMove, nodeToMove];
    } else {
      const [leftTree2, rightTree2, newParent] = recurse(parent);
      const nextSiblings = currentNode.getNextSiblings();
      newParent.append(nodeToMove, ...nextSiblings);
      return [leftTree2, rightTree2, nodeToMove];
    }
  };
  const [leftTree, rightTree] = recurse(startNode);
  return [leftTree, rightTree];
}
function $findMatchingParent(startingNode, findFn) {
  let curr = startingNode;
  while (curr !== $getRoot() && curr != null) {
    if (findFn(curr)) {
      return curr;
    }
    curr = curr.getParent();
  }
  return null;
}
function isHTMLAnchorElement(x4) {
  return isHTMLElement(x4) && x4.tagName === "A";
}
function isHTMLElement(x4) {
  return isDOMNode(x4) && x4.nodeType === DOM_ELEMENT_TYPE;
}
function isDOMNode(x4) {
  return typeof x4 === "object" && x4 !== null && "nodeType" in x4 && typeof x4.nodeType === "number";
}
function isDocumentFragment(x4) {
  return isDOMNode(x4) && x4.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;
}
function isInlineDomNode(node) {
  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return node.nodeName.match(inlineNodes) !== null;
}
function isBlockDomNode(node) {
  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return node.nodeName.match(blockNodes) !== null;
}
function INTERNAL_$isBlock(node) {
  if ($isDecoratorNode(node) && !node.isInline()) {
    return true;
  }
  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {
    return false;
  }
  const firstChild = node.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
}
function $getAncestor(node, predicate) {
  let parent = node;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
function $getEditor() {
  return getActiveEditor();
}
function getCachedTypeToNodeMap(editorState) {
  if (!editorState._readOnly && editorState.isEmpty()) {
    return EMPTY_TYPE_TO_NODE_MAP;
  }
  if (!editorState._readOnly) {
    formatDevErrorMessage(`getCachedTypeToNodeMap called with a writable EditorState`);
  }
  let typeToNodeMap = cachedNodeMaps.get(editorState);
  if (!typeToNodeMap) {
    typeToNodeMap = computeTypeToNodeMap(editorState);
    cachedNodeMaps.set(editorState, typeToNodeMap);
  }
  return typeToNodeMap;
}
function computeTypeToNodeMap(editorState) {
  const typeToNodeMap = /* @__PURE__ */ new Map();
  for (const [nodeKey, node] of editorState._nodeMap) {
    const nodeType = node.__type;
    let nodeMap = typeToNodeMap.get(nodeType);
    if (!nodeMap) {
      nodeMap = /* @__PURE__ */ new Map();
      typeToNodeMap.set(nodeType, nodeMap);
    }
    nodeMap.set(nodeKey, node);
  }
  return typeToNodeMap;
}
function $cloneWithProperties(latestNode) {
  const constructor = latestNode.constructor;
  const mutableNode = constructor.clone(latestNode);
  mutableNode.afterCloneFrom(latestNode);
  {
    if (!(mutableNode.__key === latestNode.__key)) {
      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);
    }
    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {
      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrode afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);
    }
  }
  return mutableNode;
}
function setNodeIndentFromDOM(elementDom, elementNode) {
  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;
  const indent = Math.round(indentSize / 40);
  elementNode.setIndent(indent);
}
function setDOMUnmanaged(elementDom) {
  const el2 = elementDom;
  el2.__lexicalUnmanaged = true;
}
function isDOMUnmanaged(elementDom) {
  const el2 = elementDom;
  return el2.__lexicalUnmanaged === true;
}
function flipDirection(direction) {
  return FLIP_DIRECTION[direction];
}
function $filterByMode(node, mode = "root") {
  return MODE_PREDICATE[mode](node) ? null : node;
}
function $isTextPointCaret(caret) {
  return caret instanceof AbstractTextPointCaret;
}
function $isNodeCaret(caret) {
  return caret instanceof AbstractCaret;
}
function $isSiblingCaret(caret) {
  return caret instanceof AbstractSiblingCaret;
}
function $isChildCaret(caret) {
  return caret instanceof AbstractChildCaret;
}
function $getSiblingCaret(origin, direction) {
  return origin ? new SIBLING_CTOR[direction](origin) : null;
}
function $getTextPointCaret(origin, direction, offset) {
  return origin ? new TEXT_CTOR[direction](origin, $getTextNodeOffset(origin, offset)) : null;
}
function $getTextNodeOffset(origin, offset) {
  const size = origin.getTextContentSize();
  let numericOffset = offset === "next" ? size : offset === "previous" ? 0 : offset;
  if (numericOffset < 0 || numericOffset > size) {
    {
      formatDevErrorMessage(`$getTextNodeOffset: invalid offset ${String(offset)} for size ${String(size)} at key ${origin.getKey()}`);
    }
    numericOffset = numericOffset < 0 ? 0 : size;
  }
  return numericOffset;
}
function $getTextPointCaretSlice(caret, distance) {
  return new TextPointCaretSliceImpl(caret, distance);
}
function $getChildCaret(origin, direction) {
  return $isElementNode(origin) ? new CHILD_CTOR[direction](origin) : null;
}
function $getChildCaretOrSelf(caret) {
  return caret && caret.getChildCaret() || caret;
}
function $getAdjacentChildCaret(caret) {
  return caret && $getChildCaretOrSelf(caret.getAdjacentCaret());
}
function $getSliceFromTextPointCaret(caret, anchorOrFocus) {
  const {
    direction,
    origin
  } = caret;
  const offsetB = $getTextNodeOffset(origin, anchorOrFocus === "focus" ? flipDirection(direction) : direction);
  return $getTextPointCaretSlice(caret, offsetB - caret.offset);
}
function $isTextPointCaretSlice(caretOrSlice) {
  return caretOrSlice instanceof TextPointCaretSliceImpl;
}
function $extendCaretToRange(anchor) {
  return $getCaretRange(anchor, $getSiblingCaret($getRoot(), anchor.direction));
}
function $getCollapsedCaretRange(anchor) {
  return $getCaretRange(anchor, anchor);
}
function $getCaretRange(anchor, focus) {
  if (!(anchor.direction === focus.direction)) {
    formatDevErrorMessage(`$getCaretRange: anchor and focus must be in the same direction`);
  }
  return new CaretRangeImpl(anchor, focus, anchor.direction);
}
function makeStepwiseIterator(config) {
  const {
    initial,
    hasNext,
    step,
    map
  } = config;
  let state = initial;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (!hasNext(state)) {
        return {
          done: true,
          value: void 0
        };
      }
      const rval = {
        done: false,
        value: map(state)
      };
      state = step(state);
      return rval;
    }
  };
}
function compareNumber(a2, b3) {
  return Math.sign(a2 - b3);
}
function $comparePointCaretNext(a2, b3) {
  const compare = $getCommonAncestor(a2.origin, b3.origin);
  if (!(compare !== null)) {
    formatDevErrorMessage(`$comparePointCaretNext: a (key ${a2.origin.getKey()}) and b (key ${b3.origin.getKey()}) do not have a common ancestor`);
  }
  switch (compare.type) {
    case "same": {
      const aIsText = a2.type === "text";
      const bIsText = b3.type === "text";
      return aIsText && bIsText ? compareNumber(a2.offset, b3.offset) : a2.type === b3.type ? 0 : aIsText ? -1 : bIsText ? 1 : a2.type === "child" ? -1 : 1;
    }
    case "ancestor": {
      return a2.type === "child" ? -1 : 1;
    }
    case "descendant": {
      return b3.type === "child" ? 1 : -1;
    }
    case "branch": {
      return $getCommonAncestorResultBranchOrder(compare);
    }
  }
}
function $getCommonAncestorResultBranchOrder(compare) {
  const {
    a: a2,
    b: b3
  } = compare;
  const aKey = a2.__key;
  const bKey = b3.__key;
  let na = a2;
  let nb = b3;
  for (; na && nb; na = na.getNextSibling(), nb = nb.getNextSibling()) {
    if (na.__key === bKey) {
      return -1;
    } else if (nb.__key === aKey) {
      return 1;
    }
  }
  return na === null ? 1 : -1;
}
function $isSameNode(reference, other) {
  return other.is(reference);
}
function $initialElementTuple(node) {
  return $isElementNode(node) ? [node.getLatest(), null] : [node.getParent(), node.getLatest()];
}
function $getCommonAncestor(a2, b3) {
  if (a2.is(b3)) {
    return {
      commonAncestor: a2,
      type: "same"
    };
  }
  const aMap = /* @__PURE__ */ new Map();
  for (let [parent, child] = $initialElementTuple(a2); parent; child = parent, parent = parent.getParent()) {
    aMap.set(parent, child);
  }
  for (let [parent, child] = $initialElementTuple(b3); parent; child = parent, parent = parent.getParent()) {
    const aChild = aMap.get(parent);
    if (aChild === void 0) ;
    else if (aChild === null) {
      if (!$isSameNode(a2, parent)) {
        formatDevErrorMessage(`$originComparison: ancestor logic error`);
      }
      return {
        commonAncestor: parent,
        type: "ancestor"
      };
    } else if (child === null) {
      if (!$isSameNode(b3, parent)) {
        formatDevErrorMessage(`$originComparison: descendant logic error`);
      }
      return {
        commonAncestor: parent,
        type: "descendant"
      };
    } else {
      if (!(($isElementNode(aChild) || $isSameNode(a2, aChild)) && ($isElementNode(child) || $isSameNode(b3, child)) && parent.is(aChild.getParent()) && parent.is(child.getParent()))) {
        formatDevErrorMessage(`$originComparison: branch logic error`);
      }
      return {
        a: aChild,
        b: child,
        commonAncestor: parent,
        type: "branch"
      };
    }
  }
  return null;
}
function $caretFromPoint(point, direction) {
  const {
    type,
    key: key2,
    offset
  } = point;
  const node = $getNodeByKeyOrThrow(point.key);
  if (type === "text") {
    if (!$isTextNode(node)) {
      formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key2} that does not inherit from TextNode encountered for text point`);
    }
    return $getTextPointCaret(node, direction, offset);
  }
  if (!$isElementNode(node)) {
    formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key2} that does not inherit from ElementNode encountered for element point`);
  }
  return $getChildCaretAtIndex(node, point.offset, direction);
}
function $setPointFromCaret(point, caret) {
  const {
    origin,
    direction
  } = caret;
  const isNext = direction === "next";
  if ($isTextPointCaret(caret)) {
    point.set(origin.getKey(), caret.offset, "text");
  } else if ($isSiblingCaret(caret)) {
    if ($isTextNode(origin)) {
      point.set(origin.getKey(), $getTextNodeOffset(origin, direction), "text");
    } else {
      point.set(origin.getParentOrThrow().getKey(), origin.getIndexWithinParent() + (isNext ? 1 : 0), "element");
    }
  } else {
    if (!($isChildCaret(caret) && $isElementNode(origin))) {
      formatDevErrorMessage(`$setPointFromCaret: exhaustiveness check`);
    }
    point.set(origin.getKey(), isNext ? 0 : origin.getChildrenSize(), "element");
  }
}
function $setSelectionFromCaretRange(caretRange) {
  const currentSelection = $getSelection();
  const selection = $isRangeSelection(currentSelection) ? currentSelection : $createRangeSelection();
  $updateRangeSelectionFromCaretRange(selection, caretRange);
  $setSelection(selection);
  return selection;
}
function $updateRangeSelectionFromCaretRange(selection, caretRange) {
  $setPointFromCaret(selection.anchor, caretRange.anchor);
  $setPointFromCaret(selection.focus, caretRange.focus);
}
function $caretRangeFromSelection(selection) {
  const {
    anchor,
    focus
  } = selection;
  const anchorCaret = $caretFromPoint(anchor, "next");
  const focusCaret = $caretFromPoint(focus, "next");
  const direction = $comparePointCaretNext(anchorCaret, focusCaret) <= 0 ? "next" : "previous";
  return $getCaretRange($getCaretInDirection(anchorCaret, direction), $getCaretInDirection(focusCaret, direction));
}
function $rewindSiblingCaret(caret) {
  const {
    direction,
    origin
  } = caret;
  const rewindOrigin = $getSiblingCaret(origin, flipDirection(direction)).getNodeAtCaret();
  return rewindOrigin ? $getSiblingCaret(rewindOrigin, direction) : $getChildCaret(origin.getParentOrThrow(), direction);
}
function $getAnchorCandidates(anchor, rootMode = "root") {
  const carets = [anchor];
  for (let parent = $isChildCaret(anchor) ? anchor.getParentCaret(rootMode) : anchor.getSiblingCaret(); parent !== null; parent = parent.getParentCaret(rootMode)) {
    carets.push($rewindSiblingCaret(parent));
  }
  return carets;
}
function $isCaretAttached(caret) {
  return !!caret && caret.origin.isAttached();
}
function $removeTextFromCaretRange(initialRange, sliceMode = "removeEmptySlices") {
  if (initialRange.isCollapsed()) {
    return initialRange;
  }
  const rootMode = "root";
  const nextDirection = "next";
  let sliceState = sliceMode;
  const range = $getCaretRangeInDirection(initialRange, nextDirection);
  const anchorCandidates = $getAnchorCandidates(range.anchor, rootMode);
  const focusCandidates = $getAnchorCandidates(range.focus.getFlipped(), rootMode);
  const seenStart = /* @__PURE__ */ new Set();
  const removedNodes = [];
  for (const caret of range.iterNodeCarets(rootMode)) {
    if ($isChildCaret(caret)) {
      seenStart.add(caret.origin.getKey());
    } else if ($isSiblingCaret(caret)) {
      const {
        origin
      } = caret;
      if (!$isElementNode(origin) || seenStart.has(origin.getKey())) {
        removedNodes.push(origin);
      }
    }
  }
  for (const node of removedNodes) {
    node.remove();
  }
  for (const slice of range.getTextSlices()) {
    if (!slice) {
      continue;
    }
    const {
      origin
    } = slice.caret;
    const contentSize = origin.getTextContentSize();
    const caretBefore = $rewindSiblingCaret($getSiblingCaret(origin, nextDirection));
    const mode = origin.getMode();
    if (Math.abs(slice.distance) === contentSize && sliceState === "removeEmptySlices" || mode === "token" && slice.distance !== 0) {
      caretBefore.remove();
    } else if (slice.distance !== 0) {
      sliceState = "removeEmptySlices";
      let nextCaret = slice.removeTextSlice();
      const sliceOrigin = slice.caret.origin;
      if (mode === "segmented") {
        const src = nextCaret.origin;
        const plainTextNode = $createTextNode(src.getTextContent()).setStyle(src.getStyle()).setFormat(src.getFormat());
        caretBefore.replaceOrInsert(plainTextNode);
        nextCaret = $getTextPointCaret(plainTextNode, nextDirection, nextCaret.offset);
      }
      if (sliceOrigin.is(anchorCandidates[0].origin)) {
        anchorCandidates[0] = nextCaret;
      }
      if (sliceOrigin.is(focusCandidates[0].origin)) {
        focusCandidates[0] = nextCaret.getFlipped();
      }
    }
  }
  let anchorCandidate;
  let focusCandidate;
  for (const candidate of anchorCandidates) {
    if ($isCaretAttached(candidate)) {
      anchorCandidate = $normalizeCaret(candidate);
      break;
    }
  }
  for (const candidate of focusCandidates) {
    if ($isCaretAttached(candidate)) {
      focusCandidate = $normalizeCaret(candidate);
      break;
    }
  }
  const mergeTargets = $getBlockMergeTargets(anchorCandidate, focusCandidate, seenStart);
  if (mergeTargets) {
    const [anchorBlock, focusBlock] = mergeTargets;
    $getChildCaret(anchorBlock, "previous").splice(0, focusBlock.getChildren());
    focusBlock.remove();
  }
  const bestCandidate = [anchorCandidate, focusCandidate, ...anchorCandidates, ...focusCandidates].find($isCaretAttached);
  if (bestCandidate) {
    const anchor = $getCaretInDirection($normalizeCaret(bestCandidate), initialRange.direction);
    return $getCollapsedCaretRange(anchor);
  }
  {
    formatDevErrorMessage(`$removeTextFromCaretRange: selection was lost, could not find a new anchor given candidates with keys: ${JSON.stringify(anchorCandidates.map((n2) => n2.origin.__key))}`);
  }
}
function $getBlockMergeTargets(anchor, focus, seenStart) {
  if (!anchor || !focus) {
    return null;
  }
  const anchorParent = anchor.getParentAtCaret();
  const focusParent = focus.getParentAtCaret();
  if (!anchorParent || !focusParent) {
    return null;
  }
  const anchorElements = anchorParent.getParents().reverse();
  anchorElements.push(anchorParent);
  const focusElements = focusParent.getParents().reverse();
  focusElements.push(focusParent);
  const maxLen = Math.min(anchorElements.length, focusElements.length);
  let commonAncestorCount;
  for (commonAncestorCount = 0; commonAncestorCount < maxLen && anchorElements[commonAncestorCount] === focusElements[commonAncestorCount]; commonAncestorCount++) {
  }
  const $getBlock = (arr, predicate) => {
    let block;
    for (let i2 = commonAncestorCount; i2 < arr.length; i2++) {
      const ancestor = arr[i2];
      if ($isRootOrShadowRoot(ancestor)) {
        return;
      } else if (!block && predicate(ancestor)) {
        block = ancestor;
      }
    }
    return block;
  };
  const anchorBlock = $getBlock(anchorElements, INTERNAL_$isBlock);
  const focusBlock = anchorBlock && $getBlock(focusElements, (node) => seenStart.has(node.getKey()) && INTERNAL_$isBlock(node));
  return anchorBlock && focusBlock ? [anchorBlock, focusBlock] : null;
}
function $getDeepestChildOrSelf(initialCaret) {
  let caret = initialCaret;
  while ($isChildCaret(caret)) {
    const adjacent = $getAdjacentChildCaret(caret);
    if (!$isChildCaret(adjacent)) {
      break;
    }
    caret = adjacent;
  }
  return caret;
}
function $normalizeCaret(initialCaret) {
  const caret = $getDeepestChildOrSelf(initialCaret.getLatest());
  const {
    direction
  } = caret;
  if ($isTextNode(caret.origin)) {
    return $isTextPointCaret(caret) ? caret : $getTextPointCaret(caret.origin, direction, direction);
  }
  const adj = caret.getAdjacentCaret();
  return $isSiblingCaret(adj) && $isTextNode(adj.origin) ? $getTextPointCaret(adj.origin, direction, flipDirection(direction)) : caret;
}
function $isExtendableTextPointCaret(caret) {
  return $isTextPointCaret(caret) && caret.offset !== $getTextNodeOffset(caret.origin, caret.direction);
}
function $getCaretInDirection(caret, direction) {
  return caret.direction === direction ? caret : caret.getFlipped();
}
function $getCaretRangeInDirection(range, direction) {
  if (range.direction === direction) {
    return range;
  }
  return $getCaretRange(
    // focus and anchor get flipped here
    $getCaretInDirection(range.focus, direction),
    $getCaretInDirection(range.anchor, direction)
  );
}
function $getChildCaretAtIndex(parent, index, direction) {
  let caret = $getChildCaret(parent, "next");
  for (let i2 = 0; i2 < index; i2++) {
    const nextCaret = caret.getAdjacentCaret();
    if (nextCaret === null) {
      break;
    }
    caret = nextCaret;
  }
  return $getCaretInDirection(caret, direction);
}
function $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = "root") {
  let depthDiff = 0;
  let caret = startCaret;
  let nextCaret = $getAdjacentChildCaret(caret);
  while (nextCaret === null) {
    depthDiff--;
    nextCaret = caret.getParentCaret(rootMode);
    if (!nextCaret) {
      return null;
    }
    caret = nextCaret;
    nextCaret = $getAdjacentChildCaret(caret);
  }
  return nextCaret && [nextCaret, depthDiff];
}
function $getAdjacentNodes(initialCaret) {
  const siblings = [];
  for (let caret = initialCaret.getAdjacentCaret(); caret; caret = caret.getAdjacentCaret()) {
    siblings.push(caret.origin);
  }
  return siblings;
}
function $splitTextPointCaret(textPointCaret) {
  const {
    origin,
    offset,
    direction
  } = textPointCaret;
  if (offset === $getTextNodeOffset(origin, direction)) {
    return textPointCaret.getSiblingCaret();
  } else if (offset === $getTextNodeOffset(origin, flipDirection(direction))) {
    return $rewindSiblingCaret(textPointCaret.getSiblingCaret());
  }
  const [textNode] = origin.splitText(offset);
  if (!$isTextNode(textNode)) {
    formatDevErrorMessage(`$splitTextPointCaret: splitText must return at least one TextNode`);
  }
  return $getCaretInDirection($getSiblingCaret(textNode, "next"), direction);
}
function $alwaysSplit(_node, _edge) {
  return true;
}
function $splitAtPointCaretNext(pointCaret, {
  $copyElementNode = $copyNode,
  $splitTextPointCaretNext = $splitTextPointCaret,
  rootMode = "shadowRoot",
  $shouldSplit = $alwaysSplit
} = {}) {
  if ($isTextPointCaret(pointCaret)) {
    return $splitTextPointCaretNext(pointCaret);
  }
  const parentCaret = pointCaret.getParentCaret(rootMode);
  if (parentCaret) {
    const {
      origin
    } = parentCaret;
    if ($isChildCaret(pointCaret) && !(origin.canBeEmpty() && $shouldSplit(origin, "first"))) {
      return $rewindSiblingCaret(parentCaret);
    }
    const siblings = $getAdjacentNodes(pointCaret);
    if (siblings.length > 0 || origin.canBeEmpty() && $shouldSplit(origin, "last")) {
      parentCaret.insert($copyElementNode(origin).splice(0, 0, siblings));
    }
  }
  return parentCaret;
}
var CAN_USE_DOM, documentMode, IS_APPLE, IS_FIREFOX, CAN_USE_BEFORE_INPUT, IS_SAFARI, IS_IOS, IS_ANDROID, IS_CHROME, IS_ANDROID_CHROME, IS_APPLE_WEBKIT, DOM_ELEMENT_TYPE, DOM_TEXT_TYPE, DOM_DOCUMENT_TYPE, DOM_DOCUMENT_FRAGMENT_TYPE, NO_DIRTY_NODES, HAS_DIRTY_NODES, FULL_RECONCILE, IS_NORMAL, IS_TOKEN, IS_SEGMENTED, IS_BOLD, IS_ITALIC, IS_STRIKETHROUGH, IS_UNDERLINE, IS_CODE, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_HIGHLIGHT, IS_LOWERCASE, IS_UPPERCASE, IS_CAPITALIZE, IS_ALL_FORMATTING, IS_DIRECTIONLESS, IS_UNMERGEABLE, IS_ALIGN_LEFT, IS_ALIGN_CENTER, IS_ALIGN_RIGHT, IS_ALIGN_JUSTIFY, IS_ALIGN_START, IS_ALIGN_END, NON_BREAKING_SPACE, ZERO_WIDTH_SPACE, COMPOSITION_SUFFIX, DOUBLE_LINE_BREAK, COMPOSITION_START_CHAR, RTL, LTR, RTL_REGEX, LTR_REGEX, TEXT_TYPE_TO_FORMAT, DETAIL_TYPE_TO_DETAIL, ELEMENT_TYPE_TO_FORMAT, ELEMENT_FORMAT_TO_TYPE, TEXT_MODE_TO_TYPE, TEXT_TYPE_TO_MODE, NODE_STATE_KEY, TEXT_MUTATION_VARIANCE, isProcessingMutations, lastTextEntryTimeStamp, StateConfig, NodeState, subTreeTextContent, subTreeDirectionedTextContent, subTreeTextFormat, subTreeTextStyle, editorTextContent, activeEditorConfig, activeEditor$1, activeEditorNodes, treatAllNodesAsDirty, activeEditorStateReadOnly, activeMutationListeners, activeTextDirection, activeDirtyElements, activeDirtyLeaves, activePrevNodeMap, activeNextNodeMap, activePrevKeyToDOMMap, mutatedNodes, DEFAULT_INDENT_VALUE, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, CLICK_COMMAND, DELETE_CHARACTER_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, PASTE_COMMAND, REMOVE_TEXT_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, FORMAT_TEXT_COMMAND, UNDO_COMMAND, REDO_COMMAND, KEY_DOWN_COMMAND, KEY_ARROW_RIGHT_COMMAND, MOVE_TO_END, KEY_ARROW_LEFT_COMMAND, MOVE_TO_START, KEY_ARROW_UP_COMMAND, KEY_ARROW_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_SPACE_COMMAND, KEY_BACKSPACE_COMMAND, KEY_ESCAPE_COMMAND, KEY_DELETE_COMMAND, KEY_TAB_COMMAND, INSERT_TAB_COMMAND, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, DROP_COMMAND, FORMAT_ELEMENT_COMMAND, DRAGSTART_COMMAND, DRAGOVER_COMMAND, DRAGEND_COMMAND, COPY_COMMAND, CUT_COMMAND, SELECT_ALL_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, FOCUS_COMMAND, BLUR_COMMAND, KEY_MODIFIER_COMMAND, PASS_THROUGH_COMMAND, ANDROID_COMPOSITION_LATENCY, rootElementEvents, lastKeyDownTimeStamp, lastKeyCode, lastBeforeInputInsertTextTimeStamp, unprocessedBeforeInputData, rootElementsRegistered, isSelectionChangeFromDOMUpdate, isSelectionChangeFromMouseDown, isInsertLineBreak, isFirefoxEndingComposition, isSafariEndingComposition, safariEndCompositionEventData, postDeleteSelectionToRestore, collapsedSelectionFormat, activeNestedEditorsMap, rootElementNotRegisteredWarning, LexicalNode, LineBreakNode, TextNode, preParentCache, nodeNameToTextFormat, TabNode, Point, NodeSelection, RangeSelection, doesContainEmoji, activeEditorState, activeEditor, isReadOnlyMode, isAttemptingToRecoverFromReconcilerError, infiniteTransformCount, observerOptions, ElementDOMSlot, ElementNode, DecoratorNode, RootNode, EditorState, HISTORIC_TAG, HISTORY_PUSH_TAG, HISTORY_MERGE_TAG, PASTE_TAG, COLLABORATION_TAG, SKIP_COLLAB_TAG, SKIP_SCROLL_INTO_VIEW_TAG, SKIP_DOM_SELECTION_TAG, FOCUS_TAG, ArtificialNode__DO_NOT_USE, ParagraphNode, DEFAULT_SKIP_INITIALIZATION, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_CRITICAL, LexicalEditor, keyCounter, scheduleMicroTask, CONTROL_OR_META, CONTROL_OR_ALT, cachedNodeMaps, EMPTY_TYPE_TO_NODE_MAP, FLIP_DIRECTION, AbstractCaret, AbstractChildCaret, ChildCaretFirst, ChildCaretLast, MODE_PREDICATE, AbstractSiblingCaret, AbstractTextPointCaret, SiblingCaretNext, SiblingCaretPrevious, TextPointCaretNext, TextPointCaretPrevious, TEXT_CTOR, SIBLING_CTOR, CHILD_CTOR, CaretRangeImpl, TextPointCaretSliceImpl;
var init_Lexical_dev = __esm({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/lexical@0.32.1/node_modules/lexical/Lexical.dev.mjs"() {
    CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
    IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);
    IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;
    IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    DOM_ELEMENT_TYPE = 1;
    DOM_TEXT_TYPE = 3;
    DOM_DOCUMENT_TYPE = 9;
    DOM_DOCUMENT_FRAGMENT_TYPE = 11;
    NO_DIRTY_NODES = 0;
    HAS_DIRTY_NODES = 1;
    FULL_RECONCILE = 2;
    IS_NORMAL = 0;
    IS_TOKEN = 1;
    IS_SEGMENTED = 2;
    IS_BOLD = 1;
    IS_ITALIC = 1 << 1;
    IS_STRIKETHROUGH = 1 << 2;
    IS_UNDERLINE = 1 << 3;
    IS_CODE = 1 << 4;
    IS_SUBSCRIPT = 1 << 5;
    IS_SUPERSCRIPT = 1 << 6;
    IS_HIGHLIGHT = 1 << 7;
    IS_LOWERCASE = 1 << 8;
    IS_UPPERCASE = 1 << 9;
    IS_CAPITALIZE = 1 << 10;
    IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;
    IS_DIRECTIONLESS = 1;
    IS_UNMERGEABLE = 1 << 1;
    IS_ALIGN_LEFT = 1;
    IS_ALIGN_CENTER = 2;
    IS_ALIGN_RIGHT = 3;
    IS_ALIGN_JUSTIFY = 4;
    IS_ALIGN_START = 5;
    IS_ALIGN_END = 6;
    NON_BREAKING_SPACE = "\xA0";
    ZERO_WIDTH_SPACE = "\u200B";
    COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
    DOUBLE_LINE_BREAK = "\n\n";
    COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
    RTL = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
    LTR = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
    RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    TEXT_TYPE_TO_FORMAT = {
      bold: IS_BOLD,
      capitalize: IS_CAPITALIZE,
      code: IS_CODE,
      highlight: IS_HIGHLIGHT,
      italic: IS_ITALIC,
      lowercase: IS_LOWERCASE,
      strikethrough: IS_STRIKETHROUGH,
      subscript: IS_SUBSCRIPT,
      superscript: IS_SUPERSCRIPT,
      underline: IS_UNDERLINE,
      uppercase: IS_UPPERCASE
    };
    DETAIL_TYPE_TO_DETAIL = {
      directionless: IS_DIRECTIONLESS,
      unmergeable: IS_UNMERGEABLE
    };
    ELEMENT_TYPE_TO_FORMAT = {
      center: IS_ALIGN_CENTER,
      end: IS_ALIGN_END,
      justify: IS_ALIGN_JUSTIFY,
      left: IS_ALIGN_LEFT,
      right: IS_ALIGN_RIGHT,
      start: IS_ALIGN_START
    };
    ELEMENT_FORMAT_TO_TYPE = {
      [IS_ALIGN_CENTER]: "center",
      [IS_ALIGN_END]: "end",
      [IS_ALIGN_JUSTIFY]: "justify",
      [IS_ALIGN_LEFT]: "left",
      [IS_ALIGN_RIGHT]: "right",
      [IS_ALIGN_START]: "start"
    };
    TEXT_MODE_TO_TYPE = {
      normal: IS_NORMAL,
      segmented: IS_SEGMENTED,
      token: IS_TOKEN
    };
    TEXT_TYPE_TO_MODE = {
      [IS_NORMAL]: "normal",
      [IS_SEGMENTED]: "segmented",
      [IS_TOKEN]: "token"
    };
    NODE_STATE_KEY = "$";
    TEXT_MUTATION_VARIANCE = 100;
    isProcessingMutations = false;
    lastTextEntryTimeStamp = 0;
    StateConfig = class {
      /** The string key used when serializing this state to JSON */
      /** The parse function from the StateValueConfig passed to createState */
      /**
       * The unparse function from the StateValueConfig passed to createState,
       * with a default that is simply a pass-through that assumes the value is
       * JSON serializable.
       */
      /**
       * An equality function from the StateValueConfig, with a default of
       * Object.is.
       */
      /**
       * The result of `stateValueConfig.parse(undefined)`, which is computed only
       * once and used as the default value. When the current value `isEqual` to
       * the `defaultValue`, it will not be serialized to JSON.
       */
      constructor(key2, stateValueConfig) {
        this.key = key2;
        this.parse = stateValueConfig.parse.bind(stateValueConfig);
        this.unparse = (stateValueConfig.unparse || coerceToJSON).bind(stateValueConfig);
        this.isEqual = (stateValueConfig.isEqual || Object.is).bind(stateValueConfig);
        this.defaultValue = this.parse(void 0);
      }
    };
    NodeState = class _NodeState {
      /**
       * @internal
       *
       * Track the (versioned) node that this NodeState was created for, to
       * facilitate copy-on-write for NodeState. When a LexicalNode is cloned,
       * it will *reference* the NodeState from its prevNode. From the nextNode
       * you can continue to read state without copying, but the first $setState
       * will trigger a copy of the prevNode's NodeState with the node property
       * updated.
       */
      /**
       * @internal
       *
       * State that has already been parsed in a get state, so it is safe. (can be returned with
       * just a cast since the proof was given before).
       *
       * Note that it uses StateConfig, so in addition to (1) the CURRENT VALUE, it has access to
       * (2) the State key (3) the DEFAULT VALUE and (4) the PARSE FUNCTION
       */
      /**
       * @internal
       *
       * A copy of serializedNode[NODE_STATE_KEY] that is made when JSON is
       * imported but has not been parsed yet.
       *
       * It stays here until a get state requires us to parse it, and since we
       * then know the value is safe we move it to knownState and garbage collect
       * it at the next version.
       *
       * Note that since only string keys are used here, we can only allow this
       * state to pass-through on export or on the next version since there is
       * no known value configuration. This pass-through is to support scenarios
       * where multiple versions of the editor code are working in parallel so
       * an old version of your code doesnt erase metadata that was
       * set by a newer version of your code.
       */
      /**
       * @internal
       *
       * This sharedConfigMap is preserved across all versions of a given node and
       * remains writable. It is how keys are resolved to configuration.
       */
      /**
       * @internal
       *
       * The count of known or unknown keys in this state, ignoring the
       * intersection between the two sets.
       */
      /**
       * @internal
       */
      constructor(node, sharedConfigMap = /* @__PURE__ */ new Map(), unknownState = void 0, knownState = /* @__PURE__ */ new Map(), size = void 0) {
        this.node = node;
        this.sharedConfigMap = sharedConfigMap;
        this.unknownState = unknownState;
        this.knownState = knownState;
        const computedSize = size !== void 0 ? size : computeSize(sharedConfigMap, unknownState, knownState);
        {
          if (!(size === void 0 || computedSize === size)) {
            formatDevErrorMessage(`NodeState: size != computedSize (${String(size)} != ${String(computedSize)})`);
          }
          for (const stateConfig of knownState.keys()) {
            if (!sharedConfigMap.has(stateConfig.key)) {
              formatDevErrorMessage(`NodeState: sharedConfigMap missing knownState key ${stateConfig.key}`);
            }
          }
        }
        this.size = computedSize;
      }
      /** @internal */
      getValue(stateConfig) {
        const known = this.knownState.get(stateConfig);
        if (known !== void 0) {
          return known;
        }
        this.sharedConfigMap.set(stateConfig.key, stateConfig);
        let parsed = stateConfig.defaultValue;
        if (this.unknownState && stateConfig.key in this.unknownState) {
          const jsonValue = this.unknownState[stateConfig.key];
          if (jsonValue !== void 0) {
            parsed = stateConfig.parse(jsonValue);
          }
          this.updateFromKnown(stateConfig, parsed);
        }
        return parsed;
      }
      /**
       * @internal
       *
       * Used only for advanced use cases, such as collab. The intent here is to
       * allow you to diff states with a more stable interface than the properties
       * of this class.
       */
      getInternalState() {
        return [this.unknownState, this.knownState];
      }
      /**
       * Encode this NodeState to JSON in the format that its node expects.
       * This returns `{[NODE_STATE_KEY]?: UnknownStateRecord}` rather than
       * `UnknownStateRecord | undefined` so that we can support flattening
       * specific entries in the future when nodes can declare what
       * their required StateConfigs are.
       */
      toJSON() {
        const state = {
          ...this.unknownState
        };
        for (const [stateConfig, v4] of this.knownState) {
          if (stateConfig.isEqual(v4, stateConfig.defaultValue)) {
            delete state[stateConfig.key];
          } else {
            state[stateConfig.key] = stateConfig.unparse(v4);
          }
        }
        return undefinedIfEmpty(state) ? {
          [NODE_STATE_KEY]: state
        } : {};
      }
      /**
       * @internal
       *
       * A NodeState is writable when the node to update matches
       * the node associated with the NodeState. This basically
       * mirrors how the EditorState NodeMap works, but in a
       * bottom-up organization rather than a top-down organization.
       *
       * This allows us to implement the same "copy on write"
       * pattern for state, without having the state version
       * update every time the node version changes (e.g. when
       * its parent or siblings change).
       *
       * @param node The node to associate with the state
       * @returns The next writable state
       */
      getWritable(node) {
        if (this.node === node) {
          return this;
        }
        const nextKnownState = new Map(this.knownState);
        const nextUnknownState = cloneUnknownState(this.unknownState);
        if (nextUnknownState) {
          for (const stateConfig of nextKnownState.keys()) {
            delete nextUnknownState[stateConfig.key];
          }
        }
        return new _NodeState(node, this.sharedConfigMap, undefinedIfEmpty(nextUnknownState), nextKnownState, this.size);
      }
      /** @internal */
      updateFromKnown(stateConfig, value) {
        const key2 = stateConfig.key;
        this.sharedConfigMap.set(key2, stateConfig);
        const {
          knownState,
          unknownState
        } = this;
        if (!(knownState.has(stateConfig) || unknownState && key2 in unknownState)) {
          this.size++;
        }
        knownState.set(stateConfig, value);
      }
      /**
       * @internal
       *
       * This is intended for advanced use cases only, such
       * as collab or dev tools.
       *
       * Update a single key value pair from unknown state,
       * parsing it if the key is known to this node. This is
       * basically like updateFromJSON, but the effect is
       * isolated to a single entry.
       *
       * @param k The string key from an UnknownStateRecord
       * @param v The unknown value from an UnknownStateRecord
       */
      updateFromUnknown(k5, v4) {
        const stateConfig = this.sharedConfigMap.get(k5);
        if (stateConfig) {
          this.updateFromKnown(stateConfig, stateConfig.parse(v4));
        } else {
          this.unknownState = this.unknownState || {};
          if (!(k5 in this.unknownState)) {
            this.size++;
          }
          this.unknownState[k5] = v4;
        }
      }
      /**
       * @internal
       *
       * Reset all existing state to default or empty values,
       * and perform any updates from the given unknownState.
       *
       * This is used when initializing a node's state from JSON,
       * or when resetting a node's state from JSON.
       *
       * @param unknownState The new state in serialized form
       */
      updateFromJSON(unknownState) {
        const {
          knownState
        } = this;
        for (const stateConfig of knownState.keys()) {
          knownState.set(stateConfig, stateConfig.defaultValue);
        }
        this.size = knownState.size;
        this.unknownState = {};
        if (unknownState) {
          for (const [k5, v4] of Object.entries(unknownState)) {
            this.updateFromUnknown(k5, v4);
          }
        }
        this.unknownState = undefinedIfEmpty(this.unknownState);
      }
    };
    subTreeTextContent = "";
    subTreeDirectionedTextContent = "";
    subTreeTextFormat = null;
    subTreeTextStyle = "";
    editorTextContent = "";
    treatAllNodesAsDirty = false;
    activeEditorStateReadOnly = false;
    activeTextDirection = null;
    DEFAULT_INDENT_VALUE = "40px";
    SELECTION_CHANGE_COMMAND = createCommand("SELECTION_CHANGE_COMMAND");
    SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
    CLICK_COMMAND = createCommand("CLICK_COMMAND");
    DELETE_CHARACTER_COMMAND = createCommand("DELETE_CHARACTER_COMMAND");
    INSERT_LINE_BREAK_COMMAND = createCommand("INSERT_LINE_BREAK_COMMAND");
    INSERT_PARAGRAPH_COMMAND = createCommand("INSERT_PARAGRAPH_COMMAND");
    CONTROLLED_TEXT_INSERTION_COMMAND = createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
    PASTE_COMMAND = createCommand("PASTE_COMMAND");
    REMOVE_TEXT_COMMAND = createCommand("REMOVE_TEXT_COMMAND");
    DELETE_WORD_COMMAND = createCommand("DELETE_WORD_COMMAND");
    DELETE_LINE_COMMAND = createCommand("DELETE_LINE_COMMAND");
    FORMAT_TEXT_COMMAND = createCommand("FORMAT_TEXT_COMMAND");
    UNDO_COMMAND = createCommand("UNDO_COMMAND");
    REDO_COMMAND = createCommand("REDO_COMMAND");
    KEY_DOWN_COMMAND = createCommand("KEYDOWN_COMMAND");
    KEY_ARROW_RIGHT_COMMAND = createCommand("KEY_ARROW_RIGHT_COMMAND");
    MOVE_TO_END = createCommand("MOVE_TO_END");
    KEY_ARROW_LEFT_COMMAND = createCommand("KEY_ARROW_LEFT_COMMAND");
    MOVE_TO_START = createCommand("MOVE_TO_START");
    KEY_ARROW_UP_COMMAND = createCommand("KEY_ARROW_UP_COMMAND");
    KEY_ARROW_DOWN_COMMAND = createCommand("KEY_ARROW_DOWN_COMMAND");
    KEY_ENTER_COMMAND = createCommand("KEY_ENTER_COMMAND");
    KEY_SPACE_COMMAND = createCommand("KEY_SPACE_COMMAND");
    KEY_BACKSPACE_COMMAND = createCommand("KEY_BACKSPACE_COMMAND");
    KEY_ESCAPE_COMMAND = createCommand("KEY_ESCAPE_COMMAND");
    KEY_DELETE_COMMAND = createCommand("KEY_DELETE_COMMAND");
    KEY_TAB_COMMAND = createCommand("KEY_TAB_COMMAND");
    INSERT_TAB_COMMAND = createCommand("INSERT_TAB_COMMAND");
    INDENT_CONTENT_COMMAND = createCommand("INDENT_CONTENT_COMMAND");
    OUTDENT_CONTENT_COMMAND = createCommand("OUTDENT_CONTENT_COMMAND");
    DROP_COMMAND = createCommand("DROP_COMMAND");
    FORMAT_ELEMENT_COMMAND = createCommand("FORMAT_ELEMENT_COMMAND");
    DRAGSTART_COMMAND = createCommand("DRAGSTART_COMMAND");
    DRAGOVER_COMMAND = createCommand("DRAGOVER_COMMAND");
    DRAGEND_COMMAND = createCommand("DRAGEND_COMMAND");
    COPY_COMMAND = createCommand("COPY_COMMAND");
    CUT_COMMAND = createCommand("CUT_COMMAND");
    SELECT_ALL_COMMAND = createCommand("SELECT_ALL_COMMAND");
    CLEAR_EDITOR_COMMAND = createCommand("CLEAR_EDITOR_COMMAND");
    CLEAR_HISTORY_COMMAND = createCommand("CLEAR_HISTORY_COMMAND");
    CAN_REDO_COMMAND = createCommand("CAN_REDO_COMMAND");
    CAN_UNDO_COMMAND = createCommand("CAN_UNDO_COMMAND");
    FOCUS_COMMAND = createCommand("FOCUS_COMMAND");
    BLUR_COMMAND = createCommand("BLUR_COMMAND");
    KEY_MODIFIER_COMMAND = createCommand("KEY_MODIFIER_COMMAND");
    PASS_THROUGH_COMMAND = Object.freeze({});
    ANDROID_COMPOSITION_LATENCY = 30;
    rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
    if (CAN_USE_BEFORE_INPUT) {
      rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
    }
    lastKeyDownTimeStamp = 0;
    lastKeyCode = null;
    lastBeforeInputInsertTextTimeStamp = 0;
    unprocessedBeforeInputData = null;
    rootElementsRegistered = /* @__PURE__ */ new WeakMap();
    isSelectionChangeFromDOMUpdate = false;
    isSelectionChangeFromMouseDown = false;
    isInsertLineBreak = false;
    isFirefoxEndingComposition = false;
    isSafariEndingComposition = false;
    safariEndCompositionEventData = "";
    postDeleteSelectionToRestore = null;
    collapsedSelectionFormat = [0, "", 0, "root", 0];
    activeNestedEditorsMap = /* @__PURE__ */ new Map();
    rootElementNotRegisteredWarning = warnOnlyOnce("Root element not registered");
    LexicalNode = class {
      // Allow us to look up the type including static props
      /** @internal */
      /** @internal */
      //@ts-ignore We set the key in the constructor.
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      // Flow doesn't support abstract classes unfortunately, so we can't _force_
      // subclasses of Node to implement statics. All subclasses of Node should have
      // a static getType and clone method though. We define getType and clone here so we can call it
      // on any  Node, and we throw this error by default since the subclass should provide
      // their own implementation.
      /**
       * Returns the string type of this node. Every node must
       * implement this and it MUST BE UNIQUE amongst nodes registered
       * on the editor.
       *
       */
      static getType() {
        {
          formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .getType().`);
        }
      }
      /**
       * Clones this node, creating a new node with a different key
       * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
       * implement this method.
       *
       */
      static clone(_data) {
        {
          formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .clone().`);
        }
      }
      /**
       * Perform any state updates on the clone of prevNode that are not already
       * handled by the constructor call in the static clone method. If you have
       * state to update in your clone that is not handled directly by the
       * constructor, it is advisable to override this method but it is required
       * to include a call to `super.afterCloneFrom(prevNode)` in your
       * implementation. This is only intended to be called by
       * {@link $cloneWithProperties} function or via a super call.
       *
       * @example
       * ```ts
       * class ClassesTextNode extends TextNode {
       *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM
       *   __classes = new Set<string>();
       *   static clone(node: ClassesTextNode): ClassesTextNode {
       *     // The inherited TextNode constructor is used here, so
       *     // classes is not set by this method.
       *     return new ClassesTextNode(node.__text, node.__key);
       *   }
       *   afterCloneFrom(node: this): void {
       *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom
       *     // for necessary state updates
       *     super.afterCloneFrom(node);
       *     this.__addClasses(node.__classes);
       *   }
       *   // This method is a private implementation detail, it is not
       *   // suitable for the public API because it does not call getWritable
       *   __addClasses(classNames: Iterable<string>): this {
       *     for (const className of classNames) {
       *       this.__classes.add(className);
       *     }
       *     return this;
       *   }
       *   addClass(...classNames: string[]): this {
       *     return this.getWritable().__addClasses(classNames);
       *   }
       *   removeClass(...classNames: string[]): this {
       *     const node = this.getWritable();
       *     for (const className of classNames) {
       *       this.__classes.delete(className);
       *     }
       *     return this;
       *   }
       *   getClasses(): Set<string> {
       *     return this.getLatest().__classes;
       *   }
       * }
       * ```
       *
       */
      afterCloneFrom(prevNode) {
        this.__parent = prevNode.__parent;
        this.__next = prevNode.__next;
        this.__prev = prevNode.__prev;
        this.__state = prevNode.__state;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(key2) {
        this.__type = this.constructor.getType();
        this.__parent = null;
        this.__prev = null;
        this.__next = null;
        Object.defineProperty(this, "__state", {
          configurable: true,
          enumerable: false,
          value: void 0,
          writable: true
        });
        $setNodeKey(this, key2);
        {
          if (this.__type !== "root") {
            errorOnReadOnly();
            errorOnTypeKlassMismatch(this.__type, this.constructor);
          }
        }
      }
      // Getters and Traversers
      /**
       * Returns the string type of this node.
       */
      getType() {
        return this.__type;
      }
      isInline() {
        {
          formatDevErrorMessage(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
        }
      }
      /**
       * Returns true if there is a path between this node and the RootNode, false otherwise.
       * This is a way of determining if the node is "attached" EditorState. Unattached nodes
       * won't be reconciled and will ultimately be cleaned up by the Lexical GC.
       */
      isAttached() {
        let nodeKey = this.__key;
        while (nodeKey !== null) {
          if (nodeKey === "root") {
            return true;
          }
          const node = $getNodeByKey(nodeKey);
          if (node === null) {
            break;
          }
          nodeKey = node.__parent;
        }
        return false;
      }
      /**
       * Returns true if this node is contained within the provided Selection., false otherwise.
       * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
       * what's included.
       *
       * @param selection - The selection that we want to determine if the node is in.
       */
      isSelected(selection) {
        const targetSelection = selection || $getSelection();
        if (targetSelection == null) {
          return false;
        }
        const isSelected = targetSelection.getNodes().some((n2) => n2.__key === this.__key);
        if ($isTextNode(this)) {
          return isSelected;
        }
        const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element";
        if (isElementRangeSelection) {
          if (targetSelection.isCollapsed()) {
            return false;
          }
          const parentNode = this.getParent();
          if ($isDecoratorNode(this) && this.isInline() && parentNode) {
            const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;
            if (parentNode.is(firstPoint.getNode()) && firstPoint.offset === parentNode.getChildrenSize() && this.is(parentNode.getLastChild())) {
              return false;
            }
          }
        }
        return isSelected;
      }
      /**
       * Returns this nodes key.
       */
      getKey() {
        return this.__key;
      }
      /**
       * Returns the zero-based index of this node within the parent.
       */
      getIndexWithinParent() {
        const parent = this.getParent();
        if (parent === null) {
          return -1;
        }
        let node = parent.getFirstChild();
        let index = 0;
        while (node !== null) {
          if (this.is(node)) {
            return index;
          }
          index++;
          node = node.getNextSibling();
        }
        return -1;
      }
      /**
       * Returns the parent of this node, or null if none is found.
       */
      getParent() {
        const parent = this.getLatest().__parent;
        if (parent === null) {
          return null;
        }
        return $getNodeByKey(parent);
      }
      /**
       * Returns the parent of this node, or throws if none is found.
       */
      getParentOrThrow() {
        const parent = this.getParent();
        if (parent === null) {
          {
            formatDevErrorMessage(`Expected node ${this.__key} to have a parent.`);
          }
        }
        return parent;
      }
      /**
       * Returns the highest (in the EditorState tree)
       * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
       * for more information on which Elements comprise "roots".
       */
      getTopLevelElement() {
        let node = this;
        while (node !== null) {
          const parent = node.getParent();
          if ($isRootOrShadowRoot(parent)) {
            if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {
              formatDevErrorMessage(`Children of root nodes must be elements or decorators`);
            }
            return node;
          }
          node = parent;
        }
        return null;
      }
      /**
       * Returns the highest (in the EditorState tree)
       * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
       * for more information on which Elements comprise "roots".
       */
      getTopLevelElementOrThrow() {
        const parent = this.getTopLevelElement();
        if (parent === null) {
          {
            formatDevErrorMessage(`Expected node ${this.__key} to have a top parent element.`);
          }
        }
        return parent;
      }
      /**
       * Returns a list of the every ancestor of this node,
       * all the way up to the RootNode.
       *
       */
      getParents() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node);
          node = node.getParent();
        }
        return parents;
      }
      /**
       * Returns a list of the keys of every ancestor of this node,
       * all the way up to the RootNode.
       *
       */
      getParentKeys() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node.__key);
          node = node.getParent();
        }
        return parents;
      }
      /**
       * Returns the "previous" siblings - that is, the node that comes
       * before this one in the same parent.
       *
       */
      getPreviousSibling() {
        const self = this.getLatest();
        const prevKey = self.__prev;
        return prevKey === null ? null : $getNodeByKey(prevKey);
      }
      /**
       * Returns the "previous" siblings - that is, the nodes that come between
       * this one and the first child of it's parent, inclusive.
       *
       */
      getPreviousSiblings() {
        const siblings = [];
        const parent = this.getParent();
        if (parent === null) {
          return siblings;
        }
        let node = parent.getFirstChild();
        while (node !== null) {
          if (node.is(this)) {
            break;
          }
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      /**
       * Returns the "next" siblings - that is, the node that comes
       * after this one in the same parent
       *
       */
      getNextSibling() {
        const self = this.getLatest();
        const nextKey = self.__next;
        return nextKey === null ? null : $getNodeByKey(nextKey);
      }
      /**
       * Returns all "next" siblings - that is, the nodes that come between this
       * one and the last child of it's parent, inclusive.
       *
       */
      getNextSiblings() {
        const siblings = [];
        let node = this.getNextSibling();
        while (node !== null) {
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      /**
       * @deprecated use {@link $getCommonAncestor}
       *
       * Returns the closest common ancestor of this node and the provided one or null
       * if one cannot be found.
       *
       * @param node - the other node to find the common ancestor of.
       */
      getCommonAncestor(node) {
        const a2 = $isElementNode(this) ? this : this.getParent();
        const b3 = $isElementNode(node) ? node : node.getParent();
        const result = a2 && b3 ? $getCommonAncestor(a2, b3) : null;
        return result ? result.commonAncestor : null;
      }
      /**
       * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
       * Always use this instead of referential equality.
       *
       * @param object - the node to perform the equality comparison on.
       */
      is(object) {
        if (object == null) {
          return false;
        }
        return this.__key === object.__key;
      }
      /**
       * Returns true if this node logically precedes the target node in the
       * editor state, false otherwise (including if there is no common ancestor).
       *
       * Note that this notion of isBefore is based on post-order; a descendant
       * node is always before its ancestors. See also
       * {@link $getCommonAncestor} and {@link $comparePointCaretNext} for
       * more flexible ways to determine the relative positions of nodes.
       *
       * @param targetNode - the node we're testing to see if it's after this one.
       */
      isBefore(targetNode) {
        const compare = $getCommonAncestor(this, targetNode);
        if (compare === null) {
          return false;
        }
        if (compare.type === "descendant") {
          return true;
        }
        if (compare.type === "branch") {
          return $getCommonAncestorResultBranchOrder(compare) === -1;
        }
        if (!(compare.type === "same" || compare.type === "ancestor")) {
          formatDevErrorMessage(`LexicalNode.isBefore: exhaustiveness check`);
        }
        return false;
      }
      /**
       * Returns true if this node is an ancestor of and distinct from the target node, false otherwise.
       *
       * @param targetNode - the would-be child node.
       */
      isParentOf(targetNode) {
        const result = $getCommonAncestor(this, targetNode);
        return result !== null && result.type === "ancestor";
      }
      // TO-DO: this function can be simplified a lot
      /**
       * Returns a list of nodes that are between this node and
       * the target node in the EditorState.
       *
       * @param targetNode - the node that marks the other end of the range of nodes to be returned.
       */
      getNodesBetween(targetNode) {
        const isBefore = this.isBefore(targetNode);
        const nodes = [];
        const visited = /* @__PURE__ */ new Set();
        let node = this;
        while (true) {
          if (node === null) {
            break;
          }
          const key2 = node.__key;
          if (!visited.has(key2)) {
            visited.add(key2);
            nodes.push(node);
          }
          if (node === targetNode) {
            break;
          }
          const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
          if (child !== null) {
            node = child;
            continue;
          }
          const nextSibling2 = isBefore ? node.getNextSibling() : node.getPreviousSibling();
          if (nextSibling2 !== null) {
            node = nextSibling2;
            continue;
          }
          const parent = node.getParentOrThrow();
          if (!visited.has(parent.__key)) {
            nodes.push(parent);
          }
          if (parent === targetNode) {
            break;
          }
          let parentSibling = null;
          let ancestor = parent;
          do {
            if (ancestor === null) {
              {
                formatDevErrorMessage(`getNodesBetween: ancestor is null`);
              }
            }
            parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
            ancestor = ancestor.getParent();
            if (ancestor !== null) {
              if (parentSibling === null && !visited.has(ancestor.__key)) {
                nodes.push(ancestor);
              }
            } else {
              break;
            }
          } while (parentSibling === null);
          node = parentSibling;
        }
        if (!isBefore) {
          nodes.reverse();
        }
        return nodes;
      }
      /**
       * Returns true if this node has been marked dirty during this update cycle.
       *
       */
      isDirty() {
        const editor = getActiveEditor();
        const dirtyLeaves = editor._dirtyLeaves;
        return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
      }
      /**
       * Returns the latest version of the node from the active EditorState.
       * This is used to avoid getting values from stale node references.
       *
       */
      getLatest() {
        const latest = $getNodeByKey(this.__key);
        if (latest === null) {
          {
            formatDevErrorMessage(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
          }
        }
        return latest;
      }
      /**
       * Returns a mutable version of the node using {@link $cloneWithProperties}
       * if necessary. Will throw an error if called outside of a Lexical Editor
       * {@link LexicalEditor.update} callback.
       *
       */
      getWritable() {
        errorOnReadOnly();
        const editorState = getActiveEditorState();
        const editor = getActiveEditor();
        const nodeMap = editorState._nodeMap;
        const key2 = this.__key;
        const latestNode = this.getLatest();
        const cloneNotNeeded = editor._cloneNotNeeded;
        const selection = $getSelection();
        if (selection !== null) {
          selection.setCachedNodes(null);
        }
        if (cloneNotNeeded.has(key2)) {
          internalMarkNodeAsDirty(latestNode);
          return latestNode;
        }
        const mutableNode = $cloneWithProperties(latestNode);
        cloneNotNeeded.add(key2);
        internalMarkNodeAsDirty(mutableNode);
        nodeMap.set(key2, mutableNode);
        return mutableNode;
      }
      /**
       * Returns the text content of the node. Override this for
       * custom nodes that should have a representation in plain text
       * format (for copy + paste, for example)
       *
       */
      getTextContent() {
        return "";
      }
      /**
       * Returns the length of the string produced by calling getTextContent on this node.
       *
       */
      getTextContentSize() {
        return this.getTextContent().length;
      }
      // View
      /**
       * Called during the reconciliation process to determine which nodes
       * to insert into the DOM for this Lexical Node.
       *
       * This method must return exactly one HTMLElement. Nested elements are not supported.
       *
       * Do not attempt to update the Lexical EditorState during this phase of the update lifecycle.
       *
       * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
       * @param _editor - allows access to the editor for context during reconciliation.
       *
       * */
      createDOM(_config, _editor) {
        {
          formatDevErrorMessage(`createDOM: base method not extended`);
        }
      }
      /**
       * Called when a node changes and should update the DOM
       * in whatever way is necessary to make it align with any changes that might
       * have happened during the update.
       *
       * Returning "true" here will cause lexical to unmount and recreate the DOM node
       * (by calling createDOM). You would need to do this if the element tag changes,
       * for instance.
       *
       * */
      updateDOM(_prevNode, _dom, _config) {
        {
          formatDevErrorMessage(`updateDOM: base method not extended`);
        }
      }
      /**
       * Controls how the this node is serialized to HTML. This is important for
       * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
       * in which case the primary transfer format is HTML. It's also important if you're serializing
       * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
       * also use this method to build your own HTML renderer.
       *
       * */
      exportDOM(editor) {
        const element = this.createDOM(editor._config, editor);
        return {
          element
        };
      }
      /**
       * Controls how the this node is serialized to JSON. This is important for
       * copy and paste between Lexical editors sharing the same namespace. It's also important
       * if you're serializing to JSON for persistent storage somewhere.
       * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
       *
       * */
      exportJSON() {
        const state = this.__state ? this.__state.toJSON() : void 0;
        return {
          type: this.__type,
          version: 1,
          ...state
        };
      }
      /**
       * Controls how the this node is deserialized from JSON. This is usually boilerplate,
       * but provides an abstraction between the node implementation and serialized interface that can
       * be important if you ever make breaking changes to a node schema (by adding or removing properties).
       * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
       *
       * */
      static importJSON(_serializedNode) {
        {
          formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
        }
      }
      /**
       * Update this LexicalNode instance from serialized JSON. It's recommended
       * to implement as much logic as possible in this method instead of the
       * static importJSON method, so that the functionality can be inherited in subclasses.
       *
       * The LexicalUpdateJSON utility type should be used to ignore any type, version,
       * or children properties in the JSON so that the extended JSON from subclasses
       * are acceptable parameters for the super call.
       *
       * If overridden, this method must call super.
       *
       * @example
       * ```ts
       * class MyTextNode extends TextNode {
       *   // ...
       *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {
       *     return $createMyTextNode()
       *       .updateFromJSON(serializedNode);
       *   }
       *   updateFromJSON(
       *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,
       *   ): this {
       *     return super.updateFromJSON(serializedNode)
       *       .setMyProperty(serializedNode.myProperty);
       *   }
       * }
       * ```
       **/
      updateFromJSON(serializedNode) {
        return $updateStateFromJSON(this, serializedNode[NODE_STATE_KEY]);
      }
      /**
       * @experimental
       *
       * Registers the returned function as a transform on the node during
       * Editor initialization. Most such use cases should be addressed via
       * the {@link LexicalEditor.registerNodeTransform} API.
       *
       * Experimental - use at your own risk.
       */
      static transform() {
        return null;
      }
      // Setters and mutators
      /**
       * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
       * somewhere, the Lexical garbage collector will eventually clean it up.
       *
       * @param preserveEmptyParent - If falsy, the node's parent will be removed if
       * it's empty after the removal operation. This is the default behavior, subject to
       * other node heuristics such as {@link ElementNode#canBeEmpty}
       * */
      remove(preserveEmptyParent) {
        $removeNode(this, true, preserveEmptyParent);
      }
      /**
       * Replaces this LexicalNode with the provided node, optionally transferring the children
       * of the replaced node to the replacing node.
       *
       * @param replaceWith - The node to replace this one with.
       * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
       * */
      replace(replaceWith2, includeChildren) {
        errorOnReadOnly();
        let selection = $getSelection();
        if (selection !== null) {
          selection = selection.clone();
        }
        errorOnInsertTextNodeOnRoot(this, replaceWith2);
        const self = this.getLatest();
        const toReplaceKey = this.__key;
        const key2 = replaceWith2.__key;
        const writableReplaceWith = replaceWith2.getWritable();
        const writableParent = this.getParentOrThrow().getWritable();
        const size = writableParent.__size;
        removeFromParent(writableReplaceWith);
        const prevSibling = self.getPreviousSibling();
        const nextSibling2 = self.getNextSibling();
        const prevKey = self.__prev;
        const nextKey = self.__next;
        const parentKey = self.__parent;
        $removeNode(self, false, true);
        if (prevSibling === null) {
          writableParent.__first = key2;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = key2;
        }
        writableReplaceWith.__prev = prevKey;
        if (nextSibling2 === null) {
          writableParent.__last = key2;
        } else {
          const writableNextSibling = nextSibling2.getWritable();
          writableNextSibling.__prev = key2;
        }
        writableReplaceWith.__next = nextKey;
        writableReplaceWith.__parent = parentKey;
        writableParent.__size = size;
        if (includeChildren) {
          if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {
            formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);
          }
          this.getChildren().forEach((child) => {
            writableReplaceWith.append(child);
          });
        }
        if ($isRangeSelection(selection)) {
          $setSelection(selection);
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor.key === toReplaceKey) {
            $moveSelectionPointToEnd(anchor, writableReplaceWith);
          }
          if (focus.key === toReplaceKey) {
            $moveSelectionPointToEnd(focus, writableReplaceWith);
          }
        }
        if ($getCompositionKey() === toReplaceKey) {
          $setCompositionKey(key2);
        }
        return writableReplaceWith;
      }
      /**
       * Inserts a node after this LexicalNode (as the next sibling).
       *
       * @param nodeToInsert - The node to insert after this one.
       * @param restoreSelection - Whether or not to attempt to resolve the
       * selection to the appropriate place after the operation is complete.
       * */
      insertAfter(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const oldParent = writableNodeToInsert.getParent();
        const selection = $getSelection();
        let elementAnchorSelectionOnNode = false;
        let elementFocusSelectionOnNode = false;
        if (oldParent !== null) {
          const oldIndex = nodeToInsert.getIndexWithinParent();
          removeFromParent(writableNodeToInsert);
          if ($isRangeSelection(selection)) {
            const oldParentKey = oldParent.__key;
            const anchor = selection.anchor;
            const focus = selection.focus;
            elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
            elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
          }
        }
        const nextSibling2 = this.getNextSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const insertKey = writableNodeToInsert.__key;
        const nextKey = writableSelf.__next;
        if (nextSibling2 === null) {
          writableParent.__last = insertKey;
        } else {
          const writableNextSibling = nextSibling2.getWritable();
          writableNextSibling.__prev = insertKey;
        }
        writableParent.__size++;
        writableSelf.__next = insertKey;
        writableNodeToInsert.__next = nextKey;
        writableNodeToInsert.__prev = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        if (restoreSelection && $isRangeSelection(selection)) {
          const index = this.getIndexWithinParent();
          $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);
          const writableParentKey = writableParent.__key;
          if (elementAnchorSelectionOnNode) {
            selection.anchor.set(writableParentKey, index + 2, "element");
          }
          if (elementFocusSelectionOnNode) {
            selection.focus.set(writableParentKey, index + 2, "element");
          }
        }
        return nodeToInsert;
      }
      /**
       * Inserts a node before this LexicalNode (as the previous sibling).
       *
       * @param nodeToInsert - The node to insert before this one.
       * @param restoreSelection - Whether or not to attempt to resolve the
       * selection to the appropriate place after the operation is complete.
       * */
      insertBefore(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const insertKey = writableNodeToInsert.__key;
        removeFromParent(writableNodeToInsert);
        const prevSibling = this.getPreviousSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const prevKey = writableSelf.__prev;
        const index = this.getIndexWithinParent();
        if (prevSibling === null) {
          writableParent.__first = insertKey;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = insertKey;
        }
        writableParent.__size++;
        writableSelf.__prev = insertKey;
        writableNodeToInsert.__prev = prevKey;
        writableNodeToInsert.__next = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        const selection = $getSelection();
        if (restoreSelection && $isRangeSelection(selection)) {
          const parent = this.getParentOrThrow();
          $updateElementSelectionOnCreateDeleteNode(selection, parent, index);
        }
        return nodeToInsert;
      }
      /**
       * Whether or not this node has a required parent. Used during copy + paste operations
       * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
       * a ListNode parent or TextNodes with a ParagraphNode parent.
       *
       * */
      isParentRequired() {
        return false;
      }
      /**
       * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
       *
       * */
      createParentElementNode() {
        return $createParagraphNode();
      }
      selectStart() {
        return this.selectPrevious();
      }
      selectEnd() {
        return this.selectNext(0, 0);
      }
      /**
       * Moves selection to the previous sibling of this node, at the specified offsets.
       *
       * @param anchorOffset - The anchor offset for selection.
       * @param focusOffset -  The focus offset for selection
       * */
      selectPrevious(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const prevSibling = this.getPreviousSibling();
        const parent = this.getParentOrThrow();
        if (prevSibling === null) {
          return parent.select(0, 0);
        }
        if ($isElementNode(prevSibling)) {
          return prevSibling.select();
        } else if (!$isTextNode(prevSibling)) {
          const index = prevSibling.getIndexWithinParent() + 1;
          return parent.select(index, index);
        }
        return prevSibling.select(anchorOffset, focusOffset);
      }
      /**
       * Moves selection to the next sibling of this node, at the specified offsets.
       *
       * @param anchorOffset - The anchor offset for selection.
       * @param focusOffset -  The focus offset for selection
       * */
      selectNext(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const nextSibling2 = this.getNextSibling();
        const parent = this.getParentOrThrow();
        if (nextSibling2 === null) {
          return parent.select();
        }
        if ($isElementNode(nextSibling2)) {
          return nextSibling2.select(0, 0);
        } else if (!$isTextNode(nextSibling2)) {
          const index = nextSibling2.getIndexWithinParent();
          return parent.select(index, index);
        }
        return nextSibling2.select(anchorOffset, focusOffset);
      }
      /**
       * Marks a node dirty, triggering transforms and
       * forcing it to be reconciled during the update cycle.
       *
       * */
      markDirty() {
        this.getWritable();
      }
      /**
       * @internal
       *
       * When the reconciler detects that a node was mutated, this method
       * may be called to restore the node to a known good state.
       */
      reconcileObservedMutation(dom2, editor) {
        this.markDirty();
      }
    };
    LineBreakNode = class _LineBreakNode extends LexicalNode {
      static getType() {
        return "linebreak";
      }
      static clone(node) {
        return new _LineBreakNode(node.__key);
      }
      constructor(key2) {
        super(key2);
      }
      getTextContent() {
        return "\n";
      }
      createDOM() {
        return document.createElement("br");
      }
      updateDOM() {
        return false;
      }
      isInline() {
        return true;
      }
      static importDOM() {
        return {
          br: (node) => {
            if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {
              return null;
            }
            return {
              conversion: $convertLineBreakElement,
              priority: 0
            };
          }
        };
      }
      static importJSON(serializedLineBreakNode) {
        return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);
      }
    };
    TextNode = class _TextNode extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "text";
      }
      static clone(node) {
        return new _TextNode(node.__text, node.__key);
      }
      afterCloneFrom(prevNode) {
        super.afterCloneFrom(prevNode);
        this.__text = prevNode.__text;
        this.__format = prevNode.__format;
        this.__style = prevNode.__style;
        this.__mode = prevNode.__mode;
        this.__detail = prevNode.__detail;
      }
      constructor(text = "", key2) {
        super(key2);
        this.__text = text;
        this.__format = 0;
        this.__style = "";
        this.__mode = 0;
        this.__detail = 0;
      }
      /**
       * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
       * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
       *
       * @returns a number representing the format of the text node.
       */
      getFormat() {
        const self = this.getLatest();
        return self.__format;
      }
      /**
       * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
       * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
       * or TextNode.isUnmergeable instead.
       *
       * @returns a number representing the detail of the text node.
       */
      getDetail() {
        const self = this.getLatest();
        return self.__detail;
      }
      /**
       * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
       *
       * @returns TextModeType.
       */
      getMode() {
        const self = this.getLatest();
        return TEXT_TYPE_TO_MODE[self.__mode];
      }
      /**
       * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
       *
       * @returns CSSText-like string of styles applied to the underlying DOM node.
       */
      getStyle() {
        const self = this.getLatest();
        return self.__style;
      }
      /**
       * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
       * with a RangeSelection, but are deleted as a single entity (not individually by character).
       *
       * @returns true if the node is in token mode, false otherwise.
       */
      isToken() {
        const self = this.getLatest();
        return self.__mode === IS_TOKEN;
      }
      /**
       *
       * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
       * mutate the TextNode, false otherwise.
       */
      isComposing() {
        return this.__key === $getCompositionKey();
      }
      /**
       * Returns whether or not the node is in "segmented" mode. TextNodes in segmented mode can be navigated through character-by-character
       * with a RangeSelection, but are deleted in space-delimited "segments".
       *
       * @returns true if the node is in segmented mode, false otherwise.
       */
      isSegmented() {
        const self = this.getLatest();
        return self.__mode === IS_SEGMENTED;
      }
      /**
       * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
       *
       * @returns true if the node is directionless, false otherwise.
       */
      isDirectionless() {
        const self = this.getLatest();
        return (self.__detail & IS_DIRECTIONLESS) !== 0;
      }
      /**
       * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
       * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
       *
       * @returns true if the node is unmergeable, false otherwise.
       */
      isUnmergeable() {
        const self = this.getLatest();
        return (self.__detail & IS_UNMERGEABLE) !== 0;
      }
      /**
       * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
       * string values to get the format of a TextNode.
       *
       * @param type - the TextFormatType to check for.
       *
       * @returns true if the node has the provided format, false otherwise.
       */
      hasFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.getFormat() & formatFlag) !== 0;
      }
      /**
       * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
       * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
       *
       * @returns true if the node is simple text, false otherwise.
       */
      isSimpleText() {
        return this.__type === "text" && this.__mode === 0;
      }
      /**
       * Returns the text content of the node as a string.
       *
       * @returns a string representing the text content of the node.
       */
      getTextContent() {
        const self = this.getLatest();
        return self.__text;
      }
      /**
       * Returns the format flags applied to the node as a 32-bit integer.
       *
       * @returns a number representing the TextFormatTypes applied to the node.
       */
      getFormatFlags(type, alignWithFormat) {
        const self = this.getLatest();
        const format = self.__format;
        return toggleTextFormatType(format, type, alignWithFormat);
      }
      /**
       *
       * @returns true if the text node supports font styling, false otherwise.
       */
      canHaveFormat() {
        return true;
      }
      /**
       * @returns true if the text node is inline, false otherwise.
       */
      isInline() {
        return true;
      }
      // View
      createDOM(config, editor) {
        const format = this.__format;
        const outerTag = getElementOuterTag(this, format);
        const innerTag = getElementInnerTag(this, format);
        const tag = outerTag === null ? innerTag : outerTag;
        const dom2 = document.createElement(tag);
        let innerDOM = dom2;
        if (this.hasFormat("code")) {
          dom2.setAttribute("spellcheck", "false");
        }
        if (outerTag !== null) {
          innerDOM = document.createElement(innerTag);
          dom2.appendChild(innerDOM);
        }
        const text = this.__text;
        createTextInnerDOM(innerDOM, this, innerTag, format, text, config);
        const style = this.__style;
        if (style !== "") {
          dom2.style.cssText = style;
        }
        return dom2;
      }
      updateDOM(prevNode, dom2, config) {
        const nextText = this.__text;
        const prevFormat = prevNode.__format;
        const nextFormat = this.__format;
        const prevOuterTag = getElementOuterTag(this, prevFormat);
        const nextOuterTag = getElementOuterTag(this, nextFormat);
        const prevInnerTag = getElementInnerTag(this, prevFormat);
        const nextInnerTag = getElementInnerTag(this, nextFormat);
        const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
        const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
        if (prevTag !== nextTag) {
          return true;
        }
        if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
          const prevInnerDOM = dom2.firstChild;
          if (prevInnerDOM == null) {
            {
              formatDevErrorMessage(`updateDOM: prevInnerDOM is null or undefined`);
            }
          }
          const nextInnerDOM = document.createElement(nextInnerTag);
          createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
          dom2.replaceChild(nextInnerDOM, prevInnerDOM);
          return false;
        }
        let innerDOM = dom2;
        if (nextOuterTag !== null) {
          if (prevOuterTag !== null) {
            innerDOM = dom2.firstChild;
            if (innerDOM == null) {
              {
                formatDevErrorMessage(`updateDOM: innerDOM is null or undefined`);
              }
            }
          }
        }
        setTextContent(nextText, innerDOM, this);
        const theme = config.theme;
        const textClassNames = theme.text;
        if (textClassNames !== void 0 && prevFormat !== nextFormat) {
          setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
        }
        const prevStyle = prevNode.__style;
        const nextStyle = this.__style;
        if (prevStyle !== nextStyle) {
          dom2.style.cssText = nextStyle;
        }
        return false;
      }
      static importDOM() {
        return {
          "#text": () => ({
            conversion: $convertTextDOMNode,
            priority: 0
          }),
          b: () => ({
            conversion: convertBringAttentionToElement,
            priority: 0
          }),
          code: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          em: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          i: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          mark: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          s: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          span: () => ({
            conversion: convertSpanElement,
            priority: 0
          }),
          strong: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sub: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sup: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          u: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        return $createTextNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);
      }
      // This improves Lexical's basic text output in copy+paste plus
      // for headless mode where people might use Lexical to generate
      // HTML content and not have the ability to use CSS classes.
      exportDOM(editor) {
        let {
          element
        } = super.exportDOM(editor);
        if (!isHTMLElement(element)) {
          formatDevErrorMessage(`Expected TextNode createDOM to always return a HTMLElement`);
        }
        element.style.whiteSpace = "pre-wrap";
        if (this.hasFormat("lowercase")) {
          element.style.textTransform = "lowercase";
        } else if (this.hasFormat("uppercase")) {
          element.style.textTransform = "uppercase";
        } else if (this.hasFormat("capitalize")) {
          element.style.textTransform = "capitalize";
        }
        if (this.hasFormat("bold")) {
          element = wrapElementWith(element, "b");
        }
        if (this.hasFormat("italic")) {
          element = wrapElementWith(element, "i");
        }
        if (this.hasFormat("strikethrough")) {
          element = wrapElementWith(element, "s");
        }
        if (this.hasFormat("underline")) {
          element = wrapElementWith(element, "u");
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          detail: this.getDetail(),
          format: this.getFormat(),
          mode: this.getMode(),
          style: this.getStyle(),
          text: this.getTextContent(),
          // As an exception here we invoke super at the end for historical reasons.
          // Namely, to preserve the order of the properties and not to break the tests
          // that use the serialized string representation.
          ...super.exportJSON()
        };
      }
      // Mutators
      selectionTransform(prevSelection, nextSelection) {
        return;
      }
      /**
       * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
       * version of the argument can only specify one format and doing so will remove all other formats that
       * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
       *
       * @param format - TextFormatType or 32-bit integer representing the node format.
       *
       * @returns this TextNode.
       * // TODO 0.12 This should just be a `string`.
       */
      setFormat(format) {
        const self = this.getWritable();
        self.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
        return self;
      }
      /**
       * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
       * version of the argument can only specify one detail value and doing so will remove all other detail values that
       * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
       * or {@link TextNode.toggleUnmergeable}
       *
       * @param detail - TextDetailType or 32-bit integer representing the node detail.
       *
       * @returns this TextNode.
       * // TODO 0.12 This should just be a `string`.
       */
      setDetail(detail) {
        const self = this.getWritable();
        self.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
        return self;
      }
      /**
       * Sets the node style to the provided CSSText-like string. Set this property as you
       * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
       *
       * @param style - CSSText to be applied to the underlying HTMLElement.
       *
       * @returns this TextNode.
       */
      setStyle(style) {
        const self = this.getWritable();
        self.__style = style;
        return self;
      }
      /**
       * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
       * The subscript and superscript formats are mutually exclusive.
       * Prefer using this method to turn specific formats on and off.
       *
       * @param type - TextFormatType to toggle.
       *
       * @returns this TextNode.
       */
      toggleFormat(type) {
        const format = this.getFormat();
        const newFormat = toggleTextFormatType(format, type, null);
        return this.setFormat(newFormat);
      }
      /**
       * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
       *
       * @returns this TextNode.
       */
      toggleDirectionless() {
        const self = this.getWritable();
        self.__detail ^= IS_DIRECTIONLESS;
        return self;
      }
      /**
       * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
       *
       * @returns this TextNode.
       */
      toggleUnmergeable() {
        const self = this.getWritable();
        self.__detail ^= IS_UNMERGEABLE;
        return self;
      }
      /**
       * Sets the mode of the node.
       *
       * @returns this TextNode.
       */
      setMode(type) {
        const mode = TEXT_MODE_TO_TYPE[type];
        if (this.__mode === mode) {
          return this;
        }
        const self = this.getWritable();
        self.__mode = mode;
        return self;
      }
      /**
       * Sets the text content of the node.
       *
       * @param text - the string to set as the text value of the node.
       *
       * @returns this TextNode.
       */
      setTextContent(text) {
        if (this.__text === text) {
          return this;
        }
        const self = this.getWritable();
        self.__text = text;
        return self;
      }
      /**
       * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
       *
       * @param _anchorOffset - the offset at which the Selection anchor will be placed.
       * @param _focusOffset - the offset at which the Selection focus will be placed.
       *
       * @returns the new RangeSelection.
       */
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const selection = $getSelection();
        const text = this.getTextContent();
        const key2 = this.__key;
        if (typeof text === "string") {
          const lastOffset = text.length;
          if (anchorOffset === void 0) {
            anchorOffset = lastOffset;
          }
          if (focusOffset === void 0) {
            focusOffset = lastOffset;
          }
        } else {
          anchorOffset = 0;
          focusOffset = 0;
        }
        if (!$isRangeSelection(selection)) {
          return $internalMakeRangeSelection(key2, anchorOffset, key2, focusOffset, "text", "text");
        } else {
          const compositionKey = $getCompositionKey();
          if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
            $setCompositionKey(key2);
          }
          selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
        }
        return selection;
      }
      selectStart() {
        return this.select(0, 0);
      }
      selectEnd() {
        const size = this.getTextContentSize();
        return this.select(size, size);
      }
      /**
       * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
       * specified. Can optionally calculate a new selection after the operation is complete.
       *
       * @param offset - the offset at which the splice operation should begin.
       * @param delCount - the number of characters to delete, starting from the offset.
       * @param newText - the text to insert into the TextNode at the offset.
       * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
       *
       * @returns this TextNode.
       */
      spliceText(offset, delCount, newText, moveSelection) {
        const writableSelf = this.getWritable();
        const text = writableSelf.__text;
        const handledTextLength = newText.length;
        let index = offset;
        if (index < 0) {
          index = handledTextLength + index;
          if (index < 0) {
            index = 0;
          }
        }
        const selection = $getSelection();
        if (moveSelection && $isRangeSelection(selection)) {
          const newOffset = offset + handledTextLength;
          selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
        }
        const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);
        writableSelf.__text = updatedText;
        return writableSelf;
      }
      /**
       * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
       * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
       * to insert text into this node. If false, it will insert the text in a new sibling node.
       *
       * @returns true if text can be inserted before the node, false otherwise.
       */
      canInsertTextBefore() {
        return true;
      }
      /**
       * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
       * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
       * to insert text into this node. If false, it will insert the text in a new sibling node.
       *
       * @returns true if text can be inserted after the node, false otherwise.
       */
      canInsertTextAfter() {
        return true;
      }
      /**
       * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
       * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
       *
       * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
       *
       * @returns an Array containing the newly-created TextNodes.
       */
      splitText(...splitOffsets) {
        errorOnReadOnly();
        const self = this.getLatest();
        const textContent2 = self.getTextContent();
        if (textContent2 === "") {
          return [];
        }
        const key2 = self.__key;
        const compositionKey = $getCompositionKey();
        const textLength = textContent2.length;
        splitOffsets.sort((a2, b3) => a2 - b3);
        splitOffsets.push(textLength);
        const parts = [];
        const splitOffsetsLength = splitOffsets.length;
        for (let start = 0, offsetIndex = 0; start < textLength && offsetIndex <= splitOffsetsLength; offsetIndex++) {
          const end = splitOffsets[offsetIndex];
          if (end > start) {
            parts.push(textContent2.slice(start, end));
            start = end;
          }
        }
        const partsLength = parts.length;
        if (partsLength === 1) {
          return [self];
        }
        const firstPart = parts[0];
        const parent = self.getParent();
        let writableNode;
        const format = self.getFormat();
        const style = self.getStyle();
        const detail = self.__detail;
        let hasReplacedSelf = false;
        let startTextPoint = null;
        let endTextPoint = null;
        const selection = $getSelection();
        if ($isRangeSelection(selection)) {
          const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];
          if (startPoint.type === "text" && startPoint.key === key2) {
            startTextPoint = startPoint;
          }
          if (endPoint.type === "text" && endPoint.key === key2) {
            endTextPoint = endPoint;
          }
        }
        if (self.isSegmented()) {
          writableNode = $createTextNode(firstPart);
          writableNode.__format = format;
          writableNode.__style = style;
          writableNode.__detail = detail;
          hasReplacedSelf = true;
        } else {
          writableNode = self.setTextContent(firstPart);
        }
        const splitNodes = [writableNode];
        for (let i2 = 1; i2 < partsLength; i2++) {
          const part = parts[i2];
          const sibling = $createTextNode(part);
          sibling.__format = format;
          sibling.__style = style;
          sibling.__detail = detail;
          const siblingKey = sibling.__key;
          if (compositionKey === key2) {
            $setCompositionKey(siblingKey);
          }
          splitNodes.push(sibling);
        }
        const originalStartOffset = startTextPoint ? startTextPoint.offset : null;
        const originalEndOffset = endTextPoint ? endTextPoint.offset : null;
        let startOffset = 0;
        for (const node of splitNodes) {
          if (!(startTextPoint || endTextPoint)) {
            break;
          }
          const endOffset = startOffset + node.getTextContentSize();
          if (startTextPoint !== null && originalStartOffset !== null && originalStartOffset <= endOffset && originalStartOffset >= startOffset) {
            startTextPoint.set(node.getKey(), originalStartOffset - startOffset, "text");
            if (originalStartOffset < endOffset) {
              startTextPoint = null;
            }
          }
          if (endTextPoint !== null && originalEndOffset !== null && originalEndOffset <= endOffset && originalEndOffset >= startOffset) {
            endTextPoint.set(node.getKey(), originalEndOffset - startOffset, "text");
            break;
          }
          startOffset = endOffset;
        }
        if (parent !== null) {
          internalMarkSiblingsAsDirty(this);
          const writableParent = parent.getWritable();
          const insertionIndex = this.getIndexWithinParent();
          if (hasReplacedSelf) {
            writableParent.splice(insertionIndex, 0, splitNodes);
            this.remove();
          } else {
            writableParent.splice(insertionIndex, 1, splitNodes);
          }
          if ($isRangeSelection(selection)) {
            $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
          }
        }
        return splitNodes;
      }
      /**
       * Merges the target TextNode into this TextNode, removing the target node.
       *
       * @param target - the TextNode to merge into this one.
       *
       * @returns this TextNode.
       */
      mergeWithSibling(target) {
        const isBefore = target === this.getPreviousSibling();
        if (!isBefore && target !== this.getNextSibling()) {
          {
            formatDevErrorMessage(`mergeWithSibling: sibling must be a previous or next sibling`);
          }
        }
        const key2 = this.__key;
        const targetKey = target.__key;
        const text = this.__text;
        const textLength = text.length;
        const compositionKey = $getCompositionKey();
        if (compositionKey === targetKey) {
          $setCompositionKey(key2);
        }
        const selection = $getSelection();
        if ($isRangeSelection(selection)) {
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor !== null && anchor.key === targetKey) {
            adjustPointOffsetForMergedSibling(anchor, isBefore, key2, target, textLength);
          }
          if (focus !== null && focus.key === targetKey) {
            adjustPointOffsetForMergedSibling(focus, isBefore, key2, target, textLength);
          }
        }
        const targetText = target.__text;
        const newText = isBefore ? targetText + text : text + targetText;
        this.setTextContent(newText);
        const writableSelf = this.getWritable();
        target.remove();
        return writableSelf;
      }
      /**
       * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
       * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
       * node class that you create and replace matched text with should return true from this method.
       *
       * @returns true if the node is to be treated as a "text entity", false otherwise.
       */
      isTextEntity() {
        return false;
      }
    };
    preParentCache = /* @__PURE__ */ new WeakMap();
    nodeNameToTextFormat = {
      code: "code",
      em: "italic",
      i: "italic",
      mark: "highlight",
      s: "strikethrough",
      strong: "bold",
      sub: "subscript",
      sup: "superscript",
      u: "underline"
    };
    TabNode = class _TabNode extends TextNode {
      static getType() {
        return "tab";
      }
      static clone(node) {
        return new _TabNode(node.__key);
      }
      constructor(key2) {
        super("	", key2);
        this.__detail = IS_UNMERGEABLE;
      }
      static importDOM() {
        return null;
      }
      createDOM(config) {
        const dom2 = super.createDOM(config);
        const classNames2 = getCachedClassNameArray(config.theme, "tab");
        if (classNames2 !== void 0) {
          const domClassList = dom2.classList;
          domClassList.add(...classNames2);
        }
        return dom2;
      }
      static importJSON(serializedTabNode) {
        return $createTabNode().updateFromJSON(serializedTabNode);
      }
      setTextContent(text) {
        if (!(text === "	" || text === "")) {
          formatDevErrorMessage(`TabNode does not support setTextContent`);
        }
        return super.setTextContent("	");
      }
      spliceText(offset, delCount, newText, moveSelection) {
        if (!(newText === "" && delCount === 0 || newText === "	" && delCount === 1)) {
          formatDevErrorMessage(`TabNode does not support spliceText`);
        }
        return this;
      }
      setDetail(detail) {
        if (!(detail === IS_UNMERGEABLE)) {
          formatDevErrorMessage(`TabNode does not support setDetail`);
        }
        return this;
      }
      setMode(type) {
        if (!(type === "normal")) {
          formatDevErrorMessage(`TabNode does not support setMode`);
        }
        return this;
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
    };
    Point = class {
      constructor(key2, offset, type) {
        {
          Object.defineProperty(this, "_selection", {
            enumerable: false,
            writable: true
          });
        }
        this._selection = null;
        this.key = key2;
        this.offset = offset;
        this.type = type;
      }
      is(point) {
        return this.key === point.key && this.offset === point.offset && this.type === point.type;
      }
      isBefore(b3) {
        if (this.key === b3.key) {
          return this.offset < b3.offset;
        }
        const aCaret = $normalizeCaret($caretFromPoint(this, "next"));
        const bCaret = $normalizeCaret($caretFromPoint(b3, "next"));
        return $comparePointCaretNext(aCaret, bCaret) < 0;
      }
      getNode() {
        const key2 = this.key;
        const node = $getNodeByKey(key2);
        if (node === null) {
          {
            formatDevErrorMessage(`Point.getNode: node not found`);
          }
        }
        return node;
      }
      set(key2, offset, type, onlyIfChanged) {
        const selection = this._selection;
        const oldKey = this.key;
        if (onlyIfChanged && this.key === key2 && this.offset === offset && this.type === type) {
          return;
        }
        this.key = key2;
        this.offset = offset;
        this.type = type;
        {
          const node = $getNodeByKey(key2);
          if (!(type === "text" ? $isTextNode(node) : $isElementNode(node))) {
            formatDevErrorMessage(`PointType.set: node with key ${key2} is ${node ? node.__type : "[not found]"} and can not be used for a ${type} point`);
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          if ($getCompositionKey() === oldKey) {
            $setCompositionKey(key2);
          }
          if (selection !== null) {
            selection.setCachedNodes(null);
            selection.dirty = true;
          }
        }
      }
    };
    NodeSelection = class _NodeSelection {
      constructor(objects) {
        this._cachedNodes = null;
        this._nodes = objects;
        this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(nodes) {
        this._cachedNodes = nodes;
      }
      is(selection) {
        if (!$isNodeSelection(selection)) {
          return false;
        }
        const a2 = this._nodes;
        const b3 = selection._nodes;
        return a2.size === b3.size && Array.from(a2).every((key2) => b3.has(key2));
      }
      isCollapsed() {
        return false;
      }
      isBackward() {
        return false;
      }
      getStartEndPoints() {
        return null;
      }
      add(key2) {
        this.dirty = true;
        this._nodes.add(key2);
        this._cachedNodes = null;
      }
      delete(key2) {
        this.dirty = true;
        this._nodes.delete(key2);
        this._cachedNodes = null;
      }
      clear() {
        this.dirty = true;
        this._nodes.clear();
        this._cachedNodes = null;
      }
      has(key2) {
        return this._nodes.has(key2);
      }
      clone() {
        return new _NodeSelection(new Set(this._nodes));
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text) {
      }
      insertText() {
      }
      insertNodes(nodes) {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
        let selectionAtEnd;
        if ($isTextNode(lastSelectedNode)) {
          selectionAtEnd = lastSelectedNode.select();
        } else {
          const index = lastSelectedNode.getIndexWithinParent() + 1;
          selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);
        }
        selectionAtEnd.insertNodes(nodes);
        for (let i2 = 0; i2 < selectedNodesLength; i2++) {
          selectedNodes[i2].remove();
        }
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const objects = this._nodes;
        const nodes = [];
        for (const object of objects) {
          const node = $getNodeByKey(object);
          if (node !== null) {
            nodes.push(node);
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes();
        let textContent2 = "";
        for (let i2 = 0; i2 < nodes.length; i2++) {
          textContent2 += nodes[i2].getTextContent();
        }
        return textContent2;
      }
      /**
       * Remove all nodes in the NodeSelection. If there were any nodes,
       * replace the selection with a new RangeSelection at the previous
       * location of the first node.
       */
      deleteNodes() {
        const nodes = this.getNodes();
        if (($getSelection() || $getPreviousSelection()) === this && nodes[0]) {
          const firstCaret = $getSiblingCaret(nodes[0], "next");
          $setSelectionFromCaretRange($getCaretRange(firstCaret, firstCaret));
        }
        for (const node of nodes) {
          node.remove();
        }
      }
    };
    RangeSelection = class _RangeSelection {
      constructor(anchor, focus, format, style) {
        this.anchor = anchor;
        this.focus = focus;
        anchor._selection = this;
        focus._selection = this;
        this._cachedNodes = null;
        this.format = format;
        this.style = style;
        this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(nodes) {
        this._cachedNodes = nodes;
      }
      /**
       * Used to check if the provided selections is equal to this one by value,
       * including anchor, focus, format, and style properties.
       * @param selection - the Selection to compare this one to.
       * @returns true if the Selections are equal, false otherwise.
       */
      is(selection) {
        if (!$isRangeSelection(selection)) {
          return false;
        }
        return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
      }
      /**
       * Returns whether the Selection is "collapsed", meaning the anchor and focus are
       * the same node and have the same offset.
       *
       * @returns true if the Selection is collapsed, false otherwise.
       */
      isCollapsed() {
        return this.anchor.is(this.focus);
      }
      /**
       * Gets all the nodes in the Selection. Uses caching to make it generally suitable
       * for use in hot paths.
       *
       * See also the {@link CaretRange} APIs (starting with
       * {@link $caretRangeFromSelection}), which are likely to provide a better
       * foundation for any operation where partial selection is relevant
       * (e.g. the anchor or focus are inside an ElementNode and TextNode)
       *
       * @returns an Array containing all the nodes in the Selection
       */
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const range = $getCaretRangeInDirection($caretRangeFromSelection(this), "next");
        const nodes = $getNodesFromCaretRangeCompat(range);
        {
          if (this.isCollapsed() && nodes.length > 1) {
            {
              formatDevErrorMessage(`RangeSelection.getNodes() returned ${String(nodes.length)} > 1 nodes in a collapsed selection`);
            }
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      /**
       * Sets this Selection to be of type "text" at the provided anchor and focus values.
       *
       * @param anchorNode - the anchor node to set on the Selection
       * @param anchorOffset - the offset to set on the Selection
       * @param focusNode - the focus node to set on the Selection
       * @param focusOffset - the focus offset to set on the Selection
       */
      setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchor.set(anchorNode.__key, anchorOffset, "text");
        this.focus.set(focusNode.__key, focusOffset, "text");
      }
      /**
       * Gets the (plain) text content of all the nodes in the selection.
       *
       * @returns a string representing the text content of all the nodes in the Selection
       */
      getTextContent() {
        const nodes = this.getNodes();
        if (nodes.length === 0) {
          return "";
        }
        const firstNode = nodes[0];
        const lastNode = nodes[nodes.length - 1];
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = anchor.isBefore(focus);
        const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
        let textContent2 = "";
        let prevWasElement = true;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if ($isElementNode(node) && !node.isInline()) {
            if (!prevWasElement) {
              textContent2 += "\n";
            }
            if (node.isEmpty()) {
              prevWasElement = false;
            } else {
              prevWasElement = true;
            }
          } else {
            prevWasElement = false;
            if ($isTextNode(node)) {
              let text = node.getTextContent();
              if (node === firstNode) {
                if (node === lastNode) {
                  if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                    text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);
                  }
                } else {
                  text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);
                }
              } else if (node === lastNode) {
                text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);
              }
              textContent2 += text;
            } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
              textContent2 += node.getTextContent();
            }
          }
        }
        return textContent2;
      }
      /**
       * Attempts to map a DOM selection range onto this Lexical Selection,
       * setting the anchor, focus, and type accordingly
       *
       * @param range a DOM Selection range conforming to the StaticRange interface.
       */
      applyDOMRange(range) {
        const editor = getActiveEditor();
        const currentEditorState = editor.getEditorState();
        const lastSelection = currentEditorState._selection;
        const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);
        if (resolvedSelectionPoints === null) {
          return;
        }
        const [anchorPoint, focusPoint] = resolvedSelectionPoints;
        this.anchor.set(anchorPoint.key, anchorPoint.offset, anchorPoint.type, true);
        this.focus.set(focusPoint.key, focusPoint.offset, focusPoint.type, true);
        $normalizeSelection(this);
      }
      /**
       * Creates a new RangeSelection, copying over all the property values from this one.
       *
       * @returns a new RangeSelection with the same property values as this one.
       */
      clone() {
        const anchor = this.anchor;
        const focus = this.focus;
        const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
        return selection;
      }
      /**
       * Toggles the provided format on all the TextNodes in the Selection.
       *
       * @param format a string TextFormatType to toggle on the TextNodes in the selection
       */
      toggleFormat(format) {
        this.format = toggleTextFormatType(this.format, format, null);
        this.dirty = true;
      }
      /**
       * Sets the value of the style property on the Selection
       *
       * @param style - the style to set at the value of the style property.
       */
      setStyle(style) {
        this.style = style;
        this.dirty = true;
      }
      /**
       * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
       * has the specified format.
       *
       * @param type the TextFormatType to check for.
       * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
       */
      hasFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.format & formatFlag) !== 0;
      }
      /**
       * Attempts to insert the provided text into the EditorState at the current Selection.
       * converts tabs, newlines, and carriage returns into LexicalNodes.
       *
       * @param text the text to insert into the Selection
       */
      insertRawText(text) {
        const parts = text.split(/(\r?\n|\t)/);
        const nodes = [];
        const length = parts.length;
        for (let i2 = 0; i2 < length; i2++) {
          const part = parts[i2];
          if (part === "\n" || part === "\r\n") {
            nodes.push($createLineBreakNode());
          } else if (part === "	") {
            nodes.push($createTabNode());
          } else {
            nodes.push($createTextNode(part));
          }
        }
        this.insertNodes(nodes);
      }
      /**
       * Insert the provided text into the EditorState at the current Selection.
       *
       * @param text the text to insert into the Selection
       */
      insertText(text) {
        const anchor = this.anchor;
        const focus = this.focus;
        const format = this.format;
        const style = this.style;
        let firstPoint = anchor;
        let endPoint = focus;
        if (!this.isCollapsed() && focus.isBefore(anchor)) {
          firstPoint = focus;
          endPoint = anchor;
        }
        if (firstPoint.type === "element") {
          $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);
        }
        if (endPoint.type === "element") {
          $setPointFromCaret(endPoint, $normalizeCaret($caretFromPoint(endPoint, "next")));
        }
        const startOffset = firstPoint.offset;
        let endOffset = endPoint.offset;
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        let firstNode = selectedNodes[0];
        if (!$isTextNode(firstNode)) {
          {
            formatDevErrorMessage(`insertText: first node is not a text node`);
          }
        }
        const firstNodeText = firstNode.getTextContent();
        const firstNodeTextLength = firstNodeText.length;
        const firstNodeParent = firstNode.getParentOrThrow();
        const lastIndex = selectedNodesLength - 1;
        let lastNode = selectedNodes[lastIndex];
        if (selectedNodesLength === 1 && endPoint.type === "element") {
          endOffset = firstNodeTextLength;
          endPoint.set(firstPoint.key, endOffset, "text");
        }
        if (this.isCollapsed() && startOffset === firstNodeTextLength && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
          let nextSibling2 = firstNode.getNextSibling();
          if (!$isTextNode(nextSibling2) || !nextSibling2.canInsertTextBefore() || $isTokenOrSegmented(nextSibling2)) {
            nextSibling2 = $createTextNode();
            nextSibling2.setFormat(format);
            nextSibling2.setStyle(style);
            if (!firstNodeParent.canInsertTextAfter()) {
              firstNodeParent.insertAfter(nextSibling2);
            } else {
              firstNode.insertAfter(nextSibling2);
            }
          }
          nextSibling2.select(0, 0);
          firstNode = nextSibling2;
          if (text !== "") {
            this.insertText(text);
            return;
          }
        } else if (this.isCollapsed() && startOffset === 0 && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
          let prevSibling = firstNode.getPreviousSibling();
          if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
            prevSibling = $createTextNode();
            prevSibling.setFormat(format);
            if (!firstNodeParent.canInsertTextBefore()) {
              firstNodeParent.insertBefore(prevSibling);
            } else {
              firstNode.insertBefore(prevSibling);
            }
          }
          prevSibling.select();
          firstNode = prevSibling;
          if (text !== "") {
            this.insertText(text);
            return;
          }
        } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
          const textNode = $createTextNode(firstNode.getTextContent());
          textNode.setFormat(format);
          firstNode.replace(textNode);
          firstNode = textNode;
        } else if (!this.isCollapsed() && text !== "") {
          const lastNodeParent = lastNode.getParent();
          if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
            this.insertText("");
            $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
            this.insertText(text);
            return;
          }
        }
        if (selectedNodesLength === 1) {
          if ($isTokenOrTab(firstNode)) {
            const textNode = $createTextNode(text);
            textNode.select();
            firstNode.replace(textNode);
            return;
          }
          const firstNodeFormat = firstNode.getFormat();
          const firstNodeStyle = firstNode.getStyle();
          if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
            if (firstNode.getTextContent() === "") {
              firstNode.setFormat(format);
              firstNode.setStyle(style);
            } else {
              const textNode = $createTextNode(text);
              textNode.setFormat(format);
              textNode.setStyle(style);
              textNode.select();
              if (startOffset === 0) {
                firstNode.insertBefore(textNode, false);
              } else {
                const [targetNode] = firstNode.splitText(startOffset);
                targetNode.insertAfter(textNode, false);
              }
              if (textNode.isComposing() && this.anchor.type === "text") {
                this.anchor.offset -= text.length;
              }
              return;
            }
          } else if ($isTabNode(firstNode)) {
            const textNode = $createTextNode(text);
            textNode.setFormat(format);
            textNode.setStyle(style);
            textNode.select();
            firstNode.replace(textNode);
            return;
          }
          const delCount = endOffset - startOffset;
          firstNode = firstNode.spliceText(startOffset, delCount, text, true);
          if (firstNode.getTextContent() === "") {
            firstNode.remove();
          } else if (this.anchor.type === "text") {
            if (firstNode.isComposing()) {
              this.anchor.offset -= text.length;
            } else {
              this.format = firstNodeFormat;
              this.style = firstNodeStyle;
            }
          }
        } else {
          const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
          const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
          let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
          let lastElementChild = lastNode;
          if (!firstElement.is(lastElement) && lastElement.isInline()) {
            do {
              lastElementChild = lastElement;
              lastElement = lastElement.getParentOrThrow();
            } while (lastElement.isInline());
          }
          if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
            if ($isTextNode(lastNode) && !$isTokenOrTab(lastNode) && endOffset !== lastNode.getTextContentSize()) {
              if (lastNode.isSegmented()) {
                const textNode = $createTextNode(lastNode.getTextContent());
                lastNode.replace(textNode);
                lastNode = textNode;
              }
              if (!$isRootNode(endPoint.getNode()) && endPoint.type === "text") {
                lastNode = lastNode.spliceText(0, endOffset, "");
              }
              markedNodeKeysForKeep.add(lastNode.__key);
            } else {
              const lastNodeParent = lastNode.getParentOrThrow();
              if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
                lastNodeParent.remove();
              } else {
                lastNode.remove();
              }
            }
          } else {
            markedNodeKeysForKeep.add(lastNode.__key);
          }
          const lastNodeChildren = lastElement.getChildren();
          const selectedNodesSet = new Set(selectedNodes);
          const firstAndLastElementsAreEqual = firstElement.is(lastElement);
          const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
          for (let i2 = lastNodeChildren.length - 1; i2 >= 0; i2--) {
            const lastNodeChild = lastNodeChildren[i2];
            if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
              break;
            }
            if (lastNodeChild.isAttached()) {
              if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
                if (!firstAndLastElementsAreEqual) {
                  insertionTarget.insertAfter(lastNodeChild, false);
                }
              } else {
                lastNodeChild.remove();
              }
            }
          }
          if (!firstAndLastElementsAreEqual) {
            let parent = lastElement;
            let lastRemovedParent = null;
            while (parent !== null) {
              const children = parent.getChildren();
              const childrenLength = children.length;
              if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
                markedNodeKeysForKeep.delete(parent.__key);
                lastRemovedParent = parent;
              }
              parent = parent.getParent();
            }
          }
          if (!$isTokenOrTab(firstNode)) {
            firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);
            if (firstNode.getTextContent() === "") {
              firstNode.remove();
            } else if (firstNode.isComposing() && this.anchor.type === "text") {
              this.anchor.offset -= text.length;
            }
          } else if (startOffset === firstNodeTextLength) {
            firstNode.select();
          } else {
            const textNode = $createTextNode(text);
            textNode.select();
            firstNode.replace(textNode);
          }
          for (let i2 = 1; i2 < selectedNodesLength; i2++) {
            const selectedNode = selectedNodes[i2];
            const key2 = selectedNode.__key;
            if (!markedNodeKeysForKeep.has(key2)) {
              selectedNode.remove();
            }
          }
        }
      }
      /**
       * Removes the text in the Selection, adjusting the EditorState accordingly.
       */
      removeText() {
        const isCurrentSelection = $getSelection() === this;
        const newRange = $removeTextFromCaretRange($caretRangeFromSelection(this));
        $updateRangeSelectionFromCaretRange(this, newRange);
        if (isCurrentSelection && $getSelection() !== this) {
          $setSelection(this);
        }
      }
      // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)
      /**
       * Applies the provided format to the TextNodes in the Selection, splitting or
       * merging nodes as necessary.
       *
       * @param formatType the format type to apply to the nodes in the Selection.
       * @param alignWithFormat a 32-bit integer representing formatting flags to align with.
       */
      formatText(formatType, alignWithFormat = null) {
        if (this.isCollapsed()) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const selectedNodes = this.getNodes();
        const selectedTextNodes = [];
        for (const selectedNode of selectedNodes) {
          if ($isTextNode(selectedNode)) {
            selectedTextNodes.push(selectedNode);
          }
        }
        const applyFormatToElements = (alignWith) => {
          selectedNodes.forEach((node) => {
            if ($isElementNode(node)) {
              const newFormat = node.getFormatFlags(formatType, alignWith);
              node.setTextFormat(newFormat);
            }
          });
        };
        const selectedTextNodesLength = selectedTextNodes.length;
        if (selectedTextNodesLength === 0) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          applyFormatToElements(alignWithFormat);
          return;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        const isBackward = this.isBackward();
        const startPoint = isBackward ? focus : anchor;
        const endPoint = isBackward ? anchor : focus;
        let firstIndex = 0;
        let firstNode = selectedTextNodes[0];
        let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
        if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
          firstIndex = 1;
          firstNode = selectedTextNodes[1];
          startOffset = 0;
        }
        if (firstNode == null) {
          return;
        }
        const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);
        applyFormatToElements(firstNextFormat);
        const lastIndex = selectedTextNodesLength - 1;
        let lastNode = selectedTextNodes[lastIndex];
        const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
        if (firstNode.is(lastNode)) {
          if (startOffset === endOffset) {
            return;
          }
          if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
            firstNode.setFormat(firstNextFormat);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            replacement.setFormat(firstNextFormat);
            if (startPoint.type === "text") {
              startPoint.set(replacement.__key, 0, "text");
            }
            if (endPoint.type === "text") {
              endPoint.set(replacement.__key, endOffset - startOffset, "text");
            }
          }
          this.format = firstNextFormat;
          return;
        }
        if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {
          [, firstNode] = firstNode.splitText(startOffset);
          startOffset = 0;
        }
        firstNode.setFormat(firstNextFormat);
        const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
        if (endOffset > 0) {
          if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          lastNode.setFormat(lastNextFormat);
        }
        for (let i2 = firstIndex + 1; i2 < lastIndex; i2++) {
          const textNode = selectedTextNodes[i2];
          const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
          textNode.setFormat(nextFormat);
        }
        if (startPoint.type === "text") {
          startPoint.set(firstNode.__key, startOffset, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(lastNode.__key, endOffset, "text");
        }
        this.format = firstNextFormat | lastNextFormat;
      }
      /**
       * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
       * current Selection according to a set of heuristics that determine how surrounding nodes
       * should be changed, replaced, or moved to accommodate the incoming ones.
       *
       * @param nodes - the nodes to insert
       */
      insertNodes(nodes) {
        if (nodes.length === 0) {
          return;
        }
        if (!this.isCollapsed()) {
          this.removeText();
        }
        if (this.anchor.key === "root") {
          this.insertParagraph();
          const selection = $getSelection();
          if (!$isRangeSelection(selection)) {
            formatDevErrorMessage(`Expected RangeSelection after insertParagraph`);
          }
          return selection.insertNodes(nodes);
        }
        const firstPoint = this.isBackward() ? this.focus : this.anchor;
        const firstNode = firstPoint.getNode();
        const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);
        const last = nodes[nodes.length - 1];
        if ($isElementNode(firstBlock) && "__language" in firstBlock) {
          if ("__language" in nodes[0]) {
            this.insertText(nodes[0].getTextContent());
          } else {
            const index = $removeTextAndSplitBlock(this);
            firstBlock.splice(index, 0, nodes);
            last.selectEnd();
          }
          return;
        }
        const notInline = (node) => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();
        if (!nodes.some(notInline)) {
          if (!$isElementNode(firstBlock)) {
            formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
          }
          const index = $removeTextAndSplitBlock(this);
          firstBlock.splice(index, 0, nodes);
          last.selectEnd();
          return;
        }
        const blocksParent = $wrapInlineNodes(nodes);
        const nodeToSelect = blocksParent.getLastDescendant();
        const blocks = blocksParent.getChildren();
        const isMergeable = (node) => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());
        const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();
        const insertedParagraph = shouldInsert ? this.insertParagraph() : null;
        const lastToInsert = blocks[blocks.length - 1];
        let firstToInsert = blocks[0];
        if (isMergeable(firstToInsert)) {
          if (!$isElementNode(firstBlock)) {
            formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
          }
          firstBlock.append(...firstToInsert.getChildren());
          firstToInsert = blocks[1];
        }
        if (firstToInsert) {
          if (!(firstBlock !== null)) {
            formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);
          }
          insertRangeAfter(firstBlock, firstToInsert);
        }
        const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);
        if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {
          lastInsertedBlock.append(...insertedParagraph.getChildren());
          insertedParagraph.remove();
        }
        if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {
          firstBlock.remove();
        }
        nodeToSelect.selectEnd();
        const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;
        if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {
          lastChild.remove();
        }
      }
      /**
       * Inserts a new ParagraphNode into the EditorState at the current Selection
       *
       * @returns the newly inserted node.
       */
      insertParagraph() {
        if (this.anchor.key === "root") {
          const paragraph = $createParagraphNode();
          $getRoot().splice(this.anchor.offset, 0, [paragraph]);
          paragraph.select();
          return paragraph;
        }
        const index = $removeTextAndSplitBlock(this);
        const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);
        if (!$isElementNode(block)) {
          formatDevErrorMessage(`Expected ancestor to be a block ElementNode`);
        }
        const firstToAppend = block.getChildAtIndex(index);
        const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];
        const newBlock = block.insertNewAfter(this, false);
        if (newBlock) {
          newBlock.append(...nodesToInsert);
          newBlock.selectStart();
          return newBlock;
        }
        return null;
      }
      /**
       * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
       * current Selection.
       */
      insertLineBreak(selectStart) {
        const lineBreak = $createLineBreakNode();
        this.insertNodes([lineBreak]);
        if (selectStart) {
          const parent = lineBreak.getParentOrThrow();
          const index = lineBreak.getIndexWithinParent();
          parent.select(index, index);
        }
      }
      /**
       * Extracts the nodes in the Selection, splitting nodes where necessary
       * to get offset-level precision.
       *
       * @returns The nodes in the Selection
       */
      extract() {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastIndex = selectedNodesLength - 1;
        const anchor = this.anchor;
        const focus = this.focus;
        let firstNode = selectedNodes[0];
        let lastNode = selectedNodes[lastIndex];
        const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
        if (selectedNodesLength === 0) {
          return [];
        } else if (selectedNodesLength === 1) {
          if ($isTextNode(firstNode) && !this.isCollapsed()) {
            const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            return node != null ? [node] : [];
          }
          return [firstNode];
        }
        const isBefore = anchor.isBefore(focus);
        if ($isTextNode(firstNode)) {
          const startOffset = isBefore ? anchorOffset : focusOffset;
          if (startOffset === firstNode.getTextContentSize()) {
            selectedNodes.shift();
          } else if (startOffset !== 0) {
            [, firstNode] = firstNode.splitText(startOffset);
            selectedNodes[0] = firstNode;
          }
        }
        if ($isTextNode(lastNode)) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          const endOffset = isBefore ? focusOffset : anchorOffset;
          if (endOffset === 0) {
            selectedNodes.pop();
          } else if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
            selectedNodes[lastIndex] = lastNode;
          }
        }
        return selectedNodes;
      }
      /**
       * Modifies the Selection according to the parameters and a set of heuristics that account for
       * various node types. Can be used to safely move or extend selection by one logical "unit" without
       * dealing explicitly with all the possible node types.
       *
       * @param alter the type of modification to perform
       * @param isBackward whether or not selection is backwards
       * @param granularity the granularity at which to apply the modification
       */
      modify(alter, isBackward, granularity) {
        if ($modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity)) {
          return;
        }
        const collapse = alter === "move";
        const editor = getActiveEditor();
        const domSelection = getDOMSelection(getWindow(editor));
        if (!domSelection) {
          return;
        }
        const blockCursorElement = editor._blockCursorElement;
        const rootElement = editor._rootElement;
        const focusNode = this.focus.getNode();
        if (rootElement !== null && blockCursorElement !== null && $isElementNode(focusNode) && !focusNode.isInline() && !focusNode.canBeEmpty()) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        if (this.dirty) {
          let nextAnchorDOM = getElementByKeyOrThrow(editor, this.anchor.key);
          let nextFocusDOM = getElementByKeyOrThrow(editor, this.focus.key);
          if (this.anchor.type === "text") {
            nextAnchorDOM = getDOMTextNode(nextAnchorDOM);
          }
          if (this.focus.type === "text") {
            nextFocusDOM = getDOMTextNode(nextFocusDOM);
          }
          if (nextAnchorDOM && nextFocusDOM) {
            setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, this.anchor.offset, nextFocusDOM, this.focus.offset);
          }
        }
        moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
        if (domSelection.rangeCount > 0) {
          const range = domSelection.getRangeAt(0);
          const anchorNode = this.anchor.getNode();
          const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
          this.applyDOMRange(range);
          this.dirty = true;
          if (!collapse) {
            const nodes = this.getNodes();
            const validNodes = [];
            let shrinkSelection = false;
            for (let i2 = 0; i2 < nodes.length; i2++) {
              const nextNode = nodes[i2];
              if ($hasAncestor(nextNode, root)) {
                validNodes.push(nextNode);
              } else {
                shrinkSelection = true;
              }
            }
            if (shrinkSelection && validNodes.length > 0) {
              if (isBackward) {
                const firstValidNode = validNodes[0];
                if ($isElementNode(firstValidNode)) {
                  firstValidNode.selectStart();
                } else {
                  firstValidNode.getParentOrThrow().selectStart();
                }
              } else {
                const lastValidNode = validNodes[validNodes.length - 1];
                if ($isElementNode(lastValidNode)) {
                  lastValidNode.selectEnd();
                } else {
                  lastValidNode.getParentOrThrow().selectEnd();
                }
              }
            }
            if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
              $swapPoints(this);
            }
          }
        }
        if (granularity === "lineboundary") {
          $modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity, "decorators");
        }
      }
      /**
       * Helper for handling forward character and word deletion that prevents element nodes
       * like a table, columns layout being destroyed
       *
       * @param anchor the anchor
       * @param anchorNode the anchor node in the selection
       * @param isBackward whether or not selection is backwards
       */
      forwardDeletion(anchor, anchorNode, isBackward) {
        if (!isBackward && // Delete forward handle case
        (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
          const parent = anchorNode.getParent();
          const nextSibling2 = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
          if ($isElementNode(nextSibling2) && nextSibling2.isShadowRoot()) {
            return true;
          }
        }
        return false;
      }
      /**
       * Performs one logical character deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteCharacter(isBackward) {
        const wasCollapsed = this.isCollapsed();
        if (this.isCollapsed()) {
          const anchor = this.anchor;
          let anchorNode = anchor.getNode();
          if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
            return;
          }
          const direction = isBackward ? "previous" : "next";
          const initialCaret = $caretFromPoint(anchor, direction);
          const initialRange = $extendCaretToRange(initialCaret);
          if (initialRange.getTextSlices().every((slice) => slice === null || slice.distance === 0)) {
            let state = {
              type: "initial"
            };
            for (const caret of initialRange.iterNodeCarets("shadowRoot")) {
              if ($isChildCaret(caret)) {
                if (caret.origin.isInline()) ;
                else if (caret.origin.isShadowRoot()) {
                  if (state.type === "merge-block") {
                    break;
                  }
                  if ($isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {
                    const normCaret = $normalizeCaret(caret);
                    $updateRangeSelectionFromCaretRange(this, $getCaretRange(normCaret, normCaret));
                    initialRange.anchor.origin.remove();
                  }
                  return;
                } else if (state.type === "merge-next-block" || state.type === "merge-block") {
                  state = {
                    block: state.block,
                    caret,
                    type: "merge-block"
                  };
                }
              } else if (state.type === "merge-block") {
                break;
              } else if ($isSiblingCaret(caret)) {
                if ($isElementNode(caret.origin)) {
                  if (!caret.origin.isInline()) {
                    state = {
                      block: caret.origin,
                      type: "merge-next-block"
                    };
                  } else if (!caret.origin.isParentOf(initialRange.anchor.origin)) {
                    break;
                  }
                  continue;
                } else if ($isDecoratorNode(caret.origin)) {
                  if (caret.origin.isIsolated()) ;
                  else if (state.type === "merge-next-block" && (caret.origin.isKeyboardSelectable() || !caret.origin.isInline()) && $isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {
                    initialRange.anchor.origin.remove();
                    const nodeSelection = $createNodeSelection();
                    nodeSelection.add(caret.origin.getKey());
                    $setSelection(nodeSelection);
                  } else {
                    caret.origin.remove();
                  }
                  return;
                }
                break;
              }
            }
            if (state.type === "merge-block") {
              const {
                caret,
                block
              } = state;
              $updateRangeSelectionFromCaretRange(this, $getCaretRange(!caret.origin.isEmpty() && block.isEmpty() ? $rewindSiblingCaret($getSiblingCaret(block, caret.direction)) : initialRange.anchor, caret));
              return this.removeText();
            }
          }
          const focus = this.focus;
          this.modify("extend", isBackward, "character");
          if (!this.isCollapsed()) {
            const focusNode = focus.type === "text" ? focus.getNode() : null;
            anchorNode = anchor.type === "text" ? anchor.getNode() : null;
            if (focusNode !== null && focusNode.isSegmented()) {
              const offset = focus.offset;
              const textContentSize = focusNode.getTextContentSize();
              if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
                $removeSegment(focusNode, isBackward, offset);
                return;
              }
            } else if (anchorNode !== null && anchorNode.isSegmented()) {
              const offset = anchor.offset;
              const textContentSize = anchorNode.getTextContentSize();
              if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
                $removeSegment(anchorNode, isBackward, offset);
                return;
              }
            }
            $updateCaretSelectionForUnicodeCharacter(this, isBackward);
          } else if (isBackward && anchor.offset === 0) {
            if ($collapseAtStart(this, anchor.getNode())) {
              return;
            }
          }
        }
        this.removeText();
        if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
          const anchorNode = this.anchor.getNode();
          if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getPreviousSibling() === null) {
            $collapseAtStart(this, anchorNode);
          }
        }
      }
      /**
       * Performs one logical line deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteLine(isBackward) {
        if (this.isCollapsed()) {
          this.modify("extend", isBackward, "lineboundary");
        }
        if (this.isCollapsed()) {
          this.deleteCharacter(isBackward);
        } else {
          this.removeText();
        }
      }
      /**
       * Performs one logical word deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteWord(isBackward) {
        if (this.isCollapsed()) {
          const anchor = this.anchor;
          const anchorNode = anchor.getNode();
          if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
            return;
          }
          this.modify("extend", isBackward, "word");
        }
        this.removeText();
      }
      /**
       * Returns whether the Selection is "backwards", meaning the focus
       * logically precedes the anchor in the EditorState.
       * @returns true if the Selection is backwards, false otherwise.
       */
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getStartEndPoints() {
        return [this.anchor, this.focus];
      }
    };
    doesContainEmoji = (() => {
      try {
        const re2 = new RegExp("\\p{Emoji}", "u");
        const test = re2.test.bind(re2);
        if (
          // Emoji in the BMP (heart) with variation selector
          test("\u2764\uFE0F") && // Emoji in the BMP (#) with variation selector
          test("#\uFE0F\u20E3") && // Emoji outside the BMP (thumbs up) that is encoded with a surrogate pair
          test("\u{1F44D}")
        ) {
          return test;
        }
      } catch (e2) {
      }
      return () => false;
    })();
    activeEditorState = null;
    activeEditor = null;
    isReadOnlyMode = false;
    isAttemptingToRecoverFromReconcilerError = false;
    infiniteTransformCount = 0;
    observerOptions = {
      characterData: true,
      childList: true,
      subtree: true
    };
    ElementDOMSlot = class _ElementDOMSlot {
      constructor(element, before2, after2) {
        this.element = element;
        this.before = before2 || null;
        this.after = after2 || null;
      }
      /**
       * Return a new ElementDOMSlot where all managed children will be inserted before this node
       */
      withBefore(before2) {
        return new _ElementDOMSlot(this.element, before2, this.after);
      }
      /**
       * Return a new ElementDOMSlot where all managed children will be inserted after this node
       */
      withAfter(after2) {
        return new _ElementDOMSlot(this.element, this.before, after2);
      }
      /**
       * Return a new ElementDOMSlot with an updated root element
       */
      withElement(element) {
        if (this.element === element) {
          return this;
        }
        return new _ElementDOMSlot(element, this.before, this.after);
      }
      /**
       * Insert the given child before this.before and any reconciler managed line break node,
       * or append it if this.before is not defined
       */
      insertChild(dom2) {
        const before2 = this.before || this.getManagedLineBreak();
        if (!(before2 === null || before2.parentElement === this.element)) {
          formatDevErrorMessage(`ElementDOMSlot.insertChild: before is not in element`);
        }
        this.element.insertBefore(dom2, before2);
        return this;
      }
      /**
       * Remove the managed child from this container, will throw if it was not already there
       */
      removeChild(dom2) {
        if (!(dom2.parentElement === this.element)) {
          formatDevErrorMessage(`ElementDOMSlot.removeChild: dom is not in element`);
        }
        this.element.removeChild(dom2);
        return this;
      }
      /**
       * Replace managed child prevDom with dom. Will throw if prevDom is not a child
       *
       * @param dom The new node to replace prevDom
       * @param prevDom the node that will be replaced
       */
      replaceChild(dom2, prevDom) {
        if (!(prevDom.parentElement === this.element)) {
          formatDevErrorMessage(`ElementDOMSlot.replaceChild: prevDom is not in element`);
        }
        this.element.replaceChild(dom2, prevDom);
        return this;
      }
      /**
       * Returns the first managed child of this node,
       * which will either be this.after.nextSibling or this.element.firstChild,
       * and will never be this.before if it is defined.
       */
      getFirstChild() {
        const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;
        return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;
      }
      /**
       * @internal
       */
      getManagedLineBreak() {
        const element = this.element;
        return element.__lexicalLineBreak || null;
      }
      /** @internal */
      setManagedLineBreak(lineBreakType) {
        if (lineBreakType === null) {
          this.removeManagedLineBreak();
        } else {
          const webkitHack = lineBreakType === "decorator" && (IS_IOS || IS_SAFARI);
          this.insertManagedLineBreak(webkitHack);
        }
      }
      /** @internal */
      removeManagedLineBreak() {
        const br2 = this.getManagedLineBreak();
        if (br2) {
          const element = this.element;
          const sibling = br2.nodeName === "IMG" ? br2.nextSibling : null;
          if (sibling) {
            element.removeChild(sibling);
          }
          element.removeChild(br2);
          element.__lexicalLineBreak = void 0;
        }
      }
      /** @internal */
      insertManagedLineBreak(webkitHack) {
        const prevBreak = this.getManagedLineBreak();
        if (prevBreak) {
          if (webkitHack === (prevBreak.nodeName === "IMG")) {
            return;
          }
          this.removeManagedLineBreak();
        }
        const element = this.element;
        const before2 = this.before;
        const br2 = document.createElement("br");
        element.insertBefore(br2, before2);
        if (webkitHack) {
          const img = document.createElement("img");
          img.setAttribute("data-lexical-linebreak", "true");
          img.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;";
          img.alt = "";
          element.insertBefore(img, br2);
          element.__lexicalLineBreak = img;
        } else {
          element.__lexicalLineBreak = br2;
        }
      }
      /**
       * @internal
       *
       * Returns the offset of the first child
       */
      getFirstChildOffset() {
        let i2 = 0;
        for (let node = this.after; node !== null; node = node.previousSibling) {
          i2++;
        }
        return i2;
      }
      /**
       * @internal
       */
      resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {
        if (initialDOM === this.element) {
          const firstChildOffset = this.getFirstChildOffset();
          return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];
        }
        const initialPath = indexPath(elementDOM, initialDOM);
        initialPath.push(initialOffset);
        const elementPath = indexPath(elementDOM, this.element);
        let offset = element.getIndexWithinParent();
        for (let i2 = 0; i2 < elementPath.length; i2++) {
          const target = initialPath[i2];
          const source = elementPath[i2];
          if (target === void 0 || target < source) {
            break;
          } else if (target > source) {
            offset += 1;
            break;
          }
        }
        return [element.getParentOrThrow(), offset];
      }
    };
    ElementNode = class extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(key2) {
        super(key2);
        this.__first = null;
        this.__last = null;
        this.__size = 0;
        this.__format = 0;
        this.__style = "";
        this.__indent = 0;
        this.__dir = null;
        this.__textFormat = 0;
        this.__textStyle = "";
      }
      afterCloneFrom(prevNode) {
        super.afterCloneFrom(prevNode);
        this.__first = prevNode.__first;
        this.__last = prevNode.__last;
        this.__size = prevNode.__size;
        this.__indent = prevNode.__indent;
        this.__format = prevNode.__format;
        this.__style = prevNode.__style;
        this.__dir = prevNode.__dir;
        this.__textFormat = prevNode.__textFormat;
        this.__textStyle = prevNode.__textStyle;
      }
      getFormat() {
        const self = this.getLatest();
        return self.__format;
      }
      getFormatType() {
        const format = this.getFormat();
        return ELEMENT_FORMAT_TO_TYPE[format] || "";
      }
      getStyle() {
        const self = this.getLatest();
        return self.__style;
      }
      getIndent() {
        const self = this.getLatest();
        return self.__indent;
      }
      getChildren() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenKeys() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child.__key);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenSize() {
        const self = this.getLatest();
        return self.__size;
      }
      isEmpty() {
        return this.getChildrenSize() === 0;
      }
      isDirty() {
        const editor = getActiveEditor();
        const dirtyElements = editor._dirtyElements;
        return dirtyElements !== null && dirtyElements.has(this.__key);
      }
      isLastChild() {
        const self = this.getLatest();
        const parentLastChild = this.getParentOrThrow().getLastChild();
        return parentLastChild !== null && parentLastChild.is(self);
      }
      getAllTextNodes() {
        const textNodes = [];
        let child = this.getFirstChild();
        while (child !== null) {
          if ($isTextNode(child)) {
            textNodes.push(child);
          }
          if ($isElementNode(child)) {
            const subChildrenNodes = child.getAllTextNodes();
            textNodes.push(...subChildrenNodes);
          }
          child = child.getNextSibling();
        }
        return textNodes;
      }
      getFirstDescendant() {
        let node = this.getFirstChild();
        while ($isElementNode(node)) {
          const child = node.getFirstChild();
          if (child === null) {
            break;
          }
          node = child;
        }
        return node;
      }
      getLastDescendant() {
        let node = this.getLastChild();
        while ($isElementNode(node)) {
          const child = node.getLastChild();
          if (child === null) {
            break;
          }
          node = child;
        }
        return node;
      }
      getDescendantByIndex(index) {
        const children = this.getChildren();
        const childrenLength = children.length;
        if (index >= childrenLength) {
          const resolvedNode2 = children[childrenLength - 1];
          return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
        }
        const resolvedNode = children[index];
        return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
      }
      getFirstChild() {
        const self = this.getLatest();
        const firstKey = self.__first;
        return firstKey === null ? null : $getNodeByKey(firstKey);
      }
      getFirstChildOrThrow() {
        const firstChild = this.getFirstChild();
        if (firstChild === null) {
          {
            formatDevErrorMessage(`Expected node ${this.__key} to have a first child.`);
          }
        }
        return firstChild;
      }
      getLastChild() {
        const self = this.getLatest();
        const lastKey = self.__last;
        return lastKey === null ? null : $getNodeByKey(lastKey);
      }
      getLastChildOrThrow() {
        const lastChild = this.getLastChild();
        if (lastChild === null) {
          {
            formatDevErrorMessage(`Expected node ${this.__key} to have a last child.`);
          }
        }
        return lastChild;
      }
      getChildAtIndex(index) {
        const size = this.getChildrenSize();
        let node;
        let i2;
        if (index < size / 2) {
          node = this.getFirstChild();
          i2 = 0;
          while (node !== null && i2 <= index) {
            if (i2 === index) {
              return node;
            }
            node = node.getNextSibling();
            i2++;
          }
          return null;
        }
        node = this.getLastChild();
        i2 = size - 1;
        while (node !== null && i2 >= index) {
          if (i2 === index) {
            return node;
          }
          node = node.getPreviousSibling();
          i2--;
        }
        return null;
      }
      getTextContent() {
        let textContent2 = "";
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i2 = 0; i2 < childrenLength; i2++) {
          const child = children[i2];
          textContent2 += child.getTextContent();
          if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
            textContent2 += DOUBLE_LINE_BREAK;
          }
        }
        return textContent2;
      }
      getTextContentSize() {
        let textContentSize = 0;
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i2 = 0; i2 < childrenLength; i2++) {
          const child = children[i2];
          textContentSize += child.getTextContentSize();
          if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
            textContentSize += DOUBLE_LINE_BREAK.length;
          }
        }
        return textContentSize;
      }
      getDirection() {
        const self = this.getLatest();
        return self.__dir;
      }
      getTextFormat() {
        const self = this.getLatest();
        return self.__textFormat;
      }
      hasFormat(type) {
        if (type !== "") {
          const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
          return (this.getFormat() & formatFlag) !== 0;
        }
        return false;
      }
      hasTextFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.getTextFormat() & formatFlag) !== 0;
      }
      /**
       * Returns the format flags applied to the node as a 32-bit integer.
       *
       * @returns a number representing the TextFormatTypes applied to the node.
       */
      getFormatFlags(type, alignWithFormat) {
        const self = this.getLatest();
        const format = self.__textFormat;
        return toggleTextFormatType(format, type, alignWithFormat);
      }
      getTextStyle() {
        const self = this.getLatest();
        return self.__textStyle;
      }
      // Mutators
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        const selection = $getSelection();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const childrenCount = this.getChildrenSize();
        if (!this.canBeEmpty()) {
          if (_anchorOffset === 0 && _focusOffset === 0) {
            const firstChild = this.getFirstChild();
            if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
              return firstChild.select(0, 0);
            }
          } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
            const lastChild = this.getLastChild();
            if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
              return lastChild.select();
            }
          }
        }
        if (anchorOffset === void 0) {
          anchorOffset = childrenCount;
        }
        if (focusOffset === void 0) {
          focusOffset = childrenCount;
        }
        const key2 = this.__key;
        if (!$isRangeSelection(selection)) {
          return $internalMakeRangeSelection(key2, anchorOffset, key2, focusOffset, "element", "element");
        } else {
          selection.anchor.set(key2, anchorOffset, "element");
          selection.focus.set(key2, focusOffset, "element");
          selection.dirty = true;
        }
        return selection;
      }
      selectStart() {
        const firstNode = this.getFirstDescendant();
        return firstNode ? firstNode.selectStart() : this.select();
      }
      selectEnd() {
        const lastNode = this.getLastDescendant();
        return lastNode ? lastNode.selectEnd() : this.select();
      }
      clear() {
        const writableSelf = this.getWritable();
        const children = this.getChildren();
        children.forEach((child) => child.remove());
        return writableSelf;
      }
      append(...nodesToAppend) {
        return this.splice(this.getChildrenSize(), 0, nodesToAppend);
      }
      setDirection(direction) {
        const self = this.getWritable();
        self.__dir = direction;
        return self;
      }
      setFormat(type) {
        const self = this.getWritable();
        self.__format = type !== "" ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
        return this;
      }
      setStyle(style) {
        const self = this.getWritable();
        self.__style = style || "";
        return this;
      }
      setTextFormat(type) {
        const self = this.getWritable();
        self.__textFormat = type;
        return self;
      }
      setTextStyle(style) {
        const self = this.getWritable();
        self.__textStyle = style;
        return self;
      }
      setIndent(indentLevel) {
        const self = this.getWritable();
        self.__indent = indentLevel;
        return this;
      }
      splice(start, deleteCount, nodesToInsert) {
        const nodesToInsertLength = nodesToInsert.length;
        const oldSize = this.getChildrenSize();
        const writableSelf = this.getWritable();
        if (!(start + deleteCount <= oldSize)) {
          formatDevErrorMessage(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);
        }
        const writableSelfKey = writableSelf.__key;
        const nodesToInsertKeys = [];
        const nodesToRemoveKeys = [];
        const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
        let nodeBeforeRange = null;
        let newSize = oldSize - deleteCount + nodesToInsertLength;
        if (start !== 0) {
          if (start === oldSize) {
            nodeBeforeRange = this.getLastChild();
          } else {
            const node = this.getChildAtIndex(start);
            if (node !== null) {
              nodeBeforeRange = node.getPreviousSibling();
            }
          }
        }
        if (deleteCount > 0) {
          let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
          for (let i2 = 0; i2 < deleteCount; i2++) {
            if (nodeToDelete === null) {
              {
                formatDevErrorMessage(`splice: sibling not found`);
              }
            }
            const nextSibling2 = nodeToDelete.getNextSibling();
            const nodeKeyToDelete = nodeToDelete.__key;
            const writableNodeToDelete = nodeToDelete.getWritable();
            removeFromParent(writableNodeToDelete);
            nodesToRemoveKeys.push(nodeKeyToDelete);
            nodeToDelete = nextSibling2;
          }
        }
        let prevNode = nodeBeforeRange;
        for (let i2 = 0; i2 < nodesToInsertLength; i2++) {
          const nodeToInsert = nodesToInsert[i2];
          if (prevNode !== null && nodeToInsert.is(prevNode)) {
            nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
          }
          const writableNodeToInsert = nodeToInsert.getWritable();
          if (writableNodeToInsert.__parent === writableSelfKey) {
            newSize--;
          }
          removeFromParent(writableNodeToInsert);
          const nodeKeyToInsert = nodeToInsert.__key;
          if (prevNode === null) {
            writableSelf.__first = nodeKeyToInsert;
            writableNodeToInsert.__prev = null;
          } else {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = nodeKeyToInsert;
            writableNodeToInsert.__prev = writablePrevNode.__key;
          }
          if (nodeToInsert.__key === writableSelfKey) {
            {
              formatDevErrorMessage(`append: attempting to append self`);
            }
          }
          writableNodeToInsert.__parent = writableSelfKey;
          nodesToInsertKeys.push(nodeKeyToInsert);
          prevNode = nodeToInsert;
        }
        if (start + deleteCount === oldSize) {
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = null;
            writableSelf.__last = prevNode.__key;
          }
        } else if (nodeAfterRange !== null) {
          const writableNodeAfterRange = nodeAfterRange.getWritable();
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writableNodeAfterRange.__prev = prevNode.__key;
            writablePrevNode.__next = nodeAfterRange.__key;
          } else {
            writableNodeAfterRange.__prev = null;
          }
        }
        writableSelf.__size = newSize;
        if (nodesToRemoveKeys.length) {
          const selection = $getSelection();
          if ($isRangeSelection(selection)) {
            const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
            const nodesToInsertKeySet = new Set(nodesToInsertKeys);
            const {
              anchor,
              focus
            } = selection;
            if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
              this.remove();
            }
          }
        }
        return writableSelf;
      }
      /**
       * @internal
       *
       * An experimental API that an ElementNode can override to control where its
       * children are inserted into the DOM, this is useful to add a wrapping node
       * or accessory nodes before or after the children. The root of the node returned
       * by createDOM must still be exactly one HTMLElement.
       */
      getDOMSlot(element) {
        return new ElementDOMSlot(element);
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (isHTMLElement(element)) {
          const indent = this.getIndent();
          if (indent > 0) {
            element.style.paddingInlineStart = `${indent * 40}px`;
          }
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      // JSON serialization
      exportJSON() {
        const json = {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          // As an exception here we invoke super at the end for historical reasons.
          // Namely, to preserve the order of the properties and not to break the tests
          // that use the serialized string representation.
          ...super.exportJSON()
        };
        const textFormat = this.getTextFormat();
        const textStyle = this.getTextStyle();
        if (textFormat !== 0) {
          json.textFormat = textFormat;
        }
        if (textStyle !== "") {
          json.textStyle = textStyle;
        }
        return json;
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || "");
      }
      // These are intended to be extends for specific element heuristics.
      insertNewAfter(selection, restoreSelection) {
        return null;
      }
      canIndent() {
        return true;
      }
      /*
       * This method controls the behavior of the node during backwards
       * deletion (i.e., backspace) when selection is at the beginning of
       * the node (offset 0). You may use this to have the node replace
       * itself, change its state, or do nothing. When you do make such
       * a change, you should return true.
       *
       * When true is returned, the collapse phase will stop.
       * When false is returned, and isInline() is true, and getPreviousSibling() is null,
       * then this function will be called on its parent.
       */
      collapseAtStart(selection) {
        return false;
      }
      excludeFromCopy(destination) {
        return false;
      }
      /** @deprecated @internal */
      canReplaceWith(replacement) {
        return true;
      }
      /** @deprecated @internal */
      canInsertAfter(node) {
        return true;
      }
      canBeEmpty() {
        return true;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      isInline() {
        return false;
      }
      // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
      // end of the hierarchy, most implementations should treat it as there's nothing (upwards)
      // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
      // will return the immediate first child underneath TableCellNode instead of RootNode.
      isShadowRoot() {
        return false;
      }
      /** @deprecated @internal */
      canMergeWith(node) {
        return false;
      }
      extractWithChild(child, selection, destination) {
        return false;
      }
      /**
       * Determines whether this node, when empty, can merge with a first block
       * of nodes being inserted.
       *
       * This method is specifically called in {@link RangeSelection.insertNodes}
       * to determine merging behavior during nodes insertion.
       *
       * @example
       * // In a ListItemNode or QuoteNode implementation:
       * canMergeWhenEmpty(): true {
       *  return true;
       * }
       */
      canMergeWhenEmpty() {
        return false;
      }
      /** @internal */
      reconcileObservedMutation(dom2, editor) {
        const slot = this.getDOMSlot(dom2);
        let currentDOM = slot.getFirstChild();
        for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {
          const correctDOM = editor.getElementByKey(currentNode.getKey());
          if (correctDOM === null) {
            continue;
          }
          if (currentDOM == null) {
            slot.insertChild(correctDOM);
            currentDOM = correctDOM;
          } else if (currentDOM !== correctDOM) {
            slot.replaceChild(correctDOM, currentDOM);
          }
          currentDOM = currentDOM.nextSibling;
        }
      }
    };
    DecoratorNode = class extends LexicalNode {
      /**
       * The returned value is added to the LexicalEditor._decorators
       */
      decorate(editor, config) {
        {
          formatDevErrorMessage(`decorate: base method not extended`);
        }
      }
      isIsolated() {
        return false;
      }
      isInline() {
        return true;
      }
      isKeyboardSelectable() {
        return true;
      }
    };
    RootNode = class _RootNode extends ElementNode {
      /** @internal */
      static getType() {
        return "root";
      }
      static clone() {
        return new _RootNode();
      }
      constructor() {
        super("root");
        this.__cachedText = null;
      }
      getTopLevelElementOrThrow() {
        {
          formatDevErrorMessage(`getTopLevelElementOrThrow: root nodes are not top level elements`);
        }
      }
      getTextContent() {
        const cachedText = this.__cachedText;
        if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
          if (cachedText !== null) {
            return cachedText;
          }
        }
        return super.getTextContent();
      }
      remove() {
        {
          formatDevErrorMessage(`remove: cannot be called on root nodes`);
        }
      }
      replace(node) {
        {
          formatDevErrorMessage(`replace: cannot be called on root nodes`);
        }
      }
      insertBefore(nodeToInsert) {
        {
          formatDevErrorMessage(`insertBefore: cannot be called on root nodes`);
        }
      }
      insertAfter(nodeToInsert) {
        {
          formatDevErrorMessage(`insertAfter: cannot be called on root nodes`);
        }
      }
      // View
      updateDOM(prevNode, dom2) {
        return false;
      }
      // Mutate
      splice(start, deleteCount, nodesToInsert) {
        for (const node of nodesToInsert) {
          if (!($isElementNode(node) || $isDecoratorNode(node))) {
            formatDevErrorMessage(`rootNode.splice: Only element or decorator nodes can be inserted to the root node`);
          }
        }
        return super.splice(start, deleteCount, nodesToInsert);
      }
      static importJSON(serializedNode) {
        return $getRoot().updateFromJSON(serializedNode);
      }
      collapseAtStart() {
        return true;
      }
    };
    EditorState = class _EditorState {
      constructor(nodeMap, selection) {
        this._nodeMap = nodeMap;
        this._selection = selection || null;
        this._flushSync = false;
        this._readOnly = false;
      }
      isEmpty() {
        return this._nodeMap.size === 1 && this._selection === null;
      }
      read(callbackFn, options) {
        return readEditorState(options && options.editor || null, this, callbackFn);
      }
      clone(selection) {
        const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
        editorState._readOnly = true;
        return editorState;
      }
      toJSON() {
        return readEditorState(null, this, () => ({
          root: exportNodeToJSON($getRoot())
        }));
      }
    };
    HISTORIC_TAG = "historic";
    HISTORY_PUSH_TAG = "history-push";
    HISTORY_MERGE_TAG = "history-merge";
    PASTE_TAG = "paste";
    COLLABORATION_TAG = "collaboration";
    SKIP_COLLAB_TAG = "skip-collab";
    SKIP_SCROLL_INTO_VIEW_TAG = "skip-scroll-into-view";
    SKIP_DOM_SELECTION_TAG = "skip-dom-selection";
    FOCUS_TAG = "focus";
    ArtificialNode__DO_NOT_USE = class extends ElementNode {
      static getType() {
        return "artificial";
      }
      createDOM(config) {
        const dom2 = document.createElement("div");
        return dom2;
      }
    };
    ParagraphNode = class _ParagraphNode extends ElementNode {
      static getType() {
        return "paragraph";
      }
      static clone(node) {
        return new _ParagraphNode(node.__key);
      }
      // View
      createDOM(config) {
        const dom2 = document.createElement("p");
        const classNames2 = getCachedClassNameArray(config.theme, "paragraph");
        if (classNames2 !== void 0) {
          const domClassList = dom2.classList;
          domClassList.add(...classNames2);
        }
        return dom2;
      }
      updateDOM(prevNode, dom2, config) {
        return false;
      }
      static importDOM() {
        return {
          p: (node) => ({
            conversion: $convertParagraphElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (isHTMLElement(element)) {
          if (this.isEmpty()) {
            element.append(document.createElement("br"));
          }
          const formatType = this.getFormatType();
          if (formatType) {
            element.style.textAlign = formatType;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        return $createParagraphNode().updateFromJSON(serializedNode);
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          // These are included explicitly for backwards compatibility
          textFormat: this.getTextFormat(),
          textStyle: this.getTextStyle()
        };
      }
      // Mutation
      insertNewAfter(rangeSelection, restoreSelection) {
        const newElement = $createParagraphNode();
        newElement.setTextFormat(rangeSelection.format);
        newElement.setTextStyle(rangeSelection.style);
        const direction = this.getDirection();
        newElement.setDirection(direction);
        newElement.setFormat(this.getFormatType());
        newElement.setStyle(this.getStyle());
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart() {
        const children = this.getChildren();
        if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
          const nextSibling2 = this.getNextSibling();
          if (nextSibling2 !== null) {
            this.selectNext();
            this.remove();
            return true;
          }
          const prevSibling = this.getPreviousSibling();
          if (prevSibling !== null) {
            this.selectPrevious();
            this.remove();
            return true;
          }
        }
        return false;
      }
    };
    DEFAULT_SKIP_INITIALIZATION = false;
    COMMAND_PRIORITY_EDITOR = 0;
    COMMAND_PRIORITY_LOW = 1;
    COMMAND_PRIORITY_NORMAL = 2;
    COMMAND_PRIORITY_HIGH = 3;
    COMMAND_PRIORITY_CRITICAL = 4;
    LexicalEditor = class {
      /** The version with build identifiers for this editor (since 0.17.1) */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable, createEditorArgs) {
        this._createEditorArgs = createEditorArgs;
        this._parentEditor = parentEditor;
        this._rootElement = null;
        this._editorState = editorState;
        this._pendingEditorState = null;
        this._compositionKey = null;
        this._deferred = [];
        this._keyToDOMMap = /* @__PURE__ */ new Map();
        this._updates = [];
        this._updating = false;
        this._listeners = {
          decorator: /* @__PURE__ */ new Set(),
          editable: /* @__PURE__ */ new Set(),
          mutation: /* @__PURE__ */ new Map(),
          root: /* @__PURE__ */ new Set(),
          textcontent: /* @__PURE__ */ new Set(),
          update: /* @__PURE__ */ new Set()
        };
        this._commands = /* @__PURE__ */ new Map();
        this._config = config;
        this._nodes = nodes;
        this._decorators = {};
        this._pendingDecorators = null;
        this._dirtyType = NO_DIRTY_NODES;
        this._cloneNotNeeded = /* @__PURE__ */ new Set();
        this._dirtyLeaves = /* @__PURE__ */ new Set();
        this._dirtyElements = /* @__PURE__ */ new Map();
        this._normalizedNodes = /* @__PURE__ */ new Set();
        this._updateTags = /* @__PURE__ */ new Set();
        this._observer = null;
        this._key = createUID();
        this._onError = onError;
        this._htmlConversions = htmlConversions;
        this._editable = editable;
        this._headless = parentEditor !== null && parentEditor._headless;
        this._window = null;
        this._blockCursorElement = null;
      }
      /**
       *
       * @returns true if the editor is currently in "composition" mode due to receiving input
       * through an IME, or 3P extension, for example. Returns false otherwise.
       */
      isComposing() {
        return this._compositionKey != null;
      }
      /**
       * Registers a listener for Editor update event. Will trigger the provided callback
       * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerUpdateListener(listener) {
        const listenerSetOrMap = this._listeners.update;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for for when the editor changes between editable and non-editable states.
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerEditableListener(listener) {
        const listenerSetOrMap = this._listeners.editable;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when the editor's decorator object changes. The decorator object contains
       * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerDecoratorListener(listener) {
        const listenerSetOrMap = this._listeners.decorator;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when Lexical commits an update to the DOM and the text content of
       * the editor changes from the previous state of the editor. If the text content is the
       * same between updates, no notifications to the listeners will happen.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerTextContentListener(listener) {
        const listenerSetOrMap = this._listeners.textcontent;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when the editor's root DOM element (the content editable
       * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
       *  element. The root listener function is executed directly upon registration and then on
       * any subsequent update.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerRootListener(listener) {
        const listenerSetOrMap = this._listeners.root;
        listener(this._rootElement, null);
        listenerSetOrMap.add(listener);
        return () => {
          listener(null, this._rootElement);
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener that will trigger anytime the provided command
       * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.
       * Listeners that run at a higher priority can "intercept" commands and
       * prevent them from propagating to other handlers by returning true.
       *
       * Listeners are always invoked in an {@link LexicalEditor.update} and can
       * call dollar functions.
       *
       * Listeners registered at the same priority level will run
       * deterministically in the order of registration.
       *
       * @param command - the command that will trigger the callback.
       * @param listener - the function that will execute when the command is dispatched.
       * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
       *   (or {@link COMMAND_PRIORITY_EDITOR} |
       *     {@link COMMAND_PRIORITY_LOW} |
       *     {@link COMMAND_PRIORITY_NORMAL} |
       *     {@link COMMAND_PRIORITY_HIGH} |
       *     {@link COMMAND_PRIORITY_CRITICAL})
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerCommand(command, listener, priority) {
        if (priority === void 0) {
          {
            formatDevErrorMessage(`Listener for type "command" requires a "priority".`);
          }
        }
        const commandsMap = this._commands;
        if (!commandsMap.has(command)) {
          commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
        }
        const listenersInPriorityOrder = commandsMap.get(command);
        if (listenersInPriorityOrder === void 0) {
          {
            formatDevErrorMessage(`registerCommand: Command ${String(command)} not found in command map`);
          }
        }
        const listeners = listenersInPriorityOrder[priority];
        listeners.add(listener);
        return () => {
          listeners.delete(listener);
          if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
            commandsMap.delete(command);
          }
        };
      }
      /**
       * Registers a listener that will run when a Lexical node of the provided class is
       * mutated. The listener will receive a list of nodes along with the type of mutation
       * that was performed on each: created, destroyed, or updated.
       *
       * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
       * {@link LexicalEditor.getElementByKey} can be used for this.
       *
       * If any existing nodes are in the DOM, and skipInitialization is not true, the listener
       * will be called immediately with an updateTag of 'registerMutationListener' where all
       * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option
       * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).
       *
       * @param klass - The class of the node that you want to listen to mutations on.
       * @param listener - The logic you want to run when the node is mutated.
       * @param options - see {@link MutationListenerOptions}
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerMutationListener(klass, listener, options) {
        const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;
        const mutations = this._listeners.mutation;
        mutations.set(listener, klassToMutate);
        const skipInitialization = options && options.skipInitialization;
        if (!(skipInitialization === void 0 ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {
          this.initializeMutationListener(listener, klassToMutate);
        }
        return () => {
          mutations.delete(listener);
        };
      }
      /** @internal */
      getRegisteredNode(klass) {
        const registeredNode = this._nodes.get(klass.getType());
        if (registeredNode === void 0) {
          {
            formatDevErrorMessage(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        return registeredNode;
      }
      /** @internal */
      resolveRegisteredNodeAfterReplacements(registeredNode) {
        while (registeredNode.replaceWithKlass) {
          registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);
        }
        return registeredNode;
      }
      /** @internal */
      initializeMutationListener(listener, klass) {
        const prevEditorState = this._editorState;
        const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());
        if (!nodeMap) {
          return;
        }
        const nodeMutationMap = /* @__PURE__ */ new Map();
        for (const k5 of nodeMap.keys()) {
          nodeMutationMap.set(k5, "created");
        }
        if (nodeMutationMap.size > 0) {
          listener(nodeMutationMap, {
            dirtyLeaves: /* @__PURE__ */ new Set(),
            prevEditorState,
            updateTags: /* @__PURE__ */ new Set(["registerMutationListener"])
          });
        }
      }
      /** @internal */
      registerNodeTransformToKlass(klass, listener) {
        const registeredNode = this.getRegisteredNode(klass);
        registeredNode.transforms.add(listener);
        return registeredNode;
      }
      /**
       * Registers a listener that will run when a Lexical node of the provided class is
       * marked dirty during an update. The listener will continue to run as long as the node
       * is marked dirty. There are no guarantees around the order of transform execution!
       *
       * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
       * @param klass - The class of the node that you want to run transforms on.
       * @param listener - The logic you want to run when the node is updated.
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerNodeTransform(klass, listener) {
        const registeredNode = this.registerNodeTransformToKlass(klass, listener);
        const registeredNodes = [registeredNode];
        const replaceWithKlass = registeredNode.replaceWithKlass;
        if (replaceWithKlass != null) {
          const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
          registeredNodes.push(registeredReplaceWithNode);
        }
        markNodesWithTypesAsDirty(this, registeredNodes.map((node) => node.klass.getType()));
        return () => {
          registeredNodes.forEach((node) => node.transforms.delete(listener));
        };
      }
      /**
       * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
       * depend on have been registered.
       * @returns True if the editor has registered the provided node type, false otherwise.
       */
      hasNode(node) {
        return this._nodes.has(node.getType());
      }
      /**
       * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
       * depend on have been registered.
       * @returns True if the editor has registered all of the provided node types, false otherwise.
       */
      hasNodes(nodes) {
        return nodes.every(this.hasNode.bind(this));
      }
      /**
       * Dispatches a command of the specified type with the specified payload.
       * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
       * for this type, passing them the provided payload. The command listeners
       * will be triggered in an implicit {@link LexicalEditor.update}, unless
       * this was invoked from inside an update in which case that update context
       * will be re-used (as if this was a dollar function itself).
       * @param type - the type of command listeners to trigger.
       * @param payload - the data to pass as an argument to the command listeners.
       */
      dispatchCommand(type, payload) {
        return dispatchCommand(this, type, payload);
      }
      /**
       * Gets a map of all decorators in the editor.
       * @returns A mapping of call decorator keys to their decorated content
       */
      getDecorators() {
        return this._decorators;
      }
      /**
       *
       * @returns the current root element of the editor. If you want to register
       * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
       * this reference may not be stable.
       */
      getRootElement() {
        return this._rootElement;
      }
      /**
       * Gets the key of the editor
       * @returns The editor key
       */
      getKey() {
        return this._key;
      }
      /**
       * Imperatively set the root contenteditable element that Lexical listens
       * for events on.
       */
      setRootElement(nextRootElement) {
        const prevRootElement = this._rootElement;
        if (nextRootElement !== prevRootElement) {
          const classNames2 = getCachedClassNameArray(this._config.theme, "root");
          const pendingEditorState = this._pendingEditorState || this._editorState;
          this._rootElement = nextRootElement;
          resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
          if (prevRootElement !== null) {
            if (!this._config.disableEvents) {
              removeRootElementEvents(prevRootElement);
            }
            if (classNames2 != null) {
              prevRootElement.classList.remove(...classNames2);
            }
          }
          if (nextRootElement !== null) {
            const windowObj = getDefaultView(nextRootElement);
            const style = nextRootElement.style;
            style.userSelect = "text";
            style.whiteSpace = "pre-wrap";
            style.wordBreak = "break-word";
            nextRootElement.setAttribute("data-lexical-editor", "true");
            this._window = windowObj;
            this._dirtyType = FULL_RECONCILE;
            initMutationObserver(this);
            this._updateTags.add(HISTORY_MERGE_TAG);
            $commitPendingUpdates(this);
            if (!this._config.disableEvents) {
              addRootElementEvents(nextRootElement, this);
            }
            if (classNames2 != null) {
              nextRootElement.classList.add(...classNames2);
            }
            {
              const nextRootElementParent = nextRootElement.parentElement;
              if (nextRootElementParent != null && ["flex", "inline-flex"].includes(getComputedStyle(nextRootElementParent).display)) {
                console.warn(`When using "display: flex" or "display: inline-flex" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);
              }
            }
          } else {
            this._window = null;
            this._updateTags.add(HISTORY_MERGE_TAG);
            $commitPendingUpdates(this);
          }
          triggerListeners("root", this, false, nextRootElement, prevRootElement);
        }
      }
      /**
       * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
       * @returns the HTMLElement rendered by the LexicalNode associated with the key.
       * @param key - the key of the LexicalNode.
       */
      getElementByKey(key2) {
        return this._keyToDOMMap.get(key2) || null;
      }
      /**
       * Gets the active editor state.
       * @returns The editor state
       */
      getEditorState() {
        return this._editorState;
      }
      /**
       * Imperatively set the EditorState. Triggers reconciliation like an update.
       * @param editorState - the state to set the editor
       * @param options - options for the update.
       */
      setEditorState(editorState, options) {
        if (editorState.isEmpty()) {
          {
            formatDevErrorMessage(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
          }
        }
        let writableEditorState = editorState;
        if (writableEditorState._readOnly) {
          writableEditorState = cloneEditorState(editorState);
          writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;
        }
        flushRootMutations(this);
        const pendingEditorState = this._pendingEditorState;
        const tags = this._updateTags;
        const tag = options !== void 0 ? options.tag : null;
        if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
          if (tag != null) {
            tags.add(tag);
          }
          $commitPendingUpdates(this);
        }
        this._pendingEditorState = writableEditorState;
        this._dirtyType = FULL_RECONCILE;
        this._dirtyElements.set("root", false);
        this._compositionKey = null;
        if (tag != null) {
          tags.add(tag);
        }
        if (!this._updating) {
          $commitPendingUpdates(this);
        }
      }
      /**
       * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
       * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
       * deserialization from JSON stored in a database uses this method.
       * @param maybeStringifiedEditorState
       * @param updateFn
       * @returns
       */
      parseEditorState(maybeStringifiedEditorState, updateFn) {
        const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
        return parseEditorState(serializedEditorState, this, updateFn);
      }
      /**
       * Executes a read of the editor's state, with the
       * editor context available (useful for exporting and read-only DOM
       * operations). Much like update, but prevents any mutation of the
       * editor's state. Any pending updates will be flushed immediately before
       * the read.
       * @param callbackFn - A function that has access to read-only editor state.
       */
      read(callbackFn) {
        $commitPendingUpdates(this);
        return this.getEditorState().read(callbackFn, {
          editor: this
        });
      }
      /**
       * Executes an update to the editor state. The updateFn callback is the ONLY place
       * where Lexical editor state can be safely mutated.
       * @param updateFn - A function that has access to writable editor state.
       * @param options - A bag of options to control the behavior of the update.
       * @param options.onUpdate - A function to run once the update is complete.
       * Useful for synchronizing updates in some cases.
       * @param options.skipTransforms - Setting this to true will suppress all node
       * transforms for this update cycle.
       * @param options.tag - A tag to identify this update, in an update listener, for instance.
       * Some tags are reserved by the core and control update behavior in different ways.
       * @param options.discrete - If true, prevents this update from being batched, forcing it to
       * run synchronously.
       */
      update(updateFn, options) {
        updateEditor(this, updateFn, options);
      }
      /**
       * Focuses the editor by marking the existing selection as dirty, or by
       * creating a new selection at `defaultSelection` if one does not already
       * exist. If you want to force a specific selection, you should call
       * `root.selectStart()` or `root.selectEnd()` in an update.
       *
       * @param callbackFn - A function to run after the editor is focused.
       * @param options - A bag of options
       * @param options.defaultSelection - Where to move selection when the editor is
       * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
       */
      focus(callbackFn, options = {}) {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.setAttribute("autocapitalize", "off");
          updateEditorSync(this, () => {
            const selection = $getSelection();
            const root = $getRoot();
            if (selection !== null) {
              if (!selection.dirty) {
                $setSelection(selection.clone());
              }
            } else if (root.getChildrenSize() !== 0) {
              if (options.defaultSelection === "rootStart") {
                root.selectStart();
              } else {
                root.selectEnd();
              }
            }
            $addUpdateTag(FOCUS_TAG);
            $onUpdate(() => {
              rootElement.removeAttribute("autocapitalize");
              if (callbackFn) {
                callbackFn();
              }
            });
          });
          if (this._pendingEditorState === null) {
            rootElement.removeAttribute("autocapitalize");
          }
        }
      }
      /**
       * Removes focus from the editor.
       */
      blur() {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.blur();
        }
        const domSelection = getDOMSelection(this._window);
        if (domSelection !== null) {
          domSelection.removeAllRanges();
        }
      }
      /**
       * Returns true if the editor is editable, false otherwise.
       * @returns True if the editor is editable, false otherwise.
       */
      isEditable() {
        return this._editable;
      }
      /**
       * Sets the editable property of the editor. When false, the
       * editor will not listen for user events on the underling contenteditable.
       * @param editable - the value to set the editable mode to.
       */
      setEditable(editable) {
        if (this._editable !== editable) {
          this._editable = editable;
          triggerListeners("editable", this, true, editable);
        }
      }
      /**
       * Returns a JSON-serializable javascript object NOT a JSON string.
       * You still must call JSON.stringify (or something else) to turn the
       * state into a string you can transfer over the wire and store in a database.
       *
       * See {@link LexicalNode.exportJSON}
       *
       * @returns A JSON-serializable javascript object
       */
      toJSON() {
        return {
          editorState: this._editorState.toJSON()
        };
      }
    };
    LexicalEditor.version = "0.32.1+dev.esm";
    keyCounter = 1;
    scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn3) => {
      Promise.resolve().then(fn3);
    };
    CONTROL_OR_META = {
      ctrlKey: !IS_APPLE,
      metaKey: IS_APPLE
    };
    CONTROL_OR_ALT = {
      altKey: IS_APPLE,
      ctrlKey: !IS_APPLE
    };
    cachedNodeMaps = /* @__PURE__ */ new WeakMap();
    EMPTY_TYPE_TO_NODE_MAP = /* @__PURE__ */ new Map();
    FLIP_DIRECTION = {
      next: "previous",
      previous: "next"
    };
    AbstractCaret = class {
      constructor(origin) {
        this.origin = origin;
      }
      [Symbol.iterator]() {
        return makeStepwiseIterator({
          hasNext: $isSiblingCaret,
          initial: this.getAdjacentCaret(),
          map: (caret) => caret,
          step: (caret) => caret.getAdjacentCaret()
        });
      }
      getAdjacentCaret() {
        return $getSiblingCaret(this.getNodeAtCaret(), this.direction);
      }
      getSiblingCaret() {
        return $getSiblingCaret(this.origin, this.direction);
      }
      remove() {
        const node = this.getNodeAtCaret();
        if (node) {
          node.remove();
        }
        return this;
      }
      replaceOrInsert(node, includeChildren) {
        const target = this.getNodeAtCaret();
        if (node.is(this.origin) || node.is(target)) ;
        else if (target === null) {
          this.insert(node);
        } else {
          target.replace(node, includeChildren);
        }
        return this;
      }
      splice(deleteCount, nodes, nodesDirection = "next") {
        const nodeIter = nodesDirection === this.direction ? nodes : Array.from(nodes).reverse();
        let caret = this;
        const parent = this.getParentAtCaret();
        const nodesToRemove = /* @__PURE__ */ new Map();
        for (let removeCaret = caret.getAdjacentCaret(); removeCaret !== null && nodesToRemove.size < deleteCount; removeCaret = removeCaret.getAdjacentCaret()) {
          const writableNode = removeCaret.origin.getWritable();
          nodesToRemove.set(writableNode.getKey(), writableNode);
        }
        for (const node of nodeIter) {
          if (nodesToRemove.size > 0) {
            const target = caret.getNodeAtCaret();
            if (target) {
              nodesToRemove.delete(target.getKey());
              nodesToRemove.delete(node.getKey());
              if (target.is(node) || caret.origin.is(node)) ;
              else {
                const nodeParent = node.getParent();
                if (nodeParent && nodeParent.is(parent)) {
                  node.remove();
                }
                target.replace(node);
              }
            } else {
              if (!(target !== null)) {
                formatDevErrorMessage(`NodeCaret.splice: Underflow of expected nodesToRemove during splice (keys: ${Array.from(nodesToRemove).join(" ")})`);
              }
            }
          } else {
            caret.insert(node);
          }
          caret = $getSiblingCaret(node, this.direction);
        }
        for (const node of nodesToRemove.values()) {
          node.remove();
        }
        return this;
      }
    };
    AbstractChildCaret = class _AbstractChildCaret extends AbstractCaret {
      type = "child";
      getLatest() {
        const origin = this.origin.getLatest();
        return origin === this.origin ? this : $getChildCaret(origin, this.direction);
      }
      /**
       * Get the SiblingCaret from this origin in the same direction.
       *
       * @param mode 'root' to return null at the root, 'shadowRoot' to return null at the root or any shadow root
       * @returns A SiblingCaret with this origin, or null if origin is a root according to mode.
       */
      getParentCaret(mode = "root") {
        return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
      }
      getFlipped() {
        const dir = flipDirection(this.direction);
        return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin, dir);
      }
      getParentAtCaret() {
        return this.origin;
      }
      getChildCaret() {
        return this;
      }
      isSameNodeCaret(other) {
        return other instanceof _AbstractChildCaret && this.direction === other.direction && this.origin.is(other.origin);
      }
      isSamePointCaret(other) {
        return this.isSameNodeCaret(other);
      }
    };
    ChildCaretFirst = class extends AbstractChildCaret {
      direction = "next";
      getNodeAtCaret() {
        return this.origin.getFirstChild();
      }
      insert(node) {
        this.origin.splice(0, 0, [node]);
        return this;
      }
    };
    ChildCaretLast = class extends AbstractChildCaret {
      direction = "previous";
      getNodeAtCaret() {
        return this.origin.getLastChild();
      }
      insert(node) {
        this.origin.splice(this.origin.getChildrenSize(), 0, [node]);
        return this;
      }
    };
    MODE_PREDICATE = {
      root: $isRootNode,
      shadowRoot: $isRootOrShadowRoot
    };
    AbstractSiblingCaret = class _AbstractSiblingCaret extends AbstractCaret {
      type = "sibling";
      getLatest() {
        const origin = this.origin.getLatest();
        return origin === this.origin ? this : $getSiblingCaret(origin, this.direction);
      }
      getSiblingCaret() {
        return this;
      }
      getParentAtCaret() {
        return this.origin.getParent();
      }
      getChildCaret() {
        return $isElementNode(this.origin) ? $getChildCaret(this.origin, this.direction) : null;
      }
      getParentCaret(mode = "root") {
        return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
      }
      getFlipped() {
        const dir = flipDirection(this.direction);
        return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin.getParentOrThrow(), dir);
      }
      isSamePointCaret(other) {
        return other instanceof _AbstractSiblingCaret && this.direction === other.direction && this.origin.is(other.origin);
      }
      isSameNodeCaret(other) {
        return (other instanceof _AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);
      }
    };
    AbstractTextPointCaret = class _AbstractTextPointCaret extends AbstractCaret {
      type = "text";
      constructor(origin, offset) {
        super(origin);
        this.offset = offset;
      }
      getLatest() {
        const origin = this.origin.getLatest();
        return origin === this.origin ? this : $getTextPointCaret(origin, this.direction, this.offset);
      }
      getParentAtCaret() {
        return this.origin.getParent();
      }
      getChildCaret() {
        return null;
      }
      getParentCaret(mode = "root") {
        return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
      }
      getFlipped() {
        return $getTextPointCaret(this.origin, flipDirection(this.direction), this.offset);
      }
      isSamePointCaret(other) {
        return other instanceof _AbstractTextPointCaret && this.direction === other.direction && this.origin.is(other.origin) && this.offset === other.offset;
      }
      isSameNodeCaret(other) {
        return (other instanceof AbstractSiblingCaret || other instanceof _AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);
      }
      getSiblingCaret() {
        return $getSiblingCaret(this.origin, this.direction);
      }
    };
    SiblingCaretNext = class extends AbstractSiblingCaret {
      direction = "next";
      getNodeAtCaret() {
        return this.origin.getNextSibling();
      }
      insert(node) {
        this.origin.insertAfter(node);
        return this;
      }
    };
    SiblingCaretPrevious = class extends AbstractSiblingCaret {
      direction = "previous";
      getNodeAtCaret() {
        return this.origin.getPreviousSibling();
      }
      insert(node) {
        this.origin.insertBefore(node);
        return this;
      }
    };
    TextPointCaretNext = class extends AbstractTextPointCaret {
      direction = "next";
      getNodeAtCaret() {
        return this.origin.getNextSibling();
      }
      insert(node) {
        this.origin.insertAfter(node);
        return this;
      }
    };
    TextPointCaretPrevious = class extends AbstractTextPointCaret {
      direction = "previous";
      getNodeAtCaret() {
        return this.origin.getPreviousSibling();
      }
      insert(node) {
        this.origin.insertBefore(node);
        return this;
      }
    };
    TEXT_CTOR = {
      next: TextPointCaretNext,
      previous: TextPointCaretPrevious
    };
    SIBLING_CTOR = {
      next: SiblingCaretNext,
      previous: SiblingCaretPrevious
    };
    CHILD_CTOR = {
      next: ChildCaretFirst,
      previous: ChildCaretLast
    };
    CaretRangeImpl = class _CaretRangeImpl {
      type = "node-caret-range";
      constructor(anchor, focus, direction) {
        this.anchor = anchor;
        this.focus = focus;
        this.direction = direction;
      }
      getLatest() {
        const anchor = this.anchor.getLatest();
        const focus = this.focus.getLatest();
        return anchor === this.anchor && focus === this.focus ? this : new _CaretRangeImpl(anchor, focus, this.direction);
      }
      isCollapsed() {
        return this.anchor.isSamePointCaret(this.focus);
      }
      getTextSlices() {
        const getSlice = (k5) => {
          const caret = this[k5].getLatest();
          return $isTextPointCaret(caret) ? $getSliceFromTextPointCaret(caret, k5) : null;
        };
        const anchorSlice = getSlice("anchor");
        const focusSlice = getSlice("focus");
        if (anchorSlice && focusSlice) {
          const {
            caret: anchorCaret
          } = anchorSlice;
          const {
            caret: focusCaret
          } = focusSlice;
          if (anchorCaret.isSameNodeCaret(focusCaret)) {
            return [$getTextPointCaretSlice(anchorCaret, focusCaret.offset - anchorCaret.offset), null];
          }
        }
        return [anchorSlice, focusSlice];
      }
      iterNodeCarets(rootMode = "root") {
        const anchor = $isTextPointCaret(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest();
        const focus = this.focus.getLatest();
        const isTextFocus = $isTextPointCaret(focus);
        const step = (state) => state.isSameNodeCaret(focus) ? null : $getAdjacentChildCaret(state) || state.getParentCaret(rootMode);
        return makeStepwiseIterator({
          hasNext: (state) => state !== null && !(isTextFocus && focus.isSameNodeCaret(state)),
          initial: anchor.isSameNodeCaret(focus) ? null : step(anchor),
          map: (state) => state,
          step
        });
      }
      [Symbol.iterator]() {
        return this.iterNodeCarets("root");
      }
    };
    TextPointCaretSliceImpl = class {
      type = "slice";
      constructor(caret, distance) {
        this.caret = caret;
        this.distance = distance;
      }
      getSliceIndices() {
        const {
          distance,
          caret: {
            offset
          }
        } = this;
        const offsetB = offset + distance;
        return offsetB < offset ? [offsetB, offset] : [offset, offsetB];
      }
      getTextContent() {
        const [startIndex, endIndex] = this.getSliceIndices();
        return this.caret.origin.getTextContent().slice(startIndex, endIndex);
      }
      getTextContentSize() {
        return Math.abs(this.distance);
      }
      removeTextSlice() {
        const {
          caret: {
            origin,
            direction
          }
        } = this;
        const [indexStart, indexEnd] = this.getSliceIndices();
        const text = origin.getTextContent();
        return $getTextPointCaret(origin.setTextContent(text.slice(0, indexStart) + text.slice(indexEnd)), direction, indexStart);
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/lexical@0.32.1/node_modules/lexical/Lexical.prod.mjs
var Lexical_prod_exports = {};
__export(Lexical_prod_exports, {
  $addUpdateTag: () => Ys,
  $applyNodeReplacement: () => no,
  $caretFromPoint: () => ll,
  $caretRangeFromSelection: () => fl,
  $cloneWithProperties: () => ko,
  $comparePointCaretNext: () => nl,
  $copyNode: () => eo,
  $createLineBreakNode: () => Pn,
  $createNodeSelection: () => kr,
  $createParagraphNode: () => Pi,
  $createPoint: () => ir,
  $createRangeSelection: () => vr,
  $createRangeSelectionFromDom: () => Tr,
  $createTabNode: () => er,
  $createTextNode: () => Xn,
  $extendCaretToRange: () => Qo,
  $getAdjacentChildCaret: () => Ho,
  $getAdjacentNode: () => Bs,
  $getAdjacentSiblingOrParentSiblingCaret: () => Sl,
  $getCaretInDirection: () => ml,
  $getCaretRange: () => tl,
  $getCaretRangeInDirection: () => xl,
  $getCharacterOffsets: () => dr,
  $getChildCaret: () => Vo,
  $getChildCaretAtIndex: () => Cl,
  $getChildCaretOrSelf: () => Yo,
  $getCollapsedCaretRange: () => Zo,
  $getCommonAncestor: () => ol,
  $getCommonAncestorResultBranchOrder: () => rl,
  $getEditor: () => xo,
  $getNearestNodeFromDOMNode: () => hs,
  $getNearestRootOrShadowRoot: () => Zs,
  $getNodeByKey: () => us,
  $getNodeByKeyOrThrow: () => io,
  $getPreviousSelection: () => wr,
  $getRoot: () => ps,
  $getSelection: () => Nr,
  $getSiblingCaret: () => Jo,
  $getState: () => gt,
  $getStateChange: () => ht,
  $getTextContent: () => Lr,
  $getTextNodeOffset: () => $o,
  $getTextPointCaret: () => Uo,
  $getTextPointCaretSlice: () => jo,
  $getWritableNodeState: () => mt,
  $hasAncestor: () => qs,
  $hasUpdateTag: () => Vs,
  $insertNodes: () => Fr,
  $isBlockElementNode: () => Cr,
  $isChildCaret: () => Ko,
  $isDecoratorNode: () => _i,
  $isElementNode: () => di,
  $isExtendableTextPointCaret: () => yl,
  $isInlineElementOrDecoratorNode: () => Qs,
  $isLeafNode: () => is3,
  $isLineBreakNode: () => Fn,
  $isNodeCaret: () => Io,
  $isNodeSelection: () => ur,
  $isParagraphNode: () => Fi,
  $isRangeSelection: () => cr,
  $isRootNode: () => yi,
  $isRootOrShadowRoot: () => to,
  $isSiblingCaret: () => zo,
  $isTabNode: () => nr,
  $isTextNode: () => Qn,
  $isTextPointCaret: () => Lo,
  $isTextPointCaretSlice: () => Xo,
  $isTokenOrSegmented: () => Zi,
  $isTokenOrTab: () => Qi,
  $nodesOfType: () => zs,
  $normalizeCaret: () => pl,
  $normalizeSelection__EXPERIMENTAL: () => vt,
  $onUpdate: () => Hs,
  $parseSerializedNode: () => ei,
  $removeTextFromCaretRange: () => _l,
  $rewindSiblingCaret: () => dl,
  $selectAll: () => Fs,
  $setCompositionKey: () => cs,
  $setPointFromCaret: () => cl,
  $setSelection: () => ms,
  $setSelectionFromCaretRange: () => al,
  $setState: () => _t,
  $splitAtPointCaretNext: () => Tl,
  $splitNode: () => ao,
  $updateRangeSelectionFromCaretRange: () => ul,
  ArtificialNode__DO_NOT_USE: () => Ai,
  BLUR_COMMAND: () => Ge,
  CAN_REDO_COMMAND: () => Ye,
  CAN_UNDO_COMMAND: () => He,
  CLEAR_EDITOR_COMMAND: () => je,
  CLEAR_HISTORY_COMMAND: () => Ve,
  CLICK_COMMAND: () => ae,
  COLLABORATION_TAG: () => Ni,
  COMMAND_PRIORITY_CRITICAL: () => Bi,
  COMMAND_PRIORITY_EDITOR: () => Li,
  COMMAND_PRIORITY_HIGH: () => Ki,
  COMMAND_PRIORITY_LOW: () => Ii,
  COMMAND_PRIORITY_NORMAL: () => zi,
  CONTROLLED_TEXT_INSERTION_COMMAND: () => he,
  COPY_COMMAND: () => Je,
  CUT_COMMAND: () => Ue,
  DELETE_CHARACTER_COMMAND: () => ue,
  DELETE_LINE_COMMAND: () => ye,
  DELETE_WORD_COMMAND: () => pe2,
  DRAGEND_COMMAND: () => We,
  DRAGOVER_COMMAND: () => Re,
  DRAGSTART_COMMAND: () => Be,
  DROP_COMMAND: () => ze,
  DecoratorNode: () => gi,
  ElementNode: () => fi,
  FOCUS_COMMAND: () => qe,
  FORMAT_ELEMENT_COMMAND: () => Ke,
  FORMAT_TEXT_COMMAND: () => me,
  HISTORIC_TAG: () => vi,
  HISTORY_MERGE_TAG: () => Ti,
  HISTORY_PUSH_TAG: () => ki,
  INDENT_CONTENT_COMMAND: () => Le,
  INSERT_LINE_BREAK_COMMAND: () => fe,
  INSERT_PARAGRAPH_COMMAND: () => de,
  INSERT_TAB_COMMAND: () => Fe,
  INTERNAL_$isBlock: () => yo,
  IS_ALL_FORMATTING: () => O,
  IS_BOLD: () => k,
  IS_CODE: () => w,
  IS_HIGHLIGHT: () => A,
  IS_ITALIC: () => T,
  IS_STRIKETHROUGH: () => b,
  IS_SUBSCRIPT: () => E,
  IS_SUPERSCRIPT: () => M,
  IS_UNDERLINE: () => N,
  KEY_ARROW_DOWN_COMMAND: () => we,
  KEY_ARROW_LEFT_COMMAND: () => Te,
  KEY_ARROW_RIGHT_COMMAND: () => ve,
  KEY_ARROW_UP_COMMAND: () => Ne,
  KEY_BACKSPACE_COMMAND: () => Ae,
  KEY_DELETE_COMMAND: () => De,
  KEY_DOWN_COMMAND: () => Se,
  KEY_ENTER_COMMAND: () => Ee,
  KEY_ESCAPE_COMMAND: () => Oe,
  KEY_MODIFIER_COMMAND: () => Xe,
  KEY_SPACE_COMMAND: () => Me,
  KEY_TAB_COMMAND: () => Pe,
  LineBreakNode: () => On,
  MOVE_TO_END: () => ke,
  MOVE_TO_START: () => be,
  NODE_STATE_KEY: () => X,
  OUTDENT_CONTENT_COMMAND: () => Ie,
  PASTE_COMMAND: () => ge,
  PASTE_TAG: () => bi,
  ParagraphNode: () => Oi,
  REDO_COMMAND: () => Ce,
  REMOVE_TEXT_COMMAND: () => _e,
  RootNode: () => pi,
  SELECTION_CHANGE_COMMAND: () => le,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => ce,
  SELECT_ALL_COMMAND: () => $e,
  SKIP_COLLAB_TAG: () => wi,
  SKIP_DOM_SELECTION_TAG: () => Mi,
  SKIP_SCROLL_INTO_VIEW_TAG: () => Ei,
  TEXT_TYPE_TO_FORMAT: () => j,
  TabNode: () => tr,
  TextNode: () => Jn,
  UNDO_COMMAND: () => xe,
  createCommand: () => oe,
  createEditor: () => Wi,
  createState: () => dt,
  flipDirection: () => Oo,
  getDOMOwnerDocument: () => js,
  getDOMSelection: () => lo,
  getDOMSelectionFromTarget: () => co,
  getDOMTextNode: () => ns,
  getEditorPropertyFromDOMNode: () => Xi,
  getNearestEditorFromDOMNode: () => Gi,
  isBlockDomNode: () => po,
  isCurrentlyReadOnlyMode: () => jr,
  isDOMDocumentNode: () => es,
  isDOMNode: () => ho,
  isDOMTextNode: () => ts,
  isDOMUnmanaged: () => No,
  isDocumentFragment: () => go,
  isExactShortcutMatch: () => Ms,
  isHTMLAnchorElement: () => uo,
  isHTMLElement: () => fo,
  isInlineDomNode: () => _o,
  isLexicalEditor: () => qi,
  isModifierMatch: () => Es,
  isSelectionCapturedInDecoratorInput: () => Yi,
  isSelectionWithinEditor: () => Hi,
  makeStepwiseIterator: () => el,
  removeFromParent: () => os,
  resetRandomKey: () => $i,
  setDOMUnmanaged: () => bo,
  setNodeIndentFromDOM: () => To
});
function t(t3, ...e2) {
  const n2 = new URL("https://lexical.dev/docs/error"), r2 = new URLSearchParams();
  r2.append("code", t3);
  for (const t4 of e2) r2.append("v", t4);
  throw n2.search = r2.toString(), Error(`Minified Lexical error #${t3}; visit ${n2.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function d(...t3) {
  const e2 = [];
  for (const n2 of t3) if (n2 && "string" == typeof n2) for (const [t4] of n2.matchAll(/\S+/g)) e2.push(t4);
  return e2;
}
function Q(t3, e2, n2, r2, i2, s2) {
  let o2 = t3.getFirstChild();
  for (; null !== o2; ) {
    const t4 = o2.__key;
    o2.__parent === e2 && (di(o2) && Q(o2, t4, n2, r2, i2, s2), n2.has(t4) || s2.delete(t4), i2.push(t4)), o2 = o2.getNextSibling();
  }
}
function nt(t3) {
  et = t3.timeStamp;
}
function rt(t3, e2, n2) {
  const r2 = "BR" === t3.nodeName, i2 = e2.__lexicalLineBreak;
  return i2 && (t3 === i2 || r2 && t3.previousSibling === i2) || r2 && void 0 !== ds(t3, n2);
}
function it(t3, e2, n2) {
  const r2 = lo(Xs(n2));
  let i2 = null, s2 = null;
  null !== r2 && r2.anchorNode === t3 && (i2 = r2.anchorOffset, s2 = r2.focusOffset);
  const o2 = t3.nodeValue;
  null !== o2 && Ns(e2, o2, i2, s2, false);
}
function st(t3, e2, n2) {
  if (cr(t3)) {
    const e3 = t3.anchor.getNode();
    if (e3.is(n2) && t3.format !== e3.getFormat()) return false;
  }
  return ts(e2) && n2.isAttached();
}
function ot(t3, e2, n2, r2) {
  for (let i2 = t3; i2 && !No(i2); i2 = $s(i2)) {
    const t4 = ds(i2, e2);
    if (void 0 !== t4) {
      const e3 = us(t4, n2);
      if (e3) return _i(e3) || !fo(i2) ? void 0 : [i2, e3];
    } else if (i2 === r2) return [r2, ys(n2)];
  }
}
function lt(t3, e2, n2) {
  tt = true;
  const r2 = performance.now() - et > Z;
  try {
    ci(t3, () => {
      const s2 = Nr() || function(t4) {
        return t4.getEditorState().read(() => {
          const t5 = Nr();
          return null !== t5 ? t5.clone() : null;
        });
      }(t3), o2 = /* @__PURE__ */ new Map(), l2 = t3.getRootElement(), c2 = t3._editorState, a2 = t3._blockCursorElement;
      let u2 = false, f3 = "";
      for (let n3 = 0; n3 < e2.length; n3++) {
        const d4 = e2[n3], h4 = d4.type, g4 = d4.target, _5 = ot(g4, t3, c2, l2);
        if (!_5) continue;
        const [p3, y4] = _5;
        if ("characterData" === h4) r2 && Qn(y4) && ts(g4) && st(s2, g4, y4) && it(g4, y4, t3);
        else if ("childList" === h4) {
          u2 = true;
          const e3 = d4.addedNodes;
          for (let n5 = 0; n5 < e3.length; n5++) {
            const r4 = e3[n5], s3 = fs(r4), o3 = r4.parentNode;
            if (null != o3 && r4 !== a2 && null === s3 && !rt(r4, o3, t3)) {
              if (i) {
                const t4 = (fo(r4) ? r4.innerText : null) || r4.nodeValue;
                t4 && (f3 += t4);
              }
              o3.removeChild(r4);
            }
          }
          const n4 = d4.removedNodes, r3 = n4.length;
          if (r3 > 0) {
            let e4 = 0;
            for (let i2 = 0; i2 < r3; i2++) {
              const r4 = n4[i2];
              (rt(r4, g4, t3) || a2 === r4) && (g4.appendChild(r4), e4++);
            }
            r3 !== e4 && o2.set(p3, y4);
          }
        }
      }
      if (o2.size > 0) for (const [e3, n3] of o2) n3.reconcileObservedMutation(e3, t3);
      const d3 = n2.takeRecords();
      if (d3.length > 0) {
        for (let e3 = 0; e3 < d3.length; e3++) {
          const n3 = d3[e3], r3 = n3.addedNodes, i2 = n3.target;
          for (let e4 = 0; e4 < r3.length; e4++) {
            const n4 = r3[e4], s3 = n4.parentNode;
            null == s3 || "BR" !== n4.nodeName || rt(n4, i2, t3) || s3.removeChild(n4);
          }
        }
        n2.takeRecords();
      }
      null !== s2 && (u2 && ms(s2), i && Rs(t3) && s2.insertRawText(f3));
    });
  } finally {
    tt = false;
  }
}
function ct(t3) {
  const e2 = t3._observer;
  if (null !== e2) {
    lt(t3, e2.takeRecords(), e2);
  }
}
function at(t3) {
  !function(t4) {
    0 === et && Xs(t4).addEventListener("textInput", nt, true);
  }(t3), t3._observer = new MutationObserver((e2, n2) => {
    lt(t3, e2, n2);
  });
}
function ut(t3) {
  return t3;
}
function dt(t3, e2) {
  return new ft(t3, e2);
}
function ht(t3, e2, n2) {
  const r2 = gt(t3, n2, "direct"), i2 = gt(e2, n2, "direct");
  return n2.isEqual(r2, i2) ? null : [r2, i2];
}
function gt(t3, e2, n2 = "latest") {
  const r2 = ("latest" === n2 ? t3.getLatest() : t3).__state;
  return r2 ? r2.getValue(e2) : e2.defaultValue;
}
function _t(t3, e2, n2) {
  let r2;
  if (Vr(), "function" == typeof n2) {
    const i3 = t3.getLatest(), s2 = gt(i3, e2);
    if (r2 = n2(s2), e2.isEqual(s2, r2)) return i3;
  } else r2 = n2;
  const i2 = t3.getWritable();
  return mt(i2).updateFromKnown(e2, r2), i2;
}
function yt(t3) {
  if (t3) for (const e2 in t3) return t3;
}
function mt(t3) {
  const e2 = t3.getWritable(), n2 = e2.__state ? e2.__state.getWritable(e2) : new pt(e2);
  return e2.__state = n2, n2;
}
function xt(t3, e2) {
  const n2 = t3.__mode, r2 = t3.__format, i2 = t3.__style, s2 = e2.__mode, o2 = e2.__format, l2 = e2.__style, c2 = t3.__state, a2 = e2.__state;
  return (null === n2 || n2 === s2) && (null === r2 || r2 === o2) && (null === i2 || i2 === l2) && (null === t3.__state || c2 === a2 || function(t4, e3) {
    if (t4 === e3) return true;
    if (t4 && e3 && t4.size !== e3.size) return false;
    const n3 = /* @__PURE__ */ new Set(), r3 = (t5, e4) => {
      for (const [r4, i4] of t5.knownState) {
        if (n3.has(r4.key)) continue;
        n3.add(r4.key);
        const t6 = e4 ? e4.getValue(r4) : r4.defaultValue;
        if (t6 !== i4 && !r4.isEqual(t6, i4)) return true;
      }
      return false;
    }, i3 = (t5, e4) => {
      const { unknownState: r4 } = t5, i4 = e4 ? e4.unknownState : void 0;
      if (r4) {
        for (const [t6, e5] of Object.entries(r4)) if (!n3.has(t6) && (n3.add(t6), e5 !== (i4 ? i4[t6] : void 0))) return true;
      }
      return false;
    };
    return !(t4 && r3(t4, e3) || e3 && r3(e3, t4) || t4 && i3(t4, e3) || e3 && i3(e3, t4));
  }(c2, a2));
}
function Ct(t3, e2) {
  const n2 = t3.mergeWithSibling(e2), r2 = qr()._normalizedNodes;
  return r2.add(t3.__key), r2.add(e2.__key), n2;
}
function St(t3) {
  let e2, n2, r2 = t3;
  if ("" !== r2.__text || !r2.isSimpleText() || r2.isUnmergeable()) {
    for (; null !== (e2 = r2.getPreviousSibling()) && Qn(e2) && e2.isSimpleText() && !e2.isUnmergeable(); ) {
      if ("" !== e2.__text) {
        if (xt(e2, r2)) {
          r2 = Ct(e2, r2);
          break;
        }
        break;
      }
      e2.remove();
    }
    for (; null !== (n2 = r2.getNextSibling()) && Qn(n2) && n2.isSimpleText() && !n2.isUnmergeable(); ) {
      if ("" !== n2.__text) {
        if (xt(r2, n2)) {
          r2 = Ct(r2, n2);
          break;
        }
        break;
      }
      n2.remove();
    }
  } else r2.remove();
}
function vt(t3) {
  return kt(t3.anchor), kt(t3.focus), t3;
}
function kt(t3) {
  for (; "element" === t3.type; ) {
    const e2 = t3.getNode(), n2 = t3.offset;
    let r2, i2;
    if (n2 === e2.getChildrenSize() ? (r2 = e2.getChildAtIndex(n2 - 1), i2 = true) : (r2 = e2.getChildAtIndex(n2), i2 = false), Qn(r2)) {
      t3.set(r2.__key, i2 ? r2.getTextContentSize() : 0, "text", true);
      break;
    }
    if (!di(r2)) break;
    t3.set(r2.__key, i2 ? r2.getChildrenSize() : 0, "element", true);
  }
}
function Jt(t3, e2) {
  const n2 = At.get(t3);
  if (null !== e2) {
    const n3 = se(t3);
    n3.parentNode === e2 && e2.removeChild(n3);
  }
  if (Ot.has(t3) || bt._keyToDOMMap.delete(t3), di(n2)) {
    const t4 = te(n2, At);
    Ut(t4, 0, t4.length - 1, null);
  }
  void 0 !== n2 && Is(Pt, Nt, wt, n2, "destroyed");
}
function Ut(t3, e2, n2, r2) {
  let i2 = e2;
  for (; i2 <= n2; ++i2) {
    const e3 = t3[i2];
    void 0 !== e3 && Jt(e3, r2);
  }
}
function $t(t3, e2) {
  t3.setProperty("text-align", e2);
}
function Vt(t3, e2) {
  const n2 = Tt.theme.indent;
  if ("string" == typeof n2) {
    const r3 = t3.classList.contains(n2);
    e2 > 0 && !r3 ? t3.classList.add(n2) : e2 < 1 && r3 && t3.classList.remove(n2);
  }
  const r2 = getComputedStyle(t3).getPropertyValue("--lexical-indent-base-value") || jt;
  t3.style.setProperty("padding-inline-start", 0 === e2 ? "" : `calc(${e2} * ${r2})`);
}
function Yt(t3, e2) {
  const n2 = t3.style;
  0 === e2 ? $t(n2, "") : e2 === D ? $t(n2, "left") : e2 === P ? $t(n2, "center") : e2 === F ? $t(n2, "right") : e2 === L ? $t(n2, "justify") : e2 === I ? $t(n2, "start") : e2 === z && $t(n2, "end");
}
function Ht(e2, n2) {
  const r2 = Ot.get(e2);
  void 0 === r2 && t(60);
  const i2 = r2.createDOM(Tt, bt);
  if (function(t3, e3, n3) {
    const r3 = n3._keyToDOMMap;
    (function(t4, e4, n4) {
      const r4 = `__lexicalKey_${e4._key}`;
      t4[r4] = n4;
    })(e3, n3, t3), r3.set(t3, e3);
  }(e2, i2, bt), Qn(r2) ? i2.setAttribute("data-lexical-text", "true") : _i(r2) && i2.setAttribute("data-lexical-decorator", "true"), di(r2)) {
    const t3 = r2.__indent, e3 = r2.__size;
    if (0 !== t3 && Vt(i2, t3), 0 !== e3) {
      const t4 = e3 - 1;
      !function(t5, e4, n4, r3) {
        const i3 = Lt;
        Lt = "", qt(t5, n4, 0, e4, n4.getDOMSlot(r3)), Qt(n4, r3), Lt = i3;
      }(te(r2, Ot), t4, r2, i2);
    }
    const n3 = r2.__format;
    0 !== n3 && Yt(i2, n3), r2.isInline() || Xt(null, r2, i2), Js(r2) && (Ft += B, Kt += B);
  } else {
    const t3 = r2.getTextContent();
    if (_i(r2)) {
      const t4 = r2.decorate(bt, Tt);
      null !== t4 && ne(e2, t4), i2.contentEditable = "false";
    } else Qn(r2) && (r2.isDirectionless() || (Lt += t3));
    Ft += t3, Kt += t3;
  }
  return null !== n2 && n2.insertChild(i2), Is(Pt, Nt, wt, r2, "created"), i2;
}
function qt(t3, e2, n2, r2, i2) {
  const s2 = Ft;
  Ft = "";
  let o2 = n2;
  for (; o2 <= r2; ++o2) {
    Ht(t3[o2], i2);
    const e3 = Ot.get(t3[o2]);
    null !== e3 && Qn(e3) && (null === It && (It = e3.getFormat()), "" === zt && (zt = e3.getStyle()));
  }
  Js(e2) && (Ft += B);
  i2.element.__lexicalTextContent = Ft, Ft = s2 + Ft;
}
function Gt(t3, e2) {
  if (t3) {
    const n2 = t3.__last;
    if (n2) {
      const t4 = e2.get(n2);
      if (t4) return Fn(t4) ? "line-break" : _i(t4) && t4.isInline() ? "decorator" : null;
    }
    return "empty";
  }
  return null;
}
function Xt(t3, e2, n2) {
  const r2 = Gt(t3, At), i2 = Gt(e2, Ot);
  r2 !== i2 && e2.getDOMSlot(n2).setManagedLineBreak(i2);
}
function Qt(t3, e2) {
  const n2 = e2.__lexicalDirTextContent || "", r2 = e2.__lexicalDir || "";
  if (n2 !== Lt || r2 !== Wt) {
    const n3 = "" === Lt, i2 = n3 ? Wt : function(t4) {
      if (U.test(t4)) return "rtl";
      if ($.test(t4)) return "ltr";
      return null;
    }(Lt);
    if (i2 !== r2) {
      const s2 = e2.classList, o2 = Tt.theme;
      let l2 = null !== r2 ? o2[r2] : void 0, c2 = null !== i2 ? o2[i2] : void 0;
      if (void 0 !== l2) {
        if ("string" == typeof l2) {
          const t4 = d(l2);
          l2 = o2[r2] = t4;
        }
        s2.remove(...l2);
      }
      if (null === i2 || n3 && "ltr" === i2) e2.removeAttribute("dir");
      else {
        if (void 0 !== c2) {
          if ("string" == typeof c2) {
            const t4 = d(c2);
            c2 = o2[i2] = t4;
          }
          void 0 !== c2 && s2.add(...c2);
        }
        e2.dir = i2;
      }
      if (!Rt) {
        t3.getWritable().__dir = i2;
      }
    }
    Wt = i2, e2.__lexicalDirTextContent = Lt, e2.__lexicalDir = i2;
  }
}
function Zt(e2, n2, r2) {
  const i2 = Lt;
  var s2;
  Lt = "", It = null, zt = "", function(e3, n3, r3) {
    const i3 = Ft, s3 = e3.__size, o2 = n3.__size;
    Ft = "";
    const l2 = r3.element;
    if (1 === s3 && 1 === o2) {
      const t3 = e3.__first, r4 = n3.__first;
      if (t3 === r4) ee(t3, l2);
      else {
        const e4 = se(t3), n4 = Ht(r4, null);
        try {
          l2.replaceChild(n4, e4);
        } catch (i5) {
          if ("object" == typeof i5 && null != i5) {
            const s4 = `${i5.toString()} Parent: ${l2.tagName}, new child: {tag: ${n4.tagName} key: ${r4}}, old child: {tag: ${e4.tagName}, key: ${t3}}.`;
            throw new Error(s4);
          }
          throw i5;
        }
        Jt(t3, null);
      }
      const i4 = Ot.get(r4);
      Qn(i4) && (null === It && (It = i4.getFormat()), "" === zt && (zt = i4.getStyle()));
    } else {
      const i4 = te(e3, At), c2 = te(n3, Ot);
      if (i4.length !== s3 && t(227), c2.length !== o2 && t(228), 0 === s3) 0 !== o2 && qt(c2, n3, 0, o2 - 1, r3);
      else if (0 === o2) {
        if (0 !== s3) {
          const t3 = null == r3.after && null == r3.before && null == r3.element.__lexicalLineBreak;
          Ut(i4, 0, s3 - 1, t3 ? null : l2), t3 && (l2.textContent = "");
        }
      } else !function(t3, e4, n4, r4, i5, s4) {
        const o3 = r4 - 1, l3 = i5 - 1;
        let c3, a2, u2 = s4.getFirstChild(), f3 = 0, d3 = 0;
        for (; f3 <= o3 && d3 <= l3; ) {
          const t4 = e4[f3], r5 = n4[d3];
          if (t4 === r5) u2 = re(ee(r5, s4.element)), f3++, d3++;
          else {
            void 0 === c3 && (c3 = new Set(e4)), void 0 === a2 && (a2 = new Set(n4));
            const i7 = a2.has(t4), o4 = c3.has(r5);
            if (i7) if (o4) {
              const t5 = Us(bt, r5);
              t5 === u2 ? u2 = re(ee(r5, s4.element)) : (s4.withBefore(u2).insertChild(t5), ee(r5, s4.element)), f3++, d3++;
            } else Ht(r5, s4.withBefore(u2)), d3++;
            else u2 = re(se(t4)), Jt(t4, s4.element), f3++;
          }
          const i6 = Ot.get(r5);
          null !== i6 && Qn(i6) && (null === It && (It = i6.getFormat()), "" === zt && (zt = i6.getStyle()));
        }
        const h4 = f3 > o3, g4 = d3 > l3;
        if (h4 && !g4) {
          const e5 = n4[l3 + 1], r5 = void 0 === e5 ? null : bt.getElementByKey(e5);
          qt(n4, t3, d3, l3, s4.withBefore(r5));
        } else g4 && !h4 && Ut(e4, f3, o3, s4.element);
      }(n3, i4, c2, s3, o2, r3);
    }
    Js(n3) && (Ft += B);
    l2.__lexicalTextContent = Ft, Ft = i3 + Ft;
  }(e2, n2, n2.getDOMSlot(r2)), Qt(n2, r2), s2 = n2, null == It || It === s2.__textFormat || Rt || s2.setTextFormat(It), function(t3) {
    "" === zt || zt === t3.__textStyle || Rt || t3.setTextStyle(zt);
  }(n2), Lt = i2;
}
function te(e2, n2) {
  const r2 = [];
  let i2 = e2.__first;
  for (; null !== i2; ) {
    const e3 = n2.get(i2);
    void 0 === e3 && t(101), r2.push(i2), i2 = e3.__next;
  }
  return r2;
}
function ee(e2, n2) {
  const r2 = At.get(e2);
  let i2 = Ot.get(e2);
  void 0 !== r2 && void 0 !== i2 || t(61);
  const s2 = Bt || Mt.has(e2) || Et.has(e2), o2 = Us(bt, e2);
  if (r2 === i2 && !s2) {
    if (di(r2)) {
      const t3 = o2.__lexicalTextContent;
      void 0 !== t3 && (Ft += t3, Kt += t3);
      const e3 = o2.__lexicalDirTextContent;
      void 0 !== e3 && (Lt += e3);
    } else {
      const t3 = r2.getTextContent();
      Qn(r2) && !r2.isDirectionless() && (Lt += t3), Kt += t3, Ft += t3;
    }
    return o2;
  }
  if (r2 !== i2 && s2 && Is(Pt, Nt, wt, i2, "updated"), i2.updateDOM(r2, o2, Tt)) {
    const r3 = Ht(e2, null);
    return null === n2 && t(62), n2.replaceChild(r3, o2), Jt(e2, null), r3;
  }
  if (di(r2) && di(i2)) {
    const t3 = i2.__indent;
    t3 !== r2.__indent && Vt(o2, t3);
    const e3 = i2.__format;
    e3 !== r2.__format && Yt(o2, e3), s2 && (Zt(r2, i2, o2), yi(i2) || i2.isInline() || Xt(r2, i2, o2)), Js(i2) && (Ft += B, Kt += B);
  } else {
    const t3 = i2.getTextContent();
    if (_i(i2)) {
      const t4 = i2.decorate(bt, Tt);
      null !== t4 && ne(e2, t4);
    } else Qn(i2) && !i2.isDirectionless() && (Lt += t3);
    Ft += t3, Kt += t3;
  }
  if (!Rt && yi(i2) && i2.__cachedText !== Kt) {
    const t3 = i2.getWritable();
    t3.__cachedText = Kt, i2 = t3;
  }
  return o2;
}
function ne(t3, e2) {
  let n2 = bt._pendingDecorators;
  const r2 = bt._decorators;
  if (null === n2) {
    if (r2[t3] === e2) return;
    n2 = gs(bt);
  }
  n2[t3] = e2;
}
function re(t3) {
  let e2 = t3.nextSibling;
  return null !== e2 && e2 === bt._blockCursorElement && (e2 = e2.nextSibling), e2;
}
function ie(t3, e2, n2, r2, i2, s2) {
  Ft = "", Kt = "", Lt = "", Bt = r2 === x, Wt = null, bt = n2, Tt = n2._config, Nt = n2._nodes, wt = bt._listeners.mutation, Et = i2, Mt = s2, At = t3._nodeMap, Ot = e2._nodeMap, Rt = e2._readOnly, Dt = new Map(n2._keyToDOMMap);
  const o2 = /* @__PURE__ */ new Map();
  return Pt = o2, ee("root", null), bt = void 0, Nt = void 0, Et = void 0, Mt = void 0, At = void 0, Ot = void 0, Tt = void 0, Dt = void 0, Pt = void 0, o2;
}
function se(e2) {
  const n2 = Dt.get(e2);
  return void 0 === n2 && t(75, e2), n2;
}
function oe(t3) {
  return { type: t3 };
}
function _n(t3, e2, n2, r2, i2) {
  const o2 = t3.anchor, l2 = t3.focus, c2 = o2.getNode(), a2 = qr(), u2 = lo(Xs(a2)), f3 = null !== u2 ? u2.anchorNode : null, d3 = o2.key, h4 = a2.getElementByKey(d3), g4 = n2.length;
  return d3 !== l2.key || !Qn(c2) || (!i2 && (!s || rn < r2 + 50) || c2.isDirty() && g4 < 2 || Ss(n2)) && o2.offset !== l2.offset && !c2.isComposing() || Zi(c2) || c2.isDirty() && g4 > 1 || (i2 || !s) && null !== h4 && !c2.isComposing() && f3 !== ns(h4) || null !== u2 && null !== e2 && (!e2.collapsed || e2.startContainer !== u2.anchorNode || e2.startOffset !== u2.anchorOffset) || c2.getFormat() !== t3.format || c2.getStyle() !== t3.style || function(t4, e3) {
    if (e3.isSegmented()) return true;
    if (!t4.isCollapsed()) return false;
    const n3 = t4.anchor.offset, r3 = e3.getParentOrThrow(), i3 = Qi(e3);
    return 0 === n3 ? !e3.canInsertTextBefore() || !r3.canInsertTextBefore() && !e3.isComposing() || i3 || function(t5) {
      const e4 = t5.getPreviousSibling();
      return (Qn(e4) || di(e4) && e4.isInline()) && !e4.canInsertTextAfter();
    }(e3) : n3 === e3.getTextContentSize() && (!e3.canInsertTextAfter() || !r3.canInsertTextAfter() && !e3.isComposing() || i3);
  }(t3, c2);
}
function pn(t3, e2) {
  return ts(t3) && null !== t3.nodeValue && 0 !== e2 && e2 !== t3.nodeValue.length;
}
function yn(e2, n2, r2) {
  const { anchorNode: i2, anchorOffset: s2, focusNode: o2, focusOffset: l2 } = e2;
  ln && (ln = false, pn(i2, s2) && pn(o2, l2) && !hn) || ci(n2, () => {
    if (!r2) return void ms(null);
    if (!Hi(n2, i2, o2)) return;
    let c2 = Nr();
    if (hn && cr(c2) && c2.isCollapsed()) {
      const t3 = c2.anchor, e3 = hn.anchor;
      (t3.key === e3.key && t3.offset === e3.offset + 1 || 1 === t3.offset && e3.getNode().is(t3.getNode().getPreviousSibling())) && (c2 = hn.clone(), ms(c2));
    }
    if (hn = null, cr(c2)) {
      const r3 = c2.anchor, i3 = r3.getNode();
      if (c2.isCollapsed()) {
        "Range" === e2.type && e2.anchorNode === e2.focusNode && (c2.dirty = true);
        const s3 = Xs(n2).event, o3 = s3 ? s3.timeStamp : performance.now(), [l3, a2, u2, f3, d3] = gn, h4 = ps(), g4 = false === n2.isComposing() && "" === h4.getTextContent();
        if (o3 < d3 + 200 && r3.offset === u2 && r3.key === f3) mn(c2, l3, a2);
        else if ("text" === r3.type) Qn(i3) || t(141), xn(c2, i3);
        else if ("element" === r3.type && !g4) {
          di(i3) || t(259);
          const e3 = r3.getNode();
          e3.isEmpty() ? function(t3, e4) {
            const n3 = e4.getTextFormat(), r4 = e4.getTextStyle();
            mn(t3, n3, r4);
          }(c2, e3) : mn(c2, 0, "");
        }
      } else {
        const t3 = r3.key, e3 = c2.focus.key, n3 = c2.getNodes(), i4 = n3.length, o3 = c2.isBackward(), a2 = o3 ? l2 : s2, u2 = o3 ? s2 : l2, f3 = o3 ? e3 : t3, d3 = o3 ? t3 : e3;
        let h4 = O, g4 = false;
        for (let t4 = 0; t4 < i4; t4++) {
          const e4 = n3[t4], r4 = e4.getTextContentSize();
          if (Qn(e4) && 0 !== r4 && !(0 === t4 && e4.__key === f3 && a2 === r4 || t4 === i4 - 1 && e4.__key === d3 && 0 === u2) && (g4 = true, h4 &= e4.getFormat(), 0 === h4)) break;
        }
        c2.format = g4 ? h4 : 0;
      }
    }
    Ws(n2, le, void 0);
  });
}
function mn(t3, e2, n2) {
  t3.format === e2 && t3.style === n2 || (t3.format = e2, t3.style = n2, t3.dirty = true);
}
function xn(t3, e2) {
  mn(t3, e2.getFormat(), e2.getStyle());
}
function Cn(t3) {
  if (!t3.getTargetRanges) return null;
  const e2 = t3.getTargetRanges();
  return 0 === e2.length ? null : e2[0];
}
function Sn(t3, e2) {
  const n2 = t3._compositionKey;
  if (cs(null), null !== n2 && null != e2) {
    if ("" === e2) {
      const e3 = us(n2), r2 = ns(t3.getElementByKey(n2));
      return void (null !== r2 && null !== r2.nodeValue && Qn(e3) && Ns(e3, r2.nodeValue, null, null, true));
    }
    if ("\n" === e2[e2.length - 1]) {
      const e3 = Nr();
      if (cr(e3)) {
        const n3 = e3.focus;
        return e3.anchor.set(n3.key, n3.offset, n3.type), void Ws(t3, Ee, null);
      }
    }
  }
  bs(true, t3, e2);
}
function vn(t3) {
  let e2 = t3.__lexicalEventHandles;
  return void 0 === e2 && (e2 = [], t3.__lexicalEventHandles = e2), e2;
}
function Tn(t3) {
  const e2 = co(t3.target);
  if (null === e2) return;
  const n2 = Gi(e2.anchorNode);
  if (null === n2) return;
  cn && (cn = false, ci(n2, () => {
    const r3 = wr(), i3 = e2.anchorNode;
    if (fo(i3) || ts(i3)) {
      ms(br(r3, e2, n2, t3));
    }
  }));
  const r2 = vs(n2), i2 = r2[r2.length - 1], s2 = i2._key, o2 = kn.get(s2), l2 = o2 || i2;
  l2 !== n2 && yn(e2, l2, false), yn(e2, n2, true), n2 !== i2 ? kn.set(s2, n2) : o2 && kn.delete(s2);
}
function bn(t3) {
  t3._lexicalHandled = true;
}
function Nn(t3) {
  return true === t3._lexicalHandled;
}
function En(e2) {
  const n2 = e2.ownerDocument, r2 = on.get(n2);
  if (void 0 === r2) return void wn();
  const i2 = r2 - 1;
  i2 >= 0 || t(164), on.set(n2, i2), 0 === i2 && n2.removeEventListener("selectionchange", Tn);
  const s2 = Xi(e2);
  qi(s2) ? (!function(t3) {
    if (null !== t3._parentEditor) {
      const e3 = vs(t3), n3 = e3[e3.length - 1]._key;
      kn.get(n3) === t3 && kn.delete(n3);
    } else kn.delete(t3._key);
  }(s2), e2.__lexicalEditor = null) : s2 && t(198);
  const o2 = vn(e2);
  for (let t3 = 0; t3 < o2.length; t3++) o2[t3]();
  e2.__lexicalEventHandles = [];
}
function Mn(t3, e2, n2) {
  Vr();
  const r2 = t3.__key, i2 = t3.getParent();
  if (null === i2) return;
  const s2 = function(t4) {
    const e3 = Nr();
    if (!cr(e3) || !di(t4)) return e3;
    const { anchor: n3, focus: r3 } = e3, i3 = n3.getNode(), s3 = r3.getNode();
    qs(i3, t4) && n3.set(t4.__key, 0, "element");
    qs(s3, t4) && r3.set(t4.__key, 0, "element");
    return e3;
  }(t3);
  let o2 = false;
  if (cr(s2) && e2) {
    const e3 = s2.anchor, n3 = s2.focus;
    e3.key === r2 && (Ar(e3, t3, i2, t3.getPreviousSibling(), t3.getNextSibling()), o2 = true), n3.key === r2 && (Ar(n3, t3, i2, t3.getPreviousSibling(), t3.getNextSibling()), o2 = true);
  } else ur(s2) && e2 && t3.isSelected() && t3.selectPrevious();
  if (cr(s2) && e2 && !o2) {
    const e3 = t3.getIndexWithinParent();
    os(t3), Er(s2, i2, e3, -1);
  } else os(t3);
  n2 || to(i2) || i2.canBeEmpty() || !i2.isEmpty() || Mn(i2, e2), e2 && s2 && yi(i2) && i2.isEmpty() && i2.selectEnd();
}
function Dn(t3) {
  return { node: Pn() };
}
function Pn() {
  return no(new On());
}
function Fn(t3) {
  return t3 instanceof On;
}
function Ln(t3) {
  return ts(t3) && /^( |\t|\r?\n)+$/.test(t3.textContent || "");
}
function In(t3, e2) {
  return 16 & e2 ? "code" : e2 & A ? "mark" : 32 & e2 ? "sub" : 64 & e2 ? "sup" : null;
}
function zn(t3, e2) {
  return 1 & e2 ? "strong" : 2 & e2 ? "em" : "span";
}
function Kn(t3, e2, n2, r2, i2) {
  const s2 = r2.classList;
  let o2 = Ls(i2, "base");
  void 0 !== o2 && s2.add(...o2), o2 = Ls(i2, "underlineStrikethrough");
  let l2 = false;
  const c2 = e2 & N && e2 & b;
  void 0 !== o2 && (n2 & N && n2 & b ? (l2 = true, c2 || s2.add(...o2)) : c2 && s2.remove(...o2));
  for (const t4 in j) {
    const r3 = j[t4];
    if (o2 = Ls(i2, t4), void 0 !== o2) if (n2 & r3) {
      if (l2 && ("underline" === t4 || "strikethrough" === t4)) {
        e2 & r3 && s2.remove(...o2);
        continue;
      }
      e2 & r3 && (!c2 || "underline" !== t4) && "strikethrough" !== t4 || s2.add(...o2);
    } else e2 & r3 && s2.remove(...o2);
  }
}
function Bn(t3, e2, n2) {
  const r2 = e2.firstChild, s2 = n2.isComposing(), o2 = t3 + (s2 ? K : "");
  if (null == r2) e2.textContent = o2;
  else {
    const t4 = r2.nodeValue;
    if (t4 !== o2) if (s2 || i) {
      const [e3, n3, i2] = function(t5, e4) {
        const n4 = t5.length, r3 = e4.length;
        let i3 = 0, s3 = 0;
        for (; i3 < n4 && i3 < r3 && t5[i3] === e4[i3]; ) i3++;
        for (; s3 + i3 < n4 && s3 + i3 < r3 && t5[n4 - s3 - 1] === e4[r3 - s3 - 1]; ) s3++;
        return [i3, n4 - i3 - s3, e4.slice(i3, r3 - s3)];
      }(t4, o2);
      0 !== n3 && r2.deleteData(e3, n3), r2.insertData(e3, i2);
    } else r2.nodeValue = o2;
  }
}
function Rn(t3, e2, n2, r2, i2, s2) {
  Bn(i2, t3, e2);
  const o2 = s2.theme.text;
  void 0 !== o2 && Kn(0, 0, r2, t3, o2);
}
function Wn(t3, e2) {
  const n2 = document.createElement(e2);
  return n2.appendChild(t3), n2;
}
function Un(t3) {
  return { forChild: Zn(t3.style), node: null };
}
function $n(t3) {
  const e2 = t3, n2 = "normal" === e2.style.fontWeight;
  return { forChild: Zn(e2.style, n2 ? void 0 : "bold"), node: null };
}
function Vn(t3) {
  if (!fo(t3)) return false;
  if ("PRE" === t3.nodeName) return true;
  const e2 = t3.style.whiteSpace;
  return "string" == typeof e2 && e2.startsWith("pre");
}
function Yn(e2) {
  const n2 = e2;
  null === e2.parentElement && t(129);
  let r2 = n2.textContent || "";
  if (null !== function(t3) {
    let e3, n3 = t3.parentNode;
    const r3 = [t3];
    for (; null !== n3 && void 0 === (e3 = jn.get(n3)) && !Vn(n3); ) r3.push(n3), n3 = n3.parentNode;
    const i2 = void 0 === e3 ? n3 : e3;
    for (let t4 = 0; t4 < r3.length; t4++) jn.set(r3[t4], i2);
    return i2;
  }(n2)) {
    const t3 = r2.split(/(\r?\n|\t)/), e3 = [], n3 = t3.length;
    for (let r3 = 0; r3 < n3; r3++) {
      const n4 = t3[r3];
      "\n" === n4 || "\r\n" === n4 ? e3.push(Pn()) : "	" === n4 ? e3.push(er()) : "" !== n4 && e3.push(Xn(n4));
    }
    return { node: e3 };
  }
  if (r2 = r2.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), "" === r2) return { node: null };
  if (" " === r2[0]) {
    let t3 = n2, e3 = true;
    for (; null !== t3 && null !== (t3 = Hn(t3, false)); ) {
      const n3 = t3.textContent || "";
      if (n3.length > 0) {
        /[ \t\n]$/.test(n3) && (r2 = r2.slice(1)), e3 = false;
        break;
      }
    }
    e3 && (r2 = r2.slice(1));
  }
  if (" " === r2[r2.length - 1]) {
    let t3 = n2, e3 = true;
    for (; null !== t3 && null !== (t3 = Hn(t3, true)); ) {
      if ((t3.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        e3 = false;
        break;
      }
    }
    e3 && (r2 = r2.slice(0, r2.length - 1));
  }
  return "" === r2 ? { node: null } : { node: Xn(r2) };
}
function Hn(t3, e2) {
  let n2 = t3;
  for (; ; ) {
    let t4;
    for (; null === (t4 = e2 ? n2.nextSibling : n2.previousSibling); ) {
      const t5 = n2.parentElement;
      if (null === t5) return null;
      n2 = t5;
    }
    if (n2 = t4, fo(n2)) {
      const t5 = n2.style.display;
      if ("" === t5 && !_o(n2) || "" !== t5 && !t5.startsWith("inline")) return null;
    }
    let r2 = n2;
    for (; null !== (r2 = e2 ? n2.firstChild : n2.lastChild); ) n2 = r2;
    if (ts(n2)) return n2;
    if ("BR" === n2.nodeName) return null;
  }
}
function Gn(t3) {
  const e2 = qn[t3.nodeName.toLowerCase()];
  return void 0 === e2 ? { node: null } : { forChild: Zn(t3.style, e2), node: null };
}
function Xn(t3 = "") {
  return no(new Jn(t3));
}
function Qn(t3) {
  return t3 instanceof Jn;
}
function Zn(t3, e2) {
  const n2 = t3.fontWeight, r2 = t3.textDecoration.split(" "), i2 = "700" === n2 || "bold" === n2, s2 = r2.includes("line-through"), o2 = "italic" === t3.fontStyle, l2 = r2.includes("underline"), c2 = t3.verticalAlign;
  return (t4) => Qn(t4) ? (i2 && !t4.hasFormat("bold") && t4.toggleFormat("bold"), s2 && !t4.hasFormat("strikethrough") && t4.toggleFormat("strikethrough"), o2 && !t4.hasFormat("italic") && t4.toggleFormat("italic"), l2 && !t4.hasFormat("underline") && t4.toggleFormat("underline"), "sub" !== c2 || t4.hasFormat("subscript") || t4.toggleFormat("subscript"), "super" !== c2 || t4.hasFormat("superscript") || t4.toggleFormat("superscript"), e2 && !t4.hasFormat(e2) && t4.toggleFormat(e2), t4) : t4;
}
function er() {
  return no(new tr());
}
function nr(t3) {
  return t3 instanceof tr;
}
function ir(t3, e2, n2) {
  return new rr(t3, e2, n2);
}
function sr(t3, e2) {
  let n2 = e2.__key, r2 = t3.offset, i2 = "element";
  if (Qn(e2)) {
    i2 = "text";
    const t4 = e2.getTextContentSize();
    r2 > t4 && (r2 = t4);
  } else if (!di(e2)) {
    const t4 = e2.getNextSibling();
    if (Qn(t4)) n2 = t4.__key, r2 = 0, i2 = "text";
    else {
      const t5 = e2.getParent();
      t5 && (n2 = t5.__key, r2 = e2.getIndexWithinParent() + 1);
    }
  }
  t3.set(n2, r2, i2);
}
function or(t3, e2) {
  if (di(e2)) {
    const n2 = e2.getLastDescendant();
    di(n2) || Qn(n2) ? sr(t3, n2) : sr(t3, e2);
  } else sr(t3, e2);
}
function cr(t3) {
  return t3 instanceof ar;
}
function ur(t3) {
  return t3 instanceof lr;
}
function fr(t3) {
  const e2 = t3.offset;
  if ("text" === t3.type) return e2;
  const n2 = t3.getNode();
  return e2 === n2.getChildrenSize() ? n2.getTextContent().length : 0;
}
function dr(t3) {
  const e2 = t3.getStartEndPoints();
  if (null === e2) return [0, 0];
  const [n2, r2] = e2;
  return "element" === n2.type && "element" === r2.type && n2.key === r2.key && n2.offset === r2.offset ? [0, 0] : [fr(n2), fr(r2)];
}
function hr(t3, e2) {
  for (let n2 = e2; n2; n2 = n2.getParent()) {
    if (di(n2)) {
      if (n2.collapseAtStart(t3)) return true;
      if (to(n2)) break;
    }
    if (n2.getPreviousSibling()) break;
  }
  return false;
}
function _r(t3, e2, n2) {
  const r2 = t3, i2 = r2.getTextContent().split(/(?=\s)/g), s2 = i2.length;
  let o2 = 0, l2 = 0;
  for (let t4 = 0; t4 < s2; t4++) {
    const r3 = t4 === s2 - 1;
    if (l2 = o2, o2 += i2[t4].length, e2 && o2 === n2 || o2 > n2 || r3) {
      i2.splice(t4, 1), r3 && (l2 = void 0);
      break;
    }
  }
  const c2 = i2.join("").trim();
  "" === c2 ? r2.remove() : (r2.setTextContent(c2), r2.select(l2, l2));
}
function pr(e2, n2, r2, i2) {
  let s2, o2 = n2;
  if (fo(e2)) {
    let l2 = false;
    const c2 = e2.childNodes, a2 = c2.length, u2 = i2._blockCursorElement;
    o2 === a2 && (l2 = true, o2 = a2 - 1);
    let f3 = c2[o2], d3 = false;
    if (f3 === u2) f3 = c2[o2 + 1], d3 = true;
    else if (null !== u2) {
      const t3 = u2.parentNode;
      if (e2 === t3) {
        n2 > Array.prototype.indexOf.call(t3.children, u2) && o2--;
      }
    }
    if (s2 = xs(f3), Qn(s2)) o2 = Cs(s2, l2);
    else {
      let c3 = xs(e2);
      if (null === c3) return null;
      if (di(c3)) {
        const a3 = i2.getElementByKey(c3.getKey());
        null === a3 && t(214);
        const u3 = c3.getDOMSlot(a3);
        [c3, o2] = u3.resolveChildIndex(c3, a3, e2, n2), di(c3) || t(215), l2 && o2 >= c3.getChildrenSize() && (o2 = Math.max(0, c3.getChildrenSize() - 1));
        let f4 = c3.getChildAtIndex(o2);
        if (di(f4) && function(t3, e3, n3) {
          const r3 = t3.getParent();
          return null === n3 || null === r3 || !r3.canBeEmpty() || r3 !== n3.getNode();
        }(f4, 0, r2)) {
          const t3 = l2 ? f4.getLastDescendant() : f4.getFirstDescendant();
          null === t3 ? c3 = f4 : (f4 = t3, c3 = di(f4) ? f4 : f4.getParentOrThrow()), o2 = 0;
        }
        Qn(f4) ? (s2 = f4, c3 = null, o2 = Cs(f4, l2)) : f4 !== c3 && l2 && !d3 && (di(c3) || t(216), o2 = Math.min(c3.getChildrenSize(), o2 + 1));
      } else {
        const t3 = c3.getIndexWithinParent();
        o2 = 0 === n2 && _i(c3) && xs(e2) === c3 ? t3 : t3 + 1, c3 = c3.getParentOrThrow();
      }
      if (di(c3)) return ir(c3.__key, o2, "element");
    }
  } else s2 = xs(e2);
  return Qn(s2) ? ir(s2.__key, o2, "text") : null;
}
function yr(t3, e2, n2) {
  const r2 = t3.offset, i2 = t3.getNode();
  if (0 === r2) {
    const r3 = i2.getPreviousSibling(), s2 = i2.getParent();
    if (e2) {
      if ((n2 || !e2) && null === r3 && di(s2) && s2.isInline()) {
        const e3 = s2.getPreviousSibling();
        Qn(e3) && t3.set(e3.__key, e3.getTextContent().length, "text");
      }
    } else di(r3) && !n2 && r3.isInline() ? t3.set(r3.__key, r3.getChildrenSize(), "element") : Qn(r3) && t3.set(r3.__key, r3.getTextContent().length, "text");
  } else if (r2 === i2.getTextContent().length) {
    const r3 = i2.getNextSibling(), s2 = i2.getParent();
    if (e2 && di(r3) && r3.isInline()) t3.set(r3.__key, 0, "element");
    else if ((n2 || e2) && null === r3 && di(s2) && s2.isInline() && !s2.canInsertTextAfter()) {
      const e3 = s2.getNextSibling();
      Qn(e3) && t3.set(e3.__key, 0, "text");
    }
  }
}
function mr(t3, e2, n2) {
  if ("text" === t3.type && "text" === e2.type) {
    const r2 = t3.isBefore(e2), i2 = t3.is(e2);
    yr(t3, r2, i2), yr(e2, !r2, i2), i2 && e2.set(t3.key, t3.offset, t3.type);
    const s2 = qr();
    if (s2.isComposing() && s2._compositionKey !== t3.key && cr(n2)) {
      const r3 = n2.anchor, i3 = n2.focus;
      t3.set(r3.key, r3.offset, r3.type, true), e2.set(i3.key, i3.offset, i3.type, true);
    }
  }
}
function xr(t3, e2, n2, r2, i2, s2) {
  if (null === t3 || null === n2 || !Hi(i2, t3, n2)) return null;
  const o2 = pr(t3, e2, cr(s2) ? s2.anchor : null, i2);
  if (null === o2) return null;
  const l2 = pr(n2, r2, cr(s2) ? s2.focus : null, i2);
  if (null === l2) return null;
  if ("element" === o2.type && "element" === l2.type) {
    const e3 = xs(t3), r3 = xs(n2);
    if (_i(e3) && _i(r3)) return null;
  }
  return mr(o2, l2, s2), [o2, l2];
}
function Cr(t3) {
  return di(t3) && !t3.isInline();
}
function Sr(t3, e2, n2, r2, i2, s2) {
  const o2 = Hr(), l2 = new ar(ir(t3, e2, i2), ir(n2, r2, s2), 0, "");
  return l2.dirty = true, o2._selection = l2, l2;
}
function vr() {
  const t3 = ir("root", 0, "element"), e2 = ir("root", 0, "element");
  return new ar(t3, e2, 0, "");
}
function kr() {
  return new lr(/* @__PURE__ */ new Set());
}
function Tr(t3, e2) {
  return br(null, t3, e2, null);
}
function br(t3, e2, n2, r2) {
  const i2 = n2._window;
  if (null === i2) return null;
  const s2 = r2 || i2.event, o2 = s2 ? s2.type : void 0, l2 = "selectionchange" === o2, c2 = !tt && (l2 || "beforeinput" === o2 || "compositionstart" === o2 || "compositionend" === o2 || "click" === o2 && s2 && 3 === s2.detail || "drop" === o2 || void 0 === o2);
  let a2, u2, f3, d3;
  if (cr(t3) && !c2) return t3.clone();
  if (null === e2) return null;
  if (a2 = e2.anchorNode, u2 = e2.focusNode, f3 = e2.anchorOffset, d3 = e2.focusOffset, l2 && cr(t3) && !Hi(n2, a2, u2)) return t3.clone();
  const h4 = xr(a2, f3, u2, d3, n2, t3);
  if (null === h4) return null;
  const [g4, _5] = h4;
  return new ar(g4, _5, cr(t3) ? t3.format : 0, cr(t3) ? t3.style : "");
}
function Nr() {
  return Hr()._selection;
}
function wr() {
  return qr()._editorState._selection;
}
function Er(t3, e2, n2, r2 = 1) {
  const i2 = t3.anchor, s2 = t3.focus, o2 = i2.getNode(), l2 = s2.getNode();
  if (!e2.is(o2) && !e2.is(l2)) return;
  const c2 = e2.__key;
  if (t3.isCollapsed()) {
    const e3 = i2.offset;
    if (n2 <= e3 && r2 > 0 || n2 < e3 && r2 < 0) {
      const n3 = Math.max(0, e3 + r2);
      i2.set(c2, n3, "element"), s2.set(c2, n3, "element"), Mr(t3);
    }
  } else {
    const o3 = t3.isBackward(), l3 = o3 ? s2 : i2, a2 = l3.getNode(), u2 = o3 ? i2 : s2, f3 = u2.getNode();
    if (e2.is(a2)) {
      const t4 = l3.offset;
      (n2 <= t4 && r2 > 0 || n2 < t4 && r2 < 0) && l3.set(c2, Math.max(0, t4 + r2), "element");
    }
    if (e2.is(f3)) {
      const t4 = u2.offset;
      (n2 <= t4 && r2 > 0 || n2 < t4 && r2 < 0) && u2.set(c2, Math.max(0, t4 + r2), "element");
    }
  }
  Mr(t3);
}
function Mr(t3) {
  const e2 = t3.anchor, n2 = e2.offset, r2 = t3.focus, i2 = r2.offset, s2 = e2.getNode(), o2 = r2.getNode();
  if (t3.isCollapsed()) {
    if (!di(s2)) return;
    const t4 = s2.getChildrenSize(), i3 = n2 >= t4, o3 = i3 ? s2.getChildAtIndex(t4 - 1) : s2.getChildAtIndex(n2);
    if (Qn(o3)) {
      let t5 = 0;
      i3 && (t5 = o3.getTextContentSize()), e2.set(o3.__key, t5, "text"), r2.set(o3.__key, t5, "text");
    }
  } else {
    if (di(s2)) {
      const t4 = s2.getChildrenSize(), r3 = n2 >= t4, i3 = r3 ? s2.getChildAtIndex(t4 - 1) : s2.getChildAtIndex(n2);
      if (Qn(i3)) {
        let t5 = 0;
        r3 && (t5 = i3.getTextContentSize()), e2.set(i3.__key, t5, "text");
      }
    }
    if (di(o2)) {
      const t4 = o2.getChildrenSize(), e3 = i2 >= t4, n3 = e3 ? o2.getChildAtIndex(t4 - 1) : o2.getChildAtIndex(i2);
      if (Qn(n3)) {
        let t5 = 0;
        e3 && (t5 = n3.getTextContentSize()), r2.set(n3.__key, t5, "text");
      }
    }
  }
}
function Ar(t3, e2, n2, r2, i2) {
  let s2 = null, o2 = 0, l2 = null;
  null !== r2 ? (s2 = r2.__key, Qn(r2) ? (o2 = r2.getTextContentSize(), l2 = "text") : di(r2) && (o2 = r2.getChildrenSize(), l2 = "element")) : null !== i2 && (s2 = i2.__key, Qn(i2) ? l2 = "text" : di(i2) && (l2 = "element")), null !== s2 && null !== l2 ? t3.set(s2, o2, l2) : (o2 = e2.getIndexWithinParent(), -1 === o2 && (o2 = n2.getChildrenSize()), t3.set(n2.__key, o2, "element"));
}
function Or(t3, e2, n2, r2, i2) {
  "text" === t3.type ? t3.set(n2, t3.offset + (e2 ? 0 : i2), "text") : t3.offset > r2.getIndexWithinParent() && t3.set(t3.key, t3.offset - 1, "element");
}
function Dr(t3, e2, n2, r2, i2) {
  try {
    t3.setBaseAndExtent(e2, n2, r2, i2);
  } catch (t4) {
  }
}
function Pr(t3, e2, n2, r2, i2, s2, o2) {
  const l2 = r2.anchorNode, c2 = r2.focusNode, a2 = r2.anchorOffset, u2 = r2.focusOffset, f3 = document.activeElement;
  if (i2.has(Ni) && f3 !== s2 || null !== f3 && Yi(f3)) return;
  if (!cr(e2)) return void (null !== t3 && Hi(n2, l2, c2) && r2.removeAllRanges());
  const d3 = e2.anchor, h4 = e2.focus, g4 = d3.key, _5 = h4.key, p3 = Us(n2, g4), y4 = Us(n2, _5), m4 = d3.offset, x4 = h4.offset, C4 = e2.format, S4 = e2.style, v4 = e2.isCollapsed();
  let k5 = p3, T5 = y4, b3 = false;
  if ("text" === d3.type) {
    k5 = ns(p3);
    const t4 = d3.getNode();
    b3 = t4.getFormat() !== C4 || t4.getStyle() !== S4;
  } else cr(t3) && "text" === t3.anchor.type && (b3 = true);
  var N5, w4, E4, M6, A4;
  if (("text" === h4.type && (T5 = ns(y4)), null !== k5 && null !== T5) && (v4 && (null === t3 || b3 || cr(t3) && (t3.format !== C4 || t3.style !== S4)) && (N5 = C4, w4 = S4, E4 = m4, M6 = g4, A4 = performance.now(), gn = [N5, w4, E4, M6, A4]), a2 !== m4 || u2 !== x4 || l2 !== k5 || c2 !== T5 || "Range" === r2.type && v4 || (null !== f3 && s2.contains(f3) || s2.focus({ preventScroll: true }), "element" === d3.type))) {
    if (Dr(r2, k5, m4, T5, x4), !i2.has(Ei) && e2.isCollapsed() && null !== s2 && s2 === document.activeElement) {
      const t4 = cr(e2) && "element" === e2.anchor.type ? k5.childNodes[m4] || null : r2.rangeCount > 0 ? r2.getRangeAt(0) : null;
      if (null !== t4) {
        let e3;
        if (t4 instanceof Text) {
          const n3 = document.createRange();
          n3.selectNode(t4), e3 = n3.getBoundingClientRect();
        } else e3 = t4.getBoundingClientRect();
        !function(t5, e4, n3) {
          const r3 = js(n3), i3 = Gs(r3);
          if (null === r3 || null === i3) return;
          let { top: s3, bottom: o3 } = e4, l3 = 0, c3 = 0, a3 = n3;
          for (; null !== a3; ) {
            const e5 = a3 === r3.body;
            if (e5) l3 = 0, c3 = Xs(t5).innerHeight;
            else {
              const t6 = a3.getBoundingClientRect();
              l3 = t6.top, c3 = t6.bottom;
            }
            let n4 = 0;
            if (s3 < l3 ? n4 = -(l3 - s3) : o3 > c3 && (n4 = o3 - c3), 0 !== n4) if (e5) i3.scrollBy(0, n4);
            else {
              const t6 = a3.scrollTop;
              a3.scrollTop += n4;
              const e6 = a3.scrollTop - t6;
              s3 -= e6, o3 -= e6;
            }
            if (e5) break;
            a3 = $s(a3);
          }
        }(n2, e3, s2);
      }
    }
    ln = true;
  }
}
function Fr(t3) {
  let e2 = Nr() || wr();
  null === e2 && (e2 = ps().selectEnd()), e2.insertNodes(t3);
}
function Lr() {
  const t3 = Nr();
  return null === t3 ? "" : t3.getTextContent();
}
function Ir(e2) {
  let n2 = e2;
  e2.isCollapsed() || n2.removeText();
  const r2 = Nr();
  cr(r2) && (n2 = r2), cr(n2) || t(161);
  const i2 = n2.anchor;
  let s2 = i2.getNode(), o2 = i2.offset;
  for (; !yo(s2); ) {
    const t3 = s2;
    if ([s2, o2] = zr(s2, o2), t3.is(s2)) break;
  }
  return o2;
}
function zr(t3, e2) {
  const n2 = t3.getParent();
  if (!n2) {
    const t4 = Pi();
    return ps().append(t4), t4.select(), [ps(), 0];
  }
  if (Qn(t3)) {
    const r3 = t3.splitText(e2);
    if (0 === r3.length) return [n2, t3.getIndexWithinParent()];
    const i2 = 0 === e2 ? 0 : 1;
    return [n2, r3[0].getIndexWithinParent() + i2];
  }
  if (!di(t3) || 0 === e2) return [n2, t3.getIndexWithinParent()];
  const r2 = t3.getChildAtIndex(e2);
  if (r2) {
    const n3 = new ar(ir(t3.__key, e2, "element"), ir(t3.__key, e2, "element"), 0, ""), i2 = t3.insertNewAfter(n3);
    i2 && i2.append(r2, ...r2.getNextSiblings());
  }
  return [n2, t3.getIndexWithinParent() + 1];
}
function Kr(t3, e2, n2, r2, i2 = "decorators-and-blocks") {
  if ("move" === e2 && "character" === r2 && !t3.isCollapsed()) {
    const [e3, r3] = n2 === t3.isBackward() ? [t3.focus, t3.anchor] : [t3.anchor, t3.focus];
    return r3.set(e3.key, e3.offset, e3.type), true;
  }
  const s2 = ll(t3.focus, n2 ? "previous" : "next"), o2 = "lineboundary" === r2, l2 = "move" === e2;
  let c2 = s2, a2 = "decorators-and-blocks" === i2;
  if (!yl(c2)) {
    for (const t4 of c2) {
      a2 = false;
      const { origin: e3 } = t4;
      if (!_i(e3) || e3.isIsolated() || (c2 = t4, !o2 || !e3.isInline())) break;
    }
    if (a2) for (const t4 of Qo(s2).iterNodeCarets("extend" === e2 ? "shadowRoot" : "root")) {
      if (Ko(t4)) t4.origin.isInline() || (c2 = t4);
      else {
        if (di(t4.origin)) continue;
        _i(t4.origin) && !t4.origin.isInline() && (c2 = t4);
      }
      break;
    }
  }
  if (c2 === s2) return false;
  if (l2 && !o2 && _i(c2.origin) && c2.origin.isKeyboardSelectable()) {
    const t4 = kr();
    return t4.add(c2.origin.getKey()), ms(t4), true;
  }
  return c2 = pl(c2), l2 && cl(t3.anchor, c2), cl(t3.focus, c2), a2 || !o2;
}
function jr() {
  return Wr || null !== Br && Br._readOnly;
}
function Vr() {
  Wr && t(13);
}
function Yr() {
  Ur > 99 && t(14);
}
function Hr() {
  return null === Br && t(195, Gr()), Br;
}
function qr() {
  return null === Rr && t(196, Gr()), Rr;
}
function Gr() {
  let t3 = 0;
  const e2 = /* @__PURE__ */ new Set(), n2 = Ji.version;
  if ("undefined" != typeof window) for (const r3 of document.querySelectorAll("[contenteditable]")) {
    const i2 = Xi(r3);
    if (qi(i2)) t3++;
    else if (i2) {
      let t4 = String(i2.constructor.version || "<0.17.1");
      t4 === n2 && (t4 += " (separately built, likely a bundler configuration issue)"), e2.add(t4);
    }
  }
  let r2 = ` Detected on the page: ${t3} compatible editor(s) with version ${n2}`;
  return e2.size && (r2 += ` and incompatible editors with versions ${Array.from(e2).join(", ")}`), r2;
}
function Xr() {
  return Rr;
}
function Qr(e2, n2, r2) {
  const i2 = n2.__type, s2 = function(e3, n3) {
    const r3 = e3._nodes.get(n3);
    void 0 === r3 && t(30, n3);
    return r3;
  }(e2, i2);
  let o2 = r2.get(i2);
  void 0 === o2 && (o2 = Array.from(s2.transforms), r2.set(i2, o2));
  const l2 = o2.length;
  for (let t3 = 0; t3 < l2 && (o2[t3](n2), n2.isAttached()); t3++) ;
}
function Zr(t3, e2) {
  return void 0 !== t3 && t3.__key !== e2 && t3.isAttached();
}
function ti(t3, e2) {
  if (!e2) return;
  const n2 = t3._updateTags;
  let r2 = e2;
  Array.isArray(e2) || (r2 = [e2]);
  for (const t4 of r2) n2.add(t4);
}
function ei(t3) {
  return ni(t3, qr()._nodes);
}
function ni(e2, n2) {
  const r2 = e2.type, i2 = n2.get(r2);
  void 0 === i2 && t(17, r2);
  const s2 = i2.klass;
  e2.type !== s2.getType() && t(18, s2.name);
  const o2 = s2.importJSON(e2), l2 = e2.children;
  if (di(o2) && Array.isArray(l2)) for (let t3 = 0; t3 < l2.length; t3++) {
    const e3 = ni(l2[t3], n2);
    o2.append(e3);
  }
  return o2;
}
function ri(t3, e2, n2) {
  const r2 = Br, i2 = Wr, s2 = Rr;
  Br = e2, Wr = true, Rr = t3;
  try {
    return n2();
  } finally {
    Br = r2, Wr = i2, Rr = s2;
  }
}
function ii(t3, e2) {
  const n2 = t3._pendingEditorState, r2 = t3._rootElement, i2 = t3._headless || null === r2;
  if (null === n2) return;
  const s2 = t3._editorState, o2 = s2._selection, l2 = n2._selection, c2 = t3._dirtyType !== y, a2 = Br, u2 = Wr, f3 = Rr, h4 = t3._updating, g4 = t3._observer;
  let _5 = null;
  if (t3._pendingEditorState = null, t3._editorState = n2, !i2 && c2 && null !== g4) {
    Rr = t3, Br = n2, Wr = false, t3._updating = true;
    try {
      const e3 = t3._dirtyType, r3 = t3._dirtyElements, i3 = t3._dirtyLeaves;
      g4.disconnect(), _5 = ie(s2, n2, t3, e3, r3, i3);
    } catch (e3) {
      if (e3 instanceof Error && t3._onError(e3), Jr) throw e3;
      return Ri(t3, null, r2, n2), at(t3), t3._dirtyType = x, Jr = true, ii(t3, s2), void (Jr = false);
    } finally {
      g4.observe(r2, $r), t3._updating = h4, Br = a2, Wr = u2, Rr = f3;
    }
  }
  n2._readOnly || (n2._readOnly = true);
  const p3 = t3._dirtyLeaves, m4 = t3._dirtyElements, C4 = t3._normalizedNodes, S4 = t3._updateTags, v4 = t3._deferred;
  c2 && (t3._dirtyType = y, t3._cloneNotNeeded.clear(), t3._dirtyLeaves = /* @__PURE__ */ new Set(), t3._dirtyElements = /* @__PURE__ */ new Map(), t3._normalizedNodes = /* @__PURE__ */ new Set(), t3._updateTags = /* @__PURE__ */ new Set()), function(t4, e3) {
    const n3 = t4._decorators;
    let r3 = t4._pendingDecorators || n3;
    const i3 = e3._nodeMap;
    let s3;
    for (s3 in r3) i3.has(s3) || (r3 === n3 && (r3 = gs(t4)), delete r3[s3]);
  }(t3, n2);
  const k5 = i2 ? null : lo(Xs(t3));
  if (t3._editable && null !== k5 && (c2 || null === l2 || l2.dirty) && null !== r2 && !S4.has(Mi)) {
    Rr = t3, Br = n2;
    try {
      if (null !== g4 && g4.disconnect(), c2 || null === l2 || l2.dirty) {
        const e3 = t3._blockCursorElement;
        null !== e3 && oo(e3, t3, r2), Pr(o2, l2, t3, k5, S4, r2);
      }
      !function(t4, e3, n3) {
        let r3 = t4._blockCursorElement;
        if (cr(n3) && n3.isCollapsed() && "element" === n3.anchor.type && e3.contains(document.activeElement)) {
          const i3 = n3.anchor, s3 = i3.getNode(), o3 = i3.offset;
          let l3 = false, c3 = null;
          if (o3 === s3.getChildrenSize()) {
            so(s3.getChildAtIndex(o3 - 1)) && (l3 = true);
          } else {
            const e4 = s3.getChildAtIndex(o3);
            if (null !== e4 && so(e4)) {
              const n4 = e4.getPreviousSibling();
              (null === n4 || so(n4)) && (l3 = true, c3 = t4.getElementByKey(e4.__key));
            }
          }
          if (l3) {
            const n4 = t4.getElementByKey(s3.__key);
            return null === r3 && (t4._blockCursorElement = r3 = function(t5) {
              const e4 = t5.theme, n5 = document.createElement("div");
              n5.contentEditable = "false", n5.setAttribute("data-lexical-cursor", "true");
              let r4 = e4.blockCursor;
              if (void 0 !== r4) {
                if ("string" == typeof r4) {
                  const t6 = d(r4);
                  r4 = e4.blockCursor = t6;
                }
                void 0 !== r4 && n5.classList.add(...r4);
              }
              return n5;
            }(t4._config)), e3.style.caretColor = "transparent", void (null === c3 ? n4.appendChild(r3) : n4.insertBefore(r3, c3));
          }
        }
        null !== r3 && oo(r3, t4, e3);
      }(t3, r2, l2);
    } finally {
      null !== g4 && g4.observe(r2, $r), Rr = f3, Br = a2;
    }
  }
  null !== _5 && function(t4, e3, n3, r3, i3) {
    const s3 = Array.from(t4._listeners.mutation), o3 = s3.length;
    for (let t5 = 0; t5 < o3; t5++) {
      const [o4, l3] = s3[t5], c3 = e3.get(l3);
      void 0 !== c3 && o4(c3, { dirtyLeaves: r3, prevEditorState: i3, updateTags: n3 });
    }
  }(t3, _5, S4, p3, s2), cr(l2) || null === l2 || null !== o2 && o2.is(l2) || t3.dispatchCommand(le, void 0);
  const T5 = t3._pendingDecorators;
  null !== T5 && (t3._decorators = T5, t3._pendingDecorators = null, si("decorator", t3, true, T5)), function(t4, e3, n3) {
    const r3 = _s(e3), i3 = _s(n3);
    r3 !== i3 && si("textcontent", t4, true, i3);
  }(t3, e2 || s2, n2), si("update", t3, true, { dirtyElements: m4, dirtyLeaves: p3, editorState: n2, mutatedNodes: _5, normalizedNodes: C4, prevEditorState: e2 || s2, tags: S4 }), function(t4, e3) {
    if (t4._deferred = [], 0 !== e3.length) {
      const n3 = t4._updating;
      t4._updating = true;
      try {
        for (let t5 = 0; t5 < e3.length; t5++) e3[t5]();
      } finally {
        t4._updating = n3;
      }
    }
  }(t3, v4), function(t4) {
    const e3 = t4._updates;
    if (0 !== e3.length) {
      const n3 = e3.shift();
      if (n3) {
        const [e4, r3] = n3;
        li(t4, e4, r3);
      }
    }
  }(t3);
}
function si(t3, e2, n2, ...r2) {
  const i2 = e2._updating;
  e2._updating = n2;
  try {
    const n3 = Array.from(e2._listeners[t3]);
    for (let t4 = 0; t4 < n3.length; t4++) n3[t4].apply(null, r2);
  } finally {
    e2._updating = i2;
  }
}
function oi(e2, n2) {
  const r2 = e2._updates;
  let i2 = n2 || false;
  for (; 0 !== r2.length; ) {
    const n3 = r2.shift();
    if (n3) {
      const [r3, s2] = n3;
      let o2;
      if (void 0 !== s2) {
        if (o2 = s2.onUpdate, s2.skipTransforms && (i2 = true), s2.discrete) {
          const n4 = e2._pendingEditorState;
          null === n4 && t(191), n4._flushSync = true;
        }
        o2 && e2._deferred.push(o2), ti(e2, s2.tag);
      }
      r3();
    }
  }
  return i2;
}
function li(e2, n2, r2) {
  const i2 = e2._updateTags;
  let s2, o2 = false, l2 = false;
  void 0 !== r2 && (s2 = r2.onUpdate, ti(e2, r2.tag), o2 = r2.skipTransforms || false, l2 = r2.discrete || false), s2 && e2._deferred.push(s2);
  const c2 = e2._editorState;
  let a2 = e2._pendingEditorState, u2 = false;
  (null === a2 || a2._readOnly) && (a2 = e2._pendingEditorState = mi(a2 || c2), u2 = true), a2._flushSync = l2;
  const f3 = Br, d3 = Wr, h4 = Rr, g4 = e2._updating;
  Br = a2, Wr = false, e2._updating = true, Rr = e2;
  const _5 = e2._headless || null === e2.getRootElement();
  try {
    u2 && (_5 ? null !== c2._selection && (a2._selection = c2._selection.clone()) : a2._selection = function(t3, e3) {
      const n3 = t3.getEditorState()._selection, r3 = lo(Xs(t3));
      return cr(n3) || null == n3 ? br(n3, r3, t3, e3) : n3.clone();
    }(e2, r2 && r2.event || null));
    const i3 = e2._compositionKey;
    n2(), o2 = oi(e2, o2), function(t3, e3) {
      const n3 = e3.getEditorState()._selection, r3 = t3._selection;
      if (cr(r3)) {
        const t4 = r3.anchor, e4 = r3.focus;
        let i4;
        if ("text" === t4.type && (i4 = t4.getNode(), i4.selectionTransform(n3, r3)), "text" === e4.type) {
          const t5 = e4.getNode();
          i4 !== t5 && t5.selectionTransform(n3, r3);
        }
      }
    }(a2, e2), e2._dirtyType !== y && (o2 ? function(t3, e3) {
      const n3 = e3._dirtyLeaves, r3 = t3._nodeMap;
      for (const t4 of n3) {
        const e4 = r3.get(t4);
        Qn(e4) && e4.isAttached() && e4.isSimpleText() && !e4.isUnmergeable() && St(e4);
      }
    }(a2, e2) : function(t3, e3) {
      const n3 = e3._dirtyLeaves, r3 = e3._dirtyElements, i4 = t3._nodeMap, s4 = as(), o3 = /* @__PURE__ */ new Map();
      let l3 = n3, c3 = l3.size, a3 = r3, u3 = a3.size;
      for (; c3 > 0 || u3 > 0; ) {
        if (c3 > 0) {
          e3._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const t4 of l3) {
            const r4 = i4.get(t4);
            Qn(r4) && r4.isAttached() && r4.isSimpleText() && !r4.isUnmergeable() && St(r4), void 0 !== r4 && Zr(r4, s4) && Qr(e3, r4, o3), n3.add(t4);
          }
          if (l3 = e3._dirtyLeaves, c3 = l3.size, c3 > 0) {
            Ur++;
            continue;
          }
        }
        e3._dirtyLeaves = /* @__PURE__ */ new Set(), e3._dirtyElements = /* @__PURE__ */ new Map(), a3.delete("root") && a3.set("root", true);
        for (const t4 of a3) {
          const n4 = t4[0], l4 = t4[1];
          if (r3.set(n4, l4), !l4) continue;
          const c4 = i4.get(n4);
          void 0 !== c4 && Zr(c4, s4) && Qr(e3, c4, o3);
        }
        l3 = e3._dirtyLeaves, c3 = l3.size, a3 = e3._dirtyElements, u3 = a3.size, Ur++;
      }
      e3._dirtyLeaves = n3, e3._dirtyElements = r3;
    }(a2, e2), oi(e2), function(t3, e3, n3, r3) {
      const i4 = t3._nodeMap, s4 = e3._nodeMap, o3 = [];
      for (const [t4] of r3) {
        const e4 = s4.get(t4);
        void 0 !== e4 && (e4.isAttached() || (di(e4) && Q(e4, t4, i4, s4, o3, r3), i4.has(t4) || r3.delete(t4), o3.push(t4)));
      }
      for (const t4 of o3) s4.delete(t4);
      for (const t4 of n3) {
        const e4 = s4.get(t4);
        void 0 === e4 || e4.isAttached() || (i4.has(t4) || n3.delete(t4), s4.delete(t4));
      }
    }(c2, a2, e2._dirtyLeaves, e2._dirtyElements));
    i3 !== e2._compositionKey && (a2._flushSync = true);
    const s3 = a2._selection;
    if (cr(s3)) {
      const e3 = a2._nodeMap, n3 = s3.anchor.key, r3 = s3.focus.key;
      void 0 !== e3.get(n3) && void 0 !== e3.get(r3) || t(19);
    } else ur(s3) && 0 === s3._nodes.size && (a2._selection = null);
  } catch (t3) {
    return t3 instanceof Error && e2._onError(t3), e2._pendingEditorState = c2, e2._dirtyType = x, e2._cloneNotNeeded.clear(), e2._dirtyLeaves = /* @__PURE__ */ new Set(), e2._dirtyElements.clear(), void ii(e2);
  } finally {
    Br = f3, Wr = d3, Rr = h4, e2._updating = g4, Ur = 0;
  }
  const p3 = e2._dirtyType !== y || e2._deferred.length > 0 || function(t3, e3) {
    const n3 = e3.getEditorState()._selection, r3 = t3._selection;
    if (null !== r3) {
      if (r3.dirty || !r3.is(n3)) return true;
    } else if (null !== n3) return true;
    return false;
  }(a2, e2);
  p3 ? a2._flushSync ? (a2._flushSync = false, ii(e2)) : u2 && ji(() => {
    ii(e2);
  }) : (a2._flushSync = false, u2 && (i2.clear(), e2._deferred = [], e2._pendingEditorState = null));
}
function ci(t3, e2, n2) {
  Rr === t3 && void 0 === n2 ? e2() : li(t3, e2, n2);
}
function ui(e2, n2) {
  const r2 = [];
  let i2 = n2;
  for (; i2 !== e2 && null !== i2; i2 = i2.parentNode) {
    let t3 = 0;
    for (let e3 = i2.previousSibling; null !== e3; e3 = e3.previousSibling) t3++;
    r2.push(t3);
  }
  return i2 !== e2 && t(225), r2.reverse();
}
function di(t3) {
  return t3 instanceof fi;
}
function hi(t3, e2, n2) {
  let r2 = t3.getNode();
  for (; r2; ) {
    const t4 = r2.__key;
    if (e2.has(t4) && !n2.has(t4)) return true;
    r2 = r2.getParent();
  }
  return false;
}
function _i(t3) {
  return t3 instanceof gi;
}
function yi(t3) {
  return t3 instanceof pi;
}
function mi(t3) {
  return new Si(new Map(t3._nodeMap));
}
function xi() {
  return new Si(/* @__PURE__ */ new Map([["root", new pi()]]));
}
function Ci(e2) {
  const n2 = e2.exportJSON(), r2 = e2.constructor;
  if (n2.type !== r2.getType() && t(130, r2.name), di(e2)) {
    const i2 = n2.children;
    Array.isArray(i2) || t(59, r2.name);
    const s2 = e2.getChildren();
    for (let t3 = 0; t3 < s2.length; t3++) {
      const e3 = Ci(s2[t3]);
      i2.push(e3);
    }
  }
  return n2;
}
function Di(t3) {
  const e2 = Pi();
  return t3.style && (e2.setFormat(t3.style.textAlign), To(t3, e2)), { node: e2 };
}
function Pi() {
  return no(new Oi());
}
function Fi(t3) {
  return t3 instanceof Oi;
}
function Ri(t3, e2, n2, r2) {
  const i2 = t3._keyToDOMMap;
  i2.clear(), t3._editorState = xi(), t3._pendingEditorState = r2, t3._compositionKey = null, t3._dirtyType = y, t3._cloneNotNeeded.clear(), t3._dirtyLeaves = /* @__PURE__ */ new Set(), t3._dirtyElements.clear(), t3._normalizedNodes = /* @__PURE__ */ new Set(), t3._updateTags = /* @__PURE__ */ new Set(), t3._updates = [], t3._blockCursorElement = null;
  const s2 = t3._observer;
  null !== s2 && (s2.disconnect(), t3._observer = null), null !== e2 && (e2.textContent = ""), null !== n2 && (n2.textContent = "", i2.set("root", n2));
}
function Wi(t3) {
  const e2 = t3 || {}, n2 = Xr(), r2 = e2.theme || {}, i2 = void 0 === t3 ? n2 : e2.parentEditor || null, s2 = e2.disableEvents || false, o2 = xi(), l2 = e2.namespace || (null !== i2 ? i2._config.namespace : ks()), c2 = e2.editorState, a2 = [pi, Jn, On, tr, Oi, Ai, ...e2.nodes || []], { onError: u2, html: f3 } = e2, d3 = void 0 === e2.editable || e2.editable;
  let h4;
  if (void 0 === t3 && null !== n2) h4 = n2._nodes;
  else {
    h4 = /* @__PURE__ */ new Map();
    for (let t4 = 0; t4 < a2.length; t4++) {
      let e3 = a2[t4], n3 = null, r3 = null;
      if ("function" != typeof e3) {
        const t5 = e3;
        e3 = t5.replace, n3 = t5.with, r3 = t5.withKlass || null;
      }
      const i3 = e3.getType(), s3 = e3.transform(), o3 = /* @__PURE__ */ new Set();
      null !== s3 && o3.add(s3), h4.set(i3, { exportDOM: f3 && f3.export ? f3.export.get(e3) : void 0, klass: e3, replace: n3, replaceWithKlass: r3, transforms: o3 });
    }
  }
  const g4 = new Ji(o2, i2, h4, { disableEvents: s2, namespace: l2, theme: r2 }, u2 || console.error, function(t4, e3) {
    const n3 = /* @__PURE__ */ new Map(), r3 = /* @__PURE__ */ new Set(), i3 = (t5) => {
      Object.keys(t5).forEach((e4) => {
        let r4 = n3.get(e4);
        void 0 === r4 && (r4 = [], n3.set(e4, r4)), r4.push(t5[e4]);
      });
    };
    return t4.forEach((t5) => {
      const e4 = t5.klass.importDOM;
      if (null == e4 || r3.has(e4)) return;
      r3.add(e4);
      const n4 = e4.call(t5.klass);
      null !== n4 && i3(n4);
    }), e3 && i3(e3), n3;
  }(h4, f3 ? f3.import : void 0), d3, t3);
  return void 0 !== c2 && (g4._pendingEditorState = c2, g4._dirtyType = x), g4;
}
function $i() {
  Ui = 1;
}
function Vi(t3) {
  return _i(hs(t3));
}
function Yi(t3) {
  const e2 = document.activeElement;
  if (!fo(e2)) return false;
  const n2 = e2.nodeName;
  return _i(hs(t3)) && ("INPUT" === n2 || "TEXTAREA" === n2 || "true" === e2.contentEditable && null == Xi(e2));
}
function Hi(t3, e2, n2) {
  const r2 = t3.getRootElement();
  try {
    return null !== r2 && r2.contains(e2) && r2.contains(n2) && null !== e2 && !Yi(e2) && Gi(e2) === t3;
  } catch (t4) {
    return false;
  }
}
function qi(t3) {
  return t3 instanceof Ji;
}
function Gi(t3) {
  let e2 = t3;
  for (; null != e2; ) {
    const t4 = Xi(e2);
    if (qi(t4)) return t4;
    e2 = $s(e2);
  }
  return null;
}
function Xi(t3) {
  return t3 ? t3.__lexicalEditor : null;
}
function Qi(t3) {
  return nr(t3) || t3.isToken();
}
function Zi(t3) {
  return Qi(t3) || t3.isSegmented();
}
function ts(t3) {
  return ho(t3) && t3.nodeType === g;
}
function es(t3) {
  return ho(t3) && t3.nodeType === _;
}
function ns(t3) {
  let e2 = t3;
  for (; null != e2; ) {
    if (ts(e2)) return e2;
    e2 = e2.firstChild;
  }
  return null;
}
function rs(t3, e2, n2) {
  const r2 = j[e2];
  if (null !== n2 && (t3 & r2) == (n2 & r2)) return t3;
  let i2 = t3 ^ r2;
  return "subscript" === e2 ? i2 &= ~j.superscript : "superscript" === e2 ? i2 &= ~j.subscript : "lowercase" === e2 ? (i2 &= ~j.uppercase, i2 &= ~j.capitalize) : "uppercase" === e2 ? (i2 &= ~j.lowercase, i2 &= ~j.capitalize) : "capitalize" === e2 && (i2 &= ~j.lowercase, i2 &= ~j.uppercase), i2;
}
function is3(t3) {
  return Qn(t3) || Fn(t3) || _i(t3);
}
function ss(t3, e2) {
  if (null != e2) return void (t3.__key = e2);
  Vr(), Yr();
  const n2 = qr(), r2 = Hr(), i2 = "" + Ui++;
  r2._nodeMap.set(i2, t3), di(t3) ? n2._dirtyElements.set(i2, true) : n2._dirtyLeaves.add(i2), n2._cloneNotNeeded.add(i2), n2._dirtyType = m, t3.__key = i2;
}
function os(t3) {
  const e2 = t3.getParent();
  if (null !== e2) {
    const n2 = t3.getWritable(), r2 = e2.getWritable(), i2 = t3.getPreviousSibling(), s2 = t3.getNextSibling(), o2 = null !== s2 ? s2.__key : null, l2 = null !== i2 ? i2.__key : null, c2 = null !== i2 ? i2.getWritable() : null, a2 = null !== s2 ? s2.getWritable() : null;
    null === i2 && (r2.__first = o2), null === s2 && (r2.__last = l2), null !== c2 && (c2.__next = o2), null !== a2 && (a2.__prev = l2), n2.__prev = null, n2.__next = null, n2.__parent = null, r2.__size--;
  }
}
function ls(t3) {
  Yr();
  const e2 = t3.getLatest(), n2 = e2.__parent, r2 = Hr(), i2 = qr(), s2 = r2._nodeMap, o2 = i2._dirtyElements;
  null !== n2 && function(t4, e3, n3) {
    let r3 = t4;
    for (; null !== r3; ) {
      if (n3.has(r3)) return;
      const t5 = e3.get(r3);
      if (void 0 === t5) break;
      n3.set(r3, false), r3 = t5.__parent;
    }
  }(n2, s2, o2);
  const l2 = e2.__key;
  i2._dirtyType = m, di(t3) ? o2.set(l2, true) : i2._dirtyLeaves.add(l2);
}
function cs(t3) {
  Vr();
  const e2 = qr(), n2 = e2._compositionKey;
  if (t3 !== n2) {
    if (e2._compositionKey = t3, null !== n2) {
      const t4 = us(n2);
      null !== t4 && t4.getWritable();
    }
    if (null !== t3) {
      const e3 = us(t3);
      null !== e3 && e3.getWritable();
    }
  }
}
function as() {
  if (jr()) return null;
  return qr()._compositionKey;
}
function us(t3, e2) {
  const n2 = (e2 || Hr())._nodeMap.get(t3);
  return void 0 === n2 ? null : n2;
}
function fs(t3, e2) {
  const n2 = ds(t3, qr());
  return void 0 !== n2 ? us(n2, e2) : null;
}
function ds(t3, e2) {
  return t3[`__lexicalKey_${e2._key}`];
}
function hs(t3, e2) {
  let n2 = t3;
  for (; null != n2; ) {
    const t4 = fs(n2, e2);
    if (null !== t4) return t4;
    n2 = $s(n2);
  }
  return null;
}
function gs(t3) {
  const e2 = t3._decorators, n2 = Object.assign({}, e2);
  return t3._pendingDecorators = n2, n2;
}
function _s(t3) {
  return t3.read(() => ps().getTextContent());
}
function ps() {
  return ys(Hr());
}
function ys(t3) {
  return t3._nodeMap.get("root");
}
function ms(t3) {
  Vr();
  const e2 = Hr();
  null !== t3 && (t3.dirty = true, t3.setCachedNodes(null)), e2._selection = t3;
}
function xs(t3) {
  const e2 = qr(), n2 = function(t4, e3) {
    let n3 = t4;
    for (; null != n3; ) {
      const t5 = ds(n3, e3);
      if (void 0 !== t5) return t5;
      n3 = $s(n3);
    }
    return null;
  }(t3, e2);
  if (null === n2) {
    return t3 === e2.getRootElement() ? us("root") : null;
  }
  return us(n2);
}
function Cs(t3, e2) {
  return e2 ? t3.getTextContentSize() : 0;
}
function Ss(t3) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(t3);
}
function vs(t3) {
  const e2 = [];
  let n2 = t3;
  for (; null !== n2; ) e2.push(n2), n2 = n2._parentEditor;
  return e2;
}
function ks() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 5);
}
function Ts(t3) {
  return ts(t3) ? t3.nodeValue : null;
}
function bs(t3, e2, n2) {
  const r2 = lo(Xs(e2));
  if (null === r2) return;
  const i2 = r2.anchorNode;
  let { anchorOffset: s2, focusOffset: o2 } = r2;
  if (null !== i2) {
    let e3 = Ts(i2);
    const r3 = hs(i2);
    if (null !== e3 && Qn(r3)) {
      if (e3 === K && n2) {
        const t4 = n2.length;
        e3 = n2, s2 = t4, o2 = t4;
      }
      null !== e3 && Ns(r3, e3, s2, o2, t3);
    }
  }
}
function Ns(t3, e2, n2, r2, i2) {
  let s2 = t3;
  if (s2.isAttached() && (i2 || !s2.isDirty())) {
    const c2 = s2.isComposing();
    let a2 = e2;
    (c2 || i2) && e2[e2.length - 1] === K && (a2 = e2.slice(0, -1));
    const u2 = s2.getTextContent();
    if (i2 || a2 !== u2) {
      if ("" === a2) {
        if (cs(null), o || l || f) s2.remove();
        else {
          const t4 = qr();
          setTimeout(() => {
            t4.update(() => {
              s2.isAttached() && s2.remove();
            });
          }, 20);
        }
        return;
      }
      const e3 = s2.getParent(), i3 = wr(), u3 = s2.getTextContentSize(), d3 = as(), h4 = s2.getKey();
      if (s2.isToken() || null !== d3 && h4 === d3 && !c2 || cr(i3) && (null !== e3 && !e3.canInsertTextBefore() && 0 === i3.anchor.offset || i3.anchor.key === t3.__key && 0 === i3.anchor.offset && !s2.canInsertTextBefore() && !c2 || i3.focus.key === t3.__key && i3.focus.offset === u3 && !s2.canInsertTextAfter() && !c2)) return void s2.markDirty();
      const g4 = Nr();
      if (!cr(g4) || null === n2 || null === r2) return void s2.setTextContent(a2);
      if (g4.setTextNodeRange(s2, n2, s2, r2), s2.isSegmented()) {
        const t4 = Xn(s2.getTextContent());
        s2.replace(t4), s2 = t4;
      }
      s2.setTextContent(a2);
    }
  }
}
function ws(t3, e2, n2) {
  const r2 = e2[n2] || false;
  return "any" === r2 || r2 === t3[n2];
}
function Es(t3, e2) {
  return ws(t3, e2, "altKey") && ws(t3, e2, "ctrlKey") && ws(t3, e2, "shiftKey") && ws(t3, e2, "metaKey");
}
function Ms(t3, e2, n2) {
  return Es(t3, n2) && t3.key.toLowerCase() === e2.toLowerCase();
}
function Ds(t3) {
  return "Backspace" === t3.key;
}
function Ps(t3) {
  return Ms(t3, "a", As);
}
function Fs(t3) {
  const e2 = ps();
  if (cr(t3)) {
    const e3 = t3.anchor, n2 = t3.focus, r2 = e3.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    return e3.set(r2.getKey(), 0, "element"), n2.set(r2.getKey(), r2.getChildrenSize(), "element"), vt(t3), t3;
  }
  {
    const t4 = e2.select(0, e2.getChildrenSize());
    return ms(vt(t4)), t4;
  }
}
function Ls(t3, e2) {
  void 0 === t3.__lexicalClassNameCache && (t3.__lexicalClassNameCache = {});
  const n2 = t3.__lexicalClassNameCache, r2 = n2[e2];
  if (void 0 !== r2) return r2;
  const i2 = t3[e2];
  if ("string" == typeof i2) {
    const t4 = d(i2);
    return n2[e2] = t4, t4;
  }
  return i2;
}
function Is(e2, n2, r2, i2, s2) {
  if (0 === r2.size) return;
  const o2 = i2.__type, l2 = i2.__key, c2 = n2.get(o2);
  void 0 === c2 && t(33, o2);
  const a2 = c2.klass;
  let u2 = e2.get(a2);
  void 0 === u2 && (u2 = /* @__PURE__ */ new Map(), e2.set(a2, u2));
  const f3 = u2.get(l2), d3 = "destroyed" === f3 && "created" === s2;
  (void 0 === f3 || d3) && u2.set(l2, d3 ? "updated" : s2);
}
function zs(t3) {
  const e2 = t3.getType(), n2 = Hr();
  if (n2._readOnly) {
    const t4 = vo(n2).get(e2);
    return t4 ? Array.from(t4.values()) : [];
  }
  const r2 = n2._nodeMap, i2 = [];
  for (const [, n3] of r2) n3 instanceof t3 && n3.__type === e2 && n3.isAttached() && i2.push(n3);
  return i2;
}
function Ks(t3, e2, n2) {
  const r2 = t3.getParent();
  let i2 = n2, s2 = t3;
  return null !== r2 && (e2 && 0 === n2 ? (i2 = s2.getIndexWithinParent(), s2 = r2) : e2 || n2 !== s2.getChildrenSize() || (i2 = s2.getIndexWithinParent() + 1, s2 = r2)), s2.getChildAtIndex(e2 ? i2 - 1 : i2);
}
function Bs(t3, e2) {
  const n2 = t3.offset;
  if ("element" === t3.type) {
    return Ks(t3.getNode(), e2, n2);
  }
  {
    const r2 = t3.getNode();
    if (e2 && 0 === n2 || !e2 && n2 === r2.getTextContentSize()) {
      const t4 = e2 ? r2.getPreviousSibling() : r2.getNextSibling();
      return null === t4 ? Ks(r2.getParentOrThrow(), e2, r2.getIndexWithinParent() + (e2 ? 0 : 1)) : t4;
    }
  }
  return null;
}
function Rs(t3) {
  const e2 = Xs(t3).event, n2 = e2 && e2.inputType;
  return "insertFromPaste" === n2 || "insertFromPasteAsQuotation" === n2;
}
function Ws(t3, e2, n2) {
  return function(t4, e3, n3) {
    const r2 = vs(t4);
    for (let i2 = 4; i2 >= 0; i2--) for (let s2 = 0; s2 < r2.length; s2++) {
      const o2 = r2[s2], l2 = o2._commands.get(e3);
      if (void 0 !== l2) {
        const e4 = l2[i2];
        if (void 0 !== e4) {
          const r3 = Array.from(e4), i3 = r3.length;
          let s3 = false;
          if (ci(o2, () => {
            for (let e5 = 0; e5 < i3; e5++) if (r3[e5](n3, t4)) return void (s3 = true);
          }), s3) return s3;
        }
      }
    }
    return false;
  }(t3, e2, n2);
}
function Js(t3) {
  return !yi(t3) && !t3.isLastChild() && !t3.isInline();
}
function Us(e2, n2) {
  const r2 = e2._keyToDOMMap.get(n2);
  return void 0 === r2 && t(75, n2), r2;
}
function $s(t3) {
  const e2 = t3.assignedSlot || t3.parentElement;
  return go(e2) ? e2.host : e2;
}
function js(t3) {
  return es(t3) ? t3 : fo(t3) ? t3.ownerDocument : null;
}
function Vs(t3) {
  return qr()._updateTags.has(t3);
}
function Ys(t3) {
  Vr();
  qr()._updateTags.add(t3);
}
function Hs(t3) {
  Vr();
  qr()._deferred.push(t3);
}
function qs(t3, e2) {
  let n2 = t3.getParent();
  for (; null !== n2; ) {
    if (n2.is(e2)) return true;
    n2 = n2.getParent();
  }
  return false;
}
function Gs(t3) {
  const e2 = js(t3);
  return e2 ? e2.defaultView : null;
}
function Xs(e2) {
  const n2 = e2._window;
  return null === n2 && t(78), n2;
}
function Qs(t3) {
  return di(t3) && t3.isInline() || _i(t3) && t3.isInline();
}
function Zs(t3) {
  let e2 = t3.getParentOrThrow();
  for (; null !== e2; ) {
    if (to(e2)) return e2;
    e2 = e2.getParentOrThrow();
  }
  return e2;
}
function to(t3) {
  return yi(t3) || di(t3) && t3.isShadowRoot();
}
function eo(t3) {
  const e2 = t3.constructor.clone(t3);
  return ss(e2, null), e2;
}
function no(e2) {
  const n2 = qr(), r2 = e2.constructor.getType(), i2 = n2._nodes.get(r2);
  void 0 === i2 && t(200, e2.constructor.name, r2);
  const { replace: s2, replaceWithKlass: o2 } = i2;
  if (null !== s2) {
    const n3 = s2(e2), i3 = n3.constructor;
    return null !== o2 ? n3 instanceof o2 || t(201, o2.name, o2.getType(), i3.name, i3.getType(), e2.constructor.name, r2) : n3 instanceof e2.constructor && i3 !== e2.constructor || t(202, i3.name, i3.getType(), e2.constructor.name, r2), n3.__key === e2.__key && t(203, e2.constructor.name, r2, i3.name, i3.getType()), n3;
  }
  return e2;
}
function ro(e2, n2) {
  !yi(e2.getParent()) || di(n2) || _i(n2) || t(99);
}
function io(e2) {
  const n2 = us(e2);
  return null === n2 && t(63, e2), n2;
}
function so(t3) {
  return (_i(t3) || di(t3) && !t3.canBeEmpty()) && !t3.isInline();
}
function oo(t3, e2, n2) {
  n2.style.removeProperty("caret-color"), e2._blockCursorElement = null;
  const r2 = t3.parentElement;
  null !== r2 && r2.removeChild(t3);
}
function lo(t3) {
  return e ? (t3 || window).getSelection() : null;
}
function co(t3) {
  const e2 = Gs(t3);
  return e2 ? e2.getSelection() : null;
}
function ao(e2, n2) {
  let r2 = e2.getChildAtIndex(n2);
  null == r2 && (r2 = e2), to(e2) && t(102);
  const i2 = (e3) => {
    const n3 = e3.getParentOrThrow(), s3 = to(n3), o3 = e3 !== r2 || s3 ? eo(e3) : e3;
    if (s3) return di(e3) && di(o3) || t(133), e3.insertAfter(o3), [e3, o3, o3];
    {
      const [t3, r3, s4] = i2(n3), l2 = e3.getNextSiblings();
      return s4.append(o3, ...l2), [t3, r3, o3];
    }
  }, [s2, o2] = i2(r2);
  return [s2, o2];
}
function uo(t3) {
  return fo(t3) && "A" === t3.tagName;
}
function fo(t3) {
  return ho(t3) && t3.nodeType === h;
}
function ho(t3) {
  return "object" == typeof t3 && null !== t3 && "nodeType" in t3 && "number" == typeof t3.nodeType;
}
function go(t3) {
  return ho(t3) && t3.nodeType === p;
}
function _o(t3) {
  const e2 = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return null !== t3.nodeName.match(e2);
}
function po(t3) {
  const e2 = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return null !== t3.nodeName.match(e2);
}
function yo(t3) {
  if (_i(t3) && !t3.isInline()) return true;
  if (!di(t3) || to(t3)) return false;
  const e2 = t3.getFirstChild(), n2 = null === e2 || Fn(e2) || Qn(e2) || e2.isInline();
  return !t3.isInline() && false !== t3.canBeEmpty() && n2;
}
function mo(t3, e2) {
  let n2 = t3;
  for (; null !== n2 && null !== n2.getParent() && !e2(n2); ) n2 = n2.getParentOrThrow();
  return e2(n2) ? n2 : null;
}
function xo() {
  return qr();
}
function vo(e2) {
  if (!e2._readOnly && e2.isEmpty()) return So;
  e2._readOnly || t(192);
  let n2 = Co.get(e2);
  return n2 || (n2 = function(t3) {
    const e3 = /* @__PURE__ */ new Map();
    for (const [n3, r2] of t3._nodeMap) {
      const t4 = r2.__type;
      let i2 = e3.get(t4);
      i2 || (i2 = /* @__PURE__ */ new Map(), e3.set(t4, i2)), i2.set(n3, r2);
    }
    return e3;
  }(e2), Co.set(e2, n2)), n2;
}
function ko(t3) {
  const e2 = t3.constructor.clone(t3);
  return e2.afterCloneFrom(t3), e2;
}
function To(t3, e2) {
  const n2 = parseInt(t3.style.paddingInlineStart, 10) || 0, r2 = Math.round(n2 / 40);
  e2.setIndent(r2);
}
function bo(t3) {
  t3.__lexicalUnmanaged = true;
}
function No(t3) {
  return true === t3.__lexicalUnmanaged;
}
function Oo(t3) {
  return wo[t3];
}
function Do(t3, e2 = "root") {
  return Ao[e2](t3) ? null : t3;
}
function Lo(t3) {
  return t3 instanceof Fo;
}
function Io(t3) {
  return t3 instanceof Eo;
}
function zo(t3) {
  return t3 instanceof Po;
}
function Ko(t3) {
  return t3 instanceof Mo;
}
function Jo(t3, e2) {
  return t3 ? new Ro[e2](t3) : null;
}
function Uo(t3, e2, n2) {
  return t3 ? new Bo[e2](t3, $o(t3, n2)) : null;
}
function $o(t3, e2) {
  const n2 = t3.getTextContentSize();
  let r2 = "next" === e2 ? n2 : "previous" === e2 ? 0 : e2;
  return (r2 < 0 || r2 > n2) && (!function(t4, ...e3) {
    const n3 = new URL("https://lexical.dev/docs/error"), r3 = new URLSearchParams();
    r3.append("code", t4);
    for (const t5 of e3) r3.append("v", t5);
    n3.search = r3.toString(), console.warn(`Minified Lexical warning #${t4}; visit ${n3.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(284, String(e2), String(n2), t3.getKey()), r2 = r2 < 0 ? 0 : n2), r2;
}
function jo(t3, e2) {
  return new Go(t3, e2);
}
function Vo(t3, e2) {
  return di(t3) ? new Wo[e2](t3) : null;
}
function Yo(t3) {
  return t3 && t3.getChildCaret() || t3;
}
function Ho(t3) {
  return t3 && Yo(t3.getAdjacentCaret());
}
function Xo(t3) {
  return t3 instanceof Go;
}
function Qo(t3) {
  return tl(t3, Jo(ps(), t3.direction));
}
function Zo(t3) {
  return tl(t3, t3);
}
function tl(e2, n2) {
  return e2.direction !== n2.direction && t(265), new qo(e2, n2, e2.direction);
}
function el(t3) {
  const { initial: e2, hasNext: n2, step: r2, map: i2 } = t3;
  let s2 = e2;
  return { [Symbol.iterator]() {
    return this;
  }, next() {
    if (!n2(s2)) return { done: true, value: void 0 };
    const t4 = { done: false, value: i2(s2) };
    return s2 = r2(s2), t4;
  } };
}
function nl(e2, n2) {
  const r2 = ol(e2.origin, n2.origin);
  switch (null === r2 && t(275, e2.origin.getKey(), n2.origin.getKey()), r2.type) {
    case "same": {
      const t3 = "text" === e2.type, r3 = "text" === n2.type;
      return t3 && r3 ? function(t4, e3) {
        return Math.sign(t4 - e3);
      }(e2.offset, n2.offset) : e2.type === n2.type ? 0 : t3 ? -1 : r3 ? 1 : "child" === e2.type ? -1 : 1;
    }
    case "ancestor":
      return "child" === e2.type ? -1 : 1;
    case "descendant":
      return "child" === n2.type ? 1 : -1;
    case "branch":
      return rl(r2);
  }
}
function rl(t3) {
  const { a: e2, b: n2 } = t3, r2 = e2.__key, i2 = n2.__key;
  let s2 = e2, o2 = n2;
  for (; s2 && o2; s2 = s2.getNextSibling(), o2 = o2.getNextSibling()) {
    if (s2.__key === i2) return -1;
    if (o2.__key === r2) return 1;
  }
  return null === s2 ? 1 : -1;
}
function il(t3, e2) {
  return e2.is(t3);
}
function sl(t3) {
  return di(t3) ? [t3.getLatest(), null] : [t3.getParent(), t3.getLatest()];
}
function ol(e2, n2) {
  if (e2.is(n2)) return { commonAncestor: e2, type: "same" };
  const r2 = /* @__PURE__ */ new Map();
  for (let [t3, n3] = sl(e2); t3; n3 = t3, t3 = t3.getParent()) r2.set(t3, n3);
  for (let [i2, s2] = sl(n2); i2; s2 = i2, i2 = i2.getParent()) {
    const o2 = r2.get(i2);
    if (void 0 !== o2) return null === o2 ? (il(e2, i2) || t(276), { commonAncestor: i2, type: "ancestor" }) : null === s2 ? (il(n2, i2) || t(277), { commonAncestor: i2, type: "descendant" }) : ((di(o2) || il(e2, o2)) && (di(s2) || il(n2, s2)) && i2.is(o2.getParent()) && i2.is(s2.getParent()) || t(278), { a: o2, b: s2, commonAncestor: i2, type: "branch" });
  }
  return null;
}
function ll(e2, n2) {
  const { type: r2, key: i2, offset: s2 } = e2, o2 = io(e2.key);
  return "text" === r2 ? (Qn(o2) || t(266, o2.getType(), i2), Uo(o2, n2, s2)) : (di(o2) || t(267, o2.getType(), i2), Cl(o2, e2.offset, n2));
}
function cl(e2, n2) {
  const { origin: r2, direction: i2 } = n2, s2 = "next" === i2;
  Lo(n2) ? e2.set(r2.getKey(), n2.offset, "text") : zo(n2) ? Qn(r2) ? e2.set(r2.getKey(), $o(r2, i2), "text") : e2.set(r2.getParentOrThrow().getKey(), r2.getIndexWithinParent() + (s2 ? 1 : 0), "element") : (Ko(n2) && di(r2) || t(268), e2.set(r2.getKey(), s2 ? 0 : r2.getChildrenSize(), "element"));
}
function al(t3) {
  const e2 = Nr(), n2 = cr(e2) ? e2 : vr();
  return ul(n2, t3), ms(n2), n2;
}
function ul(t3, e2) {
  cl(t3.anchor, e2.anchor), cl(t3.focus, e2.focus);
}
function fl(t3) {
  const { anchor: e2, focus: n2 } = t3, r2 = ll(e2, "next"), i2 = ll(n2, "next"), s2 = nl(r2, i2) <= 0 ? "next" : "previous";
  return tl(ml(r2, s2), ml(i2, s2));
}
function dl(t3) {
  const { direction: e2, origin: n2 } = t3, r2 = Jo(n2, Oo(e2)).getNodeAtCaret();
  return r2 ? Jo(r2, e2) : Vo(n2.getParentOrThrow(), e2);
}
function hl(t3, e2 = "root") {
  const n2 = [t3];
  for (let r2 = Ko(t3) ? t3.getParentCaret(e2) : t3.getSiblingCaret(); null !== r2; r2 = r2.getParentCaret(e2)) n2.push(dl(r2));
  return n2;
}
function gl(t3) {
  return !!t3 && t3.origin.isAttached();
}
function _l(e2, n2 = "removeEmptySlices") {
  if (e2.isCollapsed()) return e2;
  const r2 = "root", i2 = "next";
  let s2 = n2;
  const o2 = xl(e2, i2), l2 = hl(o2.anchor, r2), c2 = hl(o2.focus.getFlipped(), r2), a2 = /* @__PURE__ */ new Set(), u2 = [];
  for (const t3 of o2.iterNodeCarets(r2)) if (Ko(t3)) a2.add(t3.origin.getKey());
  else if (zo(t3)) {
    const { origin: e3 } = t3;
    di(e3) && !a2.has(e3.getKey()) || u2.push(e3);
  }
  for (const t3 of u2) t3.remove();
  for (const t3 of o2.getTextSlices()) {
    if (!t3) continue;
    const { origin: e3 } = t3.caret, n3 = e3.getTextContentSize(), r3 = dl(Jo(e3, i2)), o3 = e3.getMode();
    if (Math.abs(t3.distance) === n3 && "removeEmptySlices" === s2 || "token" === o3 && 0 !== t3.distance) r3.remove();
    else if (0 !== t3.distance) {
      s2 = "removeEmptySlices";
      let e4 = t3.removeTextSlice();
      const n4 = t3.caret.origin;
      if ("segmented" === o3) {
        const t4 = e4.origin, n5 = Xn(t4.getTextContent()).setStyle(t4.getStyle()).setFormat(t4.getFormat());
        r3.replaceOrInsert(n5), e4 = Uo(n5, i2, e4.offset);
      }
      n4.is(l2[0].origin) && (l2[0] = e4), n4.is(c2[0].origin) && (c2[0] = e4.getFlipped());
    }
  }
  let f3, d3;
  for (const t3 of l2) if (gl(t3)) {
    f3 = pl(t3);
    break;
  }
  for (const t3 of c2) if (gl(t3)) {
    d3 = pl(t3);
    break;
  }
  const h4 = function(t3, e3, n3) {
    if (!t3 || !e3) return null;
    const r3 = t3.getParentAtCaret(), i3 = e3.getParentAtCaret();
    if (!r3 || !i3) return null;
    const s3 = r3.getParents().reverse();
    s3.push(r3);
    const o3 = i3.getParents().reverse();
    o3.push(i3);
    const l3 = Math.min(s3.length, o3.length);
    let c3;
    for (c3 = 0; c3 < l3 && s3[c3] === o3[c3]; c3++) ;
    const a3 = (t4, e4) => {
      let n4;
      for (let r4 = c3; r4 < t4.length; r4++) {
        const i4 = t4[r4];
        if (to(i4)) return;
        !n4 && e4(i4) && (n4 = i4);
      }
      return n4;
    }, u3 = a3(s3, yo), f4 = u3 && a3(o3, (t4) => n3.has(t4.getKey()) && yo(t4));
    return u3 && f4 ? [u3, f4] : null;
  }(f3, d3, a2);
  if (h4) {
    const [t3, e3] = h4;
    Vo(t3, "previous").splice(0, e3.getChildren()), e3.remove();
  }
  const g4 = [f3, d3, ...l2, ...c2].find(gl);
  if (g4) {
    return Zo(ml(pl(g4), e2.direction));
  }
  t(269, JSON.stringify(l2.map((t3) => t3.origin.__key)));
}
function pl(t3) {
  const e2 = function(t4) {
    let e3 = t4;
    for (; Ko(e3); ) {
      const t5 = Ho(e3);
      if (!Ko(t5)) break;
      e3 = t5;
    }
    return e3;
  }(t3.getLatest()), { direction: n2 } = e2;
  if (Qn(e2.origin)) return Lo(e2) ? e2 : Uo(e2.origin, n2, n2);
  const r2 = e2.getAdjacentCaret();
  return zo(r2) && Qn(r2.origin) ? Uo(r2.origin, n2, Oo(n2)) : e2;
}
function yl(t3) {
  return Lo(t3) && t3.offset !== $o(t3.origin, t3.direction);
}
function ml(t3, e2) {
  return t3.direction === e2 ? t3 : t3.getFlipped();
}
function xl(t3, e2) {
  return t3.direction === e2 ? t3 : tl(ml(t3.focus, e2), ml(t3.anchor, e2));
}
function Cl(t3, e2, n2) {
  let r2 = Vo(t3, "next");
  for (let t4 = 0; t4 < e2; t4++) {
    const t5 = r2.getAdjacentCaret();
    if (null === t5) break;
    r2 = t5;
  }
  return ml(r2, n2);
}
function Sl(t3, e2 = "root") {
  let n2 = 0, r2 = t3, i2 = Ho(r2);
  for (; null === i2; ) {
    if (n2--, i2 = r2.getParentCaret(e2), !i2) return null;
    r2 = i2, i2 = Ho(r2);
  }
  return i2 && [i2, n2];
}
function vl(e2) {
  const { origin: n2, offset: r2, direction: i2 } = e2;
  if (r2 === $o(n2, i2)) return e2.getSiblingCaret();
  if (r2 === $o(n2, Oo(i2))) return dl(e2.getSiblingCaret());
  const [s2] = n2.splitText(r2);
  return Qn(s2) || t(281), ml(Jo(s2, "next"), i2);
}
function kl(t3, e2) {
  return true;
}
function Tl(t3, { $copyElementNode: e2 = eo, $splitTextPointCaretNext: n2 = vl, rootMode: r2 = "shadowRoot", $shouldSplit: i2 = kl } = {}) {
  if (Lo(t3)) return n2(t3);
  const s2 = t3.getParentCaret(r2);
  if (s2) {
    const { origin: n3 } = s2;
    if (Ko(t3) && (!n3.canBeEmpty() || !i2(n3, "first"))) return dl(s2);
    const r3 = function(t4) {
      const e3 = [];
      for (let n4 = t4.getAdjacentCaret(); n4; n4 = n4.getAdjacentCaret()) e3.push(n4.origin);
      return e3;
    }(t3);
    (r3.length > 0 || n3.canBeEmpty() && i2(n3, "last")) && s2.insert(e2(n3).splice(0, 0, r3));
  }
  return s2;
}
var e, n, r, i, s, o, l, c, a, u, f, h, g, _, p, y, m, x, C, S, v, k, T, b, N, w, E, M, A, O, D, P, F, L, I, z, K, B, R, W, J, U, $, j, V, Y, H, q, G, X, Z, tt, et, ft, pt, Tt, bt, Nt, wt, Et, Mt, At, Ot, Dt, Pt, Ft, Lt, It, zt, Kt, Bt, Rt, Wt, jt, le, ce, ae, ue, fe, de, he, ge, _e, pe2, ye, me, xe, Ce, Se, ve, ke, Te, be, Ne, we, Ee, Me, Ae, Oe, De, Pe, Fe, Le, Ie, ze, Ke, Be, Re, We, Je, Ue, $e, je, Ve, Ye, He, qe, Ge, Xe, Qe, Ze, tn, en, nn, rn, sn, on, ln, cn, an, un, fn, dn, hn, gn, kn, wn, An, On, Jn, jn, qn, tr, rr, lr, ar, gr, Br, Rr, Wr, Jr, Ur, $r, ai, fi, gi, pi, Si, vi, ki, Ti, bi, Ni, wi, Ei, Mi, Ai, Oi, Li, Ii, zi, Ki, Bi, Ji, Ui, ji, As, Os, Co, So, wo, Eo, Mo, Ao, Po, Fo, Bo, Ro, Wo, qo, Go;
var init_Lexical_prod = __esm({
  "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/lexical@0.32.1/node_modules/lexical/Lexical.prod.mjs"() {
    e = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    n = e && "documentMode" in document ? document.documentMode : null;
    r = e && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    i = e && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    s = !(!e || !("InputEvent" in window) || n) && "getTargetRanges" in new window.InputEvent("input");
    o = e && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    l = e && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    c = e && /Android/.test(navigator.userAgent);
    a = e && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    u = e && c && a;
    f = e && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !a;
    h = 1;
    g = 3;
    _ = 9;
    p = 11;
    y = 0;
    m = 1;
    x = 2;
    C = 0;
    S = 1;
    v = 2;
    k = 1;
    T = 2;
    b = 4;
    N = 8;
    w = 16;
    E = 32;
    M = 64;
    A = 128;
    O = 1792 | (112 | (3 | b | N) | A);
    D = 1;
    P = 2;
    F = 3;
    L = 4;
    I = 5;
    z = 6;
    K = o || l || f ? "\xA0" : "\u200B";
    B = "\n\n";
    R = i ? "\xA0" : K;
    W = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
    J = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
    U = new RegExp("^[^" + J + "]*[" + W + "]");
    $ = new RegExp("^[^" + W + "]*[" + J + "]");
    j = { bold: 1, capitalize: 1024, code: 16, highlight: A, italic: 2, lowercase: 256, strikethrough: b, subscript: 32, superscript: 64, underline: N, uppercase: 512 };
    V = { directionless: 1, unmergeable: 2 };
    Y = { center: P, end: z, justify: L, left: D, right: F, start: I };
    H = { [P]: "center", [z]: "end", [L]: "justify", [D]: "left", [F]: "right", [I]: "start" };
    q = { normal: 0, segmented: 2, token: 1 };
    G = { [C]: "normal", [v]: "segmented", [S]: "token" };
    X = "$";
    Z = 100;
    tt = false;
    et = 0;
    ft = class {
      constructor(t3, e2) {
        this.key = t3, this.parse = e2.parse.bind(e2), this.unparse = (e2.unparse || ut).bind(e2), this.isEqual = (e2.isEqual || Object.is).bind(e2), this.defaultValue = this.parse(void 0);
      }
    };
    pt = class _pt {
      constructor(t3, e2 = /* @__PURE__ */ new Map(), n2 = void 0, r2 = /* @__PURE__ */ new Map(), i2 = void 0) {
        this.node = t3, this.sharedConfigMap = e2, this.unknownState = n2, this.knownState = r2;
        const s2 = void 0 !== i2 ? i2 : function(t4, e3, n3) {
          let r3 = n3.size;
          if (e3) for (const i3 in e3) {
            const e4 = t4.get(i3);
            e4 && n3.has(e4) || r3++;
          }
          return r3;
        }(e2, n2, r2);
        this.size = s2;
      }
      getValue(t3) {
        const e2 = this.knownState.get(t3);
        if (void 0 !== e2) return e2;
        this.sharedConfigMap.set(t3.key, t3);
        let n2 = t3.defaultValue;
        if (this.unknownState && t3.key in this.unknownState) {
          const e3 = this.unknownState[t3.key];
          void 0 !== e3 && (n2 = t3.parse(e3)), this.updateFromKnown(t3, n2);
        }
        return n2;
      }
      getInternalState() {
        return [this.unknownState, this.knownState];
      }
      toJSON() {
        const t3 = { ...this.unknownState };
        for (const [e2, n2] of this.knownState) e2.isEqual(n2, e2.defaultValue) ? delete t3[e2.key] : t3[e2.key] = e2.unparse(n2);
        return yt(t3) ? { [X]: t3 } : {};
      }
      getWritable(t3) {
        if (this.node === t3) return this;
        const e2 = new Map(this.knownState), n2 = yt(r2 = this.unknownState) && { ...r2 };
        var r2;
        if (n2) for (const t4 of e2.keys()) delete n2[t4.key];
        return new _pt(t3, this.sharedConfigMap, yt(n2), e2, this.size);
      }
      updateFromKnown(t3, e2) {
        const n2 = t3.key;
        this.sharedConfigMap.set(n2, t3);
        const { knownState: r2, unknownState: i2 } = this;
        r2.has(t3) || i2 && n2 in i2 || this.size++, r2.set(t3, e2);
      }
      updateFromUnknown(t3, e2) {
        const n2 = this.sharedConfigMap.get(t3);
        n2 ? this.updateFromKnown(n2, n2.parse(e2)) : (this.unknownState = this.unknownState || {}, t3 in this.unknownState || this.size++, this.unknownState[t3] = e2);
      }
      updateFromJSON(t3) {
        const { knownState: e2 } = this;
        for (const t4 of e2.keys()) e2.set(t4, t4.defaultValue);
        if (this.size = e2.size, this.unknownState = {}, t3) for (const [e3, n2] of Object.entries(t3)) this.updateFromUnknown(e3, n2);
        this.unknownState = yt(this.unknownState);
      }
    };
    Ft = "";
    Lt = "";
    It = null;
    zt = "";
    Kt = "";
    Bt = false;
    Rt = false;
    Wt = null;
    jt = "40px";
    le = oe("SELECTION_CHANGE_COMMAND");
    ce = oe("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
    ae = oe("CLICK_COMMAND");
    ue = oe("DELETE_CHARACTER_COMMAND");
    fe = oe("INSERT_LINE_BREAK_COMMAND");
    de = oe("INSERT_PARAGRAPH_COMMAND");
    he = oe("CONTROLLED_TEXT_INSERTION_COMMAND");
    ge = oe("PASTE_COMMAND");
    _e = oe("REMOVE_TEXT_COMMAND");
    pe2 = oe("DELETE_WORD_COMMAND");
    ye = oe("DELETE_LINE_COMMAND");
    me = oe("FORMAT_TEXT_COMMAND");
    xe = oe("UNDO_COMMAND");
    Ce = oe("REDO_COMMAND");
    Se = oe("KEYDOWN_COMMAND");
    ve = oe("KEY_ARROW_RIGHT_COMMAND");
    ke = oe("MOVE_TO_END");
    Te = oe("KEY_ARROW_LEFT_COMMAND");
    be = oe("MOVE_TO_START");
    Ne = oe("KEY_ARROW_UP_COMMAND");
    we = oe("KEY_ARROW_DOWN_COMMAND");
    Ee = oe("KEY_ENTER_COMMAND");
    Me = oe("KEY_SPACE_COMMAND");
    Ae = oe("KEY_BACKSPACE_COMMAND");
    Oe = oe("KEY_ESCAPE_COMMAND");
    De = oe("KEY_DELETE_COMMAND");
    Pe = oe("KEY_TAB_COMMAND");
    Fe = oe("INSERT_TAB_COMMAND");
    Le = oe("INDENT_CONTENT_COMMAND");
    Ie = oe("OUTDENT_CONTENT_COMMAND");
    ze = oe("DROP_COMMAND");
    Ke = oe("FORMAT_ELEMENT_COMMAND");
    Be = oe("DRAGSTART_COMMAND");
    Re = oe("DRAGOVER_COMMAND");
    We = oe("DRAGEND_COMMAND");
    Je = oe("COPY_COMMAND");
    Ue = oe("CUT_COMMAND");
    $e = oe("SELECT_ALL_COMMAND");
    je = oe("CLEAR_EDITOR_COMMAND");
    Ve = oe("CLEAR_HISTORY_COMMAND");
    Ye = oe("CAN_REDO_COMMAND");
    He = oe("CAN_UNDO_COMMAND");
    qe = oe("FOCUS_COMMAND");
    Ge = oe("BLUR_COMMAND");
    Xe = oe("KEY_MODIFIER_COMMAND");
    Qe = Object.freeze({});
    Ze = 30;
    tn = [["keydown", function(t3, e2) {
      if (en = t3.timeStamp, nn = t3.key, e2.isComposing()) return;
      if (Ws(e2, Se, t3)) return;
      if (null == t3.key) return;
      if (fn && Ds(t3)) return ci(e2, () => {
        Sn(e2, dn);
      }), fn = false, void (dn = "");
      if (function(t4) {
        return Ms(t4, "ArrowRight", { shiftKey: "any" });
      }(t3)) Ws(e2, ve, t3);
      else if (function(t4) {
        return Ms(t4, "ArrowRight", As);
      }(t3)) Ws(e2, ke, t3);
      else if (function(t4) {
        return Ms(t4, "ArrowLeft", { shiftKey: "any" });
      }(t3)) Ws(e2, Te, t3);
      else if (function(t4) {
        return Ms(t4, "ArrowLeft", As);
      }(t3)) Ws(e2, be, t3);
      else if (function(t4) {
        return Ms(t4, "ArrowUp", { altKey: "any", shiftKey: "any" });
      }(t3)) Ws(e2, Ne, t3);
      else if (function(t4) {
        return Ms(t4, "ArrowDown", { altKey: "any", shiftKey: "any" });
      }(t3)) Ws(e2, we, t3);
      else if (function(t4) {
        return Ms(t4, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any", shiftKey: true });
      }(t3)) an = true, Ws(e2, Ee, t3);
      else if (function(t4) {
        return " " === t4.key;
      }(t3)) Ws(e2, Me, t3);
      else if (function(t4) {
        return r && Ms(t4, "o", { ctrlKey: true });
      }(t3)) t3.preventDefault(), an = true, Ws(e2, fe, true);
      else if (function(t4) {
        return Ms(t4, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any" });
      }(t3)) an = false, Ws(e2, Ee, t3);
      else if (function(t4) {
        return Ms(t4, "Backspace", { shiftKey: "any" }) || r && Ms(t4, "h", { ctrlKey: true });
      }(t3)) Ds(t3) ? Ws(e2, Ae, t3) : (t3.preventDefault(), Ws(e2, ue, true));
      else if (function(t4) {
        return "Escape" === t4.key;
      }(t3)) Ws(e2, Oe, t3);
      else if (function(t4) {
        return Ms(t4, "Delete", {}) || r && Ms(t4, "d", { ctrlKey: true });
      }(t3)) !function(t4) {
        return "Delete" === t4.key;
      }(t3) ? (t3.preventDefault(), Ws(e2, ue, false)) : Ws(e2, De, t3);
      else if (function(t4) {
        return Ms(t4, "Backspace", Os);
      }(t3)) t3.preventDefault(), Ws(e2, pe2, true);
      else if (function(t4) {
        return Ms(t4, "Delete", Os);
      }(t3)) t3.preventDefault(), Ws(e2, pe2, false);
      else if (function(t4) {
        return r && Ms(t4, "Backspace", { metaKey: true });
      }(t3)) t3.preventDefault(), Ws(e2, ye, true);
      else if (function(t4) {
        return r && (Ms(t4, "Delete", { metaKey: true }) || Ms(t4, "k", { ctrlKey: true }));
      }(t3)) t3.preventDefault(), Ws(e2, ye, false);
      else if (function(t4) {
        return Ms(t4, "b", As);
      }(t3)) t3.preventDefault(), Ws(e2, me, "bold");
      else if (function(t4) {
        return Ms(t4, "u", As);
      }(t3)) t3.preventDefault(), Ws(e2, me, "underline");
      else if (function(t4) {
        return Ms(t4, "i", As);
      }(t3)) t3.preventDefault(), Ws(e2, me, "italic");
      else if (function(t4) {
        return Ms(t4, "Tab", { shiftKey: "any" });
      }(t3)) Ws(e2, Pe, t3);
      else if (function(t4) {
        return Ms(t4, "z", As);
      }(t3)) t3.preventDefault(), Ws(e2, xe, void 0);
      else if (function(t4) {
        if (r) return Ms(t4, "z", { metaKey: true, shiftKey: true });
        return Ms(t4, "y", { ctrlKey: true }) || Ms(t4, "z", { ctrlKey: true, shiftKey: true });
      }(t3)) t3.preventDefault(), Ws(e2, Ce, void 0);
      else {
        const n2 = e2._editorState._selection;
        null === n2 || cr(n2) ? Ps(t3) && (t3.preventDefault(), Ws(e2, $e, t3)) : !function(t4) {
          return Ms(t4, "c", As);
        }(t3) ? !function(t4) {
          return Ms(t4, "x", As);
        }(t3) ? Ps(t3) && (t3.preventDefault(), Ws(e2, $e, t3)) : (t3.preventDefault(), Ws(e2, Ue, t3)) : (t3.preventDefault(), Ws(e2, Je, t3));
      }
      (function(t4) {
        return t4.ctrlKey || t4.shiftKey || t4.altKey || t4.metaKey;
      })(t3) && Ws(e2, Xe, t3);
    }], ["pointerdown", function(t3, e2) {
      const n2 = t3.target, r2 = t3.pointerType;
      ho(n2) && "touch" !== r2 && "pen" !== r2 && 0 === t3.button && ci(e2, () => {
        Vi(n2) || (cn = true);
      });
    }], ["compositionstart", function(t3, e2) {
      ci(e2, () => {
        const n2 = Nr();
        if (cr(n2) && !e2.isComposing()) {
          const r2 = n2.anchor, i2 = n2.anchor.getNode();
          cs(r2.key), (t3.timeStamp < en + Ze || "element" === r2.type || !n2.isCollapsed() || i2.getFormat() !== n2.format || Qn(i2) && i2.getStyle() !== n2.style) && Ws(e2, he, R);
        }
      });
    }], ["compositionend", function(t3, e2) {
      i ? un = true : l || !o && !f ? ci(e2, () => {
        Sn(e2, t3.data);
      }) : (fn = true, dn = t3.data);
    }], ["input", function(t3, e2) {
      t3.stopPropagation(), ci(e2, () => {
        if (fo(t3.target) && Vi(t3.target)) return;
        const n2 = Nr(), r2 = t3.data, c2 = Cn(t3);
        if (null != r2 && cr(n2) && _n(n2, c2, r2, t3.timeStamp, false)) {
          un && (Sn(e2, r2), un = false);
          const c3 = n2.anchor.getNode(), a2 = lo(Xs(e2));
          if (null === a2) return;
          const u2 = n2.isBackward(), d3 = u2 ? n2.anchor.offset : n2.focus.offset, h4 = u2 ? n2.focus.offset : n2.anchor.offset;
          s && !n2.isCollapsed() && Qn(c3) && null !== a2.anchorNode && c3.getTextContent().slice(0, d3) + r2 + c3.getTextContent().slice(d3 + h4) === Ts(a2.anchorNode) || Ws(e2, he, r2);
          const g4 = r2.length;
          i && g4 > 1 && "insertCompositionText" === t3.inputType && !e2.isComposing() && (n2.anchor.offset -= g4), o || l || f || !e2.isComposing() || (en = 0, cs(null));
        } else {
          bs(false, e2, null !== r2 ? r2 : void 0), un && (Sn(e2, r2 || void 0), un = false);
        }
        !function() {
          Vr();
          const t4 = qr();
          ct(t4);
        }();
      }, { event: t3 }), sn = null;
    }], ["click", function(t3, e2) {
      ci(e2, () => {
        const n2 = Nr(), r2 = lo(Xs(e2)), i2 = wr();
        if (r2) {
          if (cr(n2)) {
            const e3 = n2.anchor, s2 = e3.getNode();
            if ("element" === e3.type && 0 === e3.offset && n2.isCollapsed() && !yi(s2) && 1 === ps().getChildrenSize() && s2.getTopLevelElementOrThrow().isEmpty() && null !== i2 && n2.is(i2)) r2.removeAllRanges(), n2.dirty = true;
            else if (3 === t3.detail && !n2.isCollapsed()) {
              if (s2 !== n2.focus.getNode()) {
                const t4 = function(t5, e4) {
                  let n3 = t5;
                  for (; n3 !== ps() && null != n3; ) {
                    if (e4(n3)) return n3;
                    n3 = n3.getParent();
                  }
                  return null;
                }(s2, (t5) => di(t5) && !t5.isInline());
                di(t4) && t4.select(0);
              }
            }
          } else if ("touch" === t3.pointerType || "pen" === t3.pointerType) {
            const n3 = r2.anchorNode;
            if (fo(n3) || ts(n3)) {
              ms(br(i2, r2, e2, t3));
            }
          }
        }
        Ws(e2, ae, t3);
      });
    }], ["cut", Qe], ["copy", Qe], ["dragstart", Qe], ["dragover", Qe], ["dragend", Qe], ["paste", Qe], ["focus", Qe], ["blur", Qe], ["drop", Qe]];
    s && tn.push(["beforeinput", (e2, n2) => function(e3, n3) {
      const r2 = e3.inputType, s2 = Cn(e3);
      if ("deleteCompositionText" === r2 || i && Rs(n3)) return;
      if ("insertCompositionText" === r2) return;
      ci(n3, () => {
        const i2 = Nr();
        if ("deleteContentBackward" === r2) {
          if (null === i2) {
            const t3 = wr();
            if (!cr(t3)) return;
            ms(t3.clone());
          }
          if (cr(i2)) {
            const r3 = i2.anchor.key === i2.focus.key;
            if (o2 = e3.timeStamp, "MediaLast" === nn && o2 < en + Ze && n3.isComposing() && r3) {
              if (cs(null), en = 0, setTimeout(() => {
                ci(n3, () => {
                  cs(null);
                });
              }, Ze), cr(i2)) {
                const e4 = i2.anchor.getNode();
                e4.markDirty(), Qn(e4) || t(142), xn(i2, e4);
              }
            } else {
              cs(null), e3.preventDefault();
              const t3 = i2.anchor.getNode(), s3 = t3.getTextContent(), o3 = t3.canInsertTextAfter(), l2 = 0 === i2.anchor.offset && i2.focus.offset === s3.length;
              let c3 = u && r3 && !l2 && o3;
              if (c3 && i2.isCollapsed() && (c3 = !_i(Bs(i2.anchor, true))), !c3) {
                Ws(n3, ue, true);
                const t4 = Nr();
                u && cr(t4) && t4.isCollapsed() && (hn = t4, setTimeout(() => hn = null));
              }
            }
            return;
          }
        }
        var o2;
        if (!cr(i2)) return;
        const c2 = e3.data;
        null !== sn && bs(false, n3, sn), i2.dirty && null === sn || !i2.isCollapsed() || yi(i2.anchor.getNode()) || null === s2 || i2.applyDOMRange(s2), sn = null;
        const a2 = i2.anchor, f3 = i2.focus, d3 = a2.getNode(), h4 = f3.getNode();
        if ("insertText" !== r2 && "insertTranspose" !== r2) switch (e3.preventDefault(), r2) {
          case "insertFromYank":
          case "insertFromDrop":
          case "insertReplacementText":
            Ws(n3, he, e3);
            break;
          case "insertFromComposition":
            cs(null), Ws(n3, he, e3);
            break;
          case "insertLineBreak":
            cs(null), Ws(n3, fe, false);
            break;
          case "insertParagraph":
            cs(null), an && !l ? (an = false, Ws(n3, fe, false)) : Ws(n3, de, void 0);
            break;
          case "insertFromPaste":
          case "insertFromPasteAsQuotation":
            Ws(n3, ge, e3);
            break;
          case "deleteByComposition":
            (function(t3, e4) {
              return t3 !== e4 || di(t3) || di(e4) || !Qi(t3) || !Qi(e4);
            })(d3, h4) && Ws(n3, _e, e3);
            break;
          case "deleteByDrag":
          case "deleteByCut":
            Ws(n3, _e, e3);
            break;
          case "deleteContent":
            Ws(n3, ue, false);
            break;
          case "deleteWordBackward":
            Ws(n3, pe2, true);
            break;
          case "deleteWordForward":
            Ws(n3, pe2, false);
            break;
          case "deleteHardLineBackward":
          case "deleteSoftLineBackward":
            Ws(n3, ye, true);
            break;
          case "deleteContentForward":
          case "deleteHardLineForward":
          case "deleteSoftLineForward":
            Ws(n3, ye, false);
            break;
          case "formatStrikeThrough":
            Ws(n3, me, "strikethrough");
            break;
          case "formatBold":
            Ws(n3, me, "bold");
            break;
          case "formatItalic":
            Ws(n3, me, "italic");
            break;
          case "formatUnderline":
            Ws(n3, me, "underline");
            break;
          case "historyUndo":
            Ws(n3, xe, void 0);
            break;
          case "historyRedo":
            Ws(n3, Ce, void 0);
        }
        else {
          if ("\n" === c2) e3.preventDefault(), Ws(n3, fe, false);
          else if (c2 === B) e3.preventDefault(), Ws(n3, de, void 0);
          else if (null == c2 && e3.dataTransfer) {
            const t3 = e3.dataTransfer.getData("text/plain");
            e3.preventDefault(), i2.insertRawText(t3);
          } else null != c2 && _n(i2, s2, c2, e3.timeStamp, true) ? (e3.preventDefault(), Ws(n3, he, c2)) : sn = c2;
          rn = e3.timeStamp;
        }
      });
    }(e2, n2)]);
    en = 0;
    nn = null;
    rn = 0;
    sn = null;
    on = /* @__PURE__ */ new WeakMap();
    ln = false;
    cn = false;
    an = false;
    un = false;
    fn = false;
    dn = "";
    hn = null;
    gn = [0, "", 0, "root", 0];
    kn = /* @__PURE__ */ new Map();
    wn = () => {
    };
    An = class {
      static getType() {
        t(64, this.name);
      }
      static clone(e2) {
        t(65, this.name);
      }
      afterCloneFrom(t3) {
        this.__parent = t3.__parent, this.__next = t3.__next, this.__prev = t3.__prev, this.__state = t3.__state;
      }
      constructor(t3) {
        this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Object.defineProperty(this, "__state", { configurable: true, enumerable: false, value: void 0, writable: true }), ss(this, t3);
      }
      getType() {
        return this.__type;
      }
      isInline() {
        t(137, this.constructor.name);
      }
      isAttached() {
        let t3 = this.__key;
        for (; null !== t3; ) {
          if ("root" === t3) return true;
          const e2 = us(t3);
          if (null === e2) break;
          t3 = e2.__parent;
        }
        return false;
      }
      isSelected(t3) {
        const e2 = t3 || Nr();
        if (null == e2) return false;
        const n2 = e2.getNodes().some((t4) => t4.__key === this.__key);
        if (Qn(this)) return n2;
        if (cr(e2) && "element" === e2.anchor.type && "element" === e2.focus.type) {
          if (e2.isCollapsed()) return false;
          const t4 = this.getParent();
          if (_i(this) && this.isInline() && t4) {
            const n3 = e2.isBackward() ? e2.focus : e2.anchor;
            if (t4.is(n3.getNode()) && n3.offset === t4.getChildrenSize() && this.is(t4.getLastChild())) return false;
          }
        }
        return n2;
      }
      getKey() {
        return this.__key;
      }
      getIndexWithinParent() {
        const t3 = this.getParent();
        if (null === t3) return -1;
        let e2 = t3.getFirstChild(), n2 = 0;
        for (; null !== e2; ) {
          if (this.is(e2)) return n2;
          n2++, e2 = e2.getNextSibling();
        }
        return -1;
      }
      getParent() {
        const t3 = this.getLatest().__parent;
        return null === t3 ? null : us(t3);
      }
      getParentOrThrow() {
        const e2 = this.getParent();
        return null === e2 && t(66, this.__key), e2;
      }
      getTopLevelElement() {
        let e2 = this;
        for (; null !== e2; ) {
          const n2 = e2.getParent();
          if (to(n2)) return di(e2) || e2 === this && _i(e2) || t(194), e2;
          e2 = n2;
        }
        return null;
      }
      getTopLevelElementOrThrow() {
        const e2 = this.getTopLevelElement();
        return null === e2 && t(67, this.__key), e2;
      }
      getParents() {
        const t3 = [];
        let e2 = this.getParent();
        for (; null !== e2; ) t3.push(e2), e2 = e2.getParent();
        return t3;
      }
      getParentKeys() {
        const t3 = [];
        let e2 = this.getParent();
        for (; null !== e2; ) t3.push(e2.__key), e2 = e2.getParent();
        return t3;
      }
      getPreviousSibling() {
        const t3 = this.getLatest().__prev;
        return null === t3 ? null : us(t3);
      }
      getPreviousSiblings() {
        const t3 = [], e2 = this.getParent();
        if (null === e2) return t3;
        let n2 = e2.getFirstChild();
        for (; null !== n2 && !n2.is(this); ) t3.push(n2), n2 = n2.getNextSibling();
        return t3;
      }
      getNextSibling() {
        const t3 = this.getLatest().__next;
        return null === t3 ? null : us(t3);
      }
      getNextSiblings() {
        const t3 = [];
        let e2 = this.getNextSibling();
        for (; null !== e2; ) t3.push(e2), e2 = e2.getNextSibling();
        return t3;
      }
      getCommonAncestor(t3) {
        const e2 = di(this) ? this : this.getParent(), n2 = di(t3) ? t3 : t3.getParent(), r2 = e2 && n2 ? ol(e2, n2) : null;
        return r2 ? r2.commonAncestor : null;
      }
      is(t3) {
        return null != t3 && this.__key === t3.__key;
      }
      isBefore(e2) {
        const n2 = ol(this, e2);
        return null !== n2 && ("descendant" === n2.type || ("branch" === n2.type ? -1 === rl(n2) : ("same" !== n2.type && "ancestor" !== n2.type && t(279), false)));
      }
      isParentOf(t3) {
        const e2 = ol(this, t3);
        return null !== e2 && "ancestor" === e2.type;
      }
      getNodesBetween(e2) {
        const n2 = this.isBefore(e2), r2 = [], i2 = /* @__PURE__ */ new Set();
        let s2 = this;
        for (; null !== s2; ) {
          const o2 = s2.__key;
          if (i2.has(o2) || (i2.add(o2), r2.push(s2)), s2 === e2) break;
          const l2 = di(s2) ? n2 ? s2.getFirstChild() : s2.getLastChild() : null;
          if (null !== l2) {
            s2 = l2;
            continue;
          }
          const c2 = n2 ? s2.getNextSibling() : s2.getPreviousSibling();
          if (null !== c2) {
            s2 = c2;
            continue;
          }
          const a2 = s2.getParentOrThrow();
          if (i2.has(a2.__key) || r2.push(a2), a2 === e2) break;
          let u2 = null, f3 = a2;
          do {
            if (null === f3 && t(68), u2 = n2 ? f3.getNextSibling() : f3.getPreviousSibling(), f3 = f3.getParent(), null === f3) break;
            null !== u2 || i2.has(f3.__key) || r2.push(f3);
          } while (null === u2);
          s2 = u2;
        }
        return n2 || r2.reverse(), r2;
      }
      isDirty() {
        const t3 = qr()._dirtyLeaves;
        return null !== t3 && t3.has(this.__key);
      }
      getLatest() {
        const e2 = us(this.__key);
        return null === e2 && t(113), e2;
      }
      getWritable() {
        Vr();
        const t3 = Hr(), e2 = qr(), n2 = t3._nodeMap, r2 = this.__key, i2 = this.getLatest(), s2 = e2._cloneNotNeeded, o2 = Nr();
        if (null !== o2 && o2.setCachedNodes(null), s2.has(r2)) return ls(i2), i2;
        const l2 = ko(i2);
        return s2.add(r2), ls(l2), n2.set(r2, l2), l2;
      }
      getTextContent() {
        return "";
      }
      getTextContentSize() {
        return this.getTextContent().length;
      }
      createDOM(e2, n2) {
        t(70);
      }
      updateDOM(e2, n2, r2) {
        t(71);
      }
      exportDOM(t3) {
        return { element: this.createDOM(t3._config, t3) };
      }
      exportJSON() {
        const t3 = this.__state ? this.__state.toJSON() : void 0;
        return { type: this.__type, version: 1, ...t3 };
      }
      static importJSON(e2) {
        t(18, this.name);
      }
      updateFromJSON(t3) {
        return function(t4, e2) {
          const n2 = t4.getWritable();
          return (e2 || n2.__state) && mt(t4).updateFromJSON(e2), n2;
        }(this, t3.$);
      }
      static transform() {
        return null;
      }
      remove(t3) {
        Mn(this, true, t3);
      }
      replace(e2, n2) {
        Vr();
        let r2 = Nr();
        null !== r2 && (r2 = r2.clone()), ro(this, e2);
        const i2 = this.getLatest(), s2 = this.__key, o2 = e2.__key, l2 = e2.getWritable(), c2 = this.getParentOrThrow().getWritable(), a2 = c2.__size;
        os(l2);
        const u2 = i2.getPreviousSibling(), f3 = i2.getNextSibling(), d3 = i2.__prev, h4 = i2.__next, g4 = i2.__parent;
        if (Mn(i2, false, true), null === u2) c2.__first = o2;
        else {
          u2.getWritable().__next = o2;
        }
        if (l2.__prev = d3, null === f3) c2.__last = o2;
        else {
          f3.getWritable().__prev = o2;
        }
        if (l2.__next = h4, l2.__parent = g4, c2.__size = a2, n2 && (di(this) && di(l2) || t(139), this.getChildren().forEach((t3) => {
          l2.append(t3);
        })), cr(r2)) {
          ms(r2);
          const t3 = r2.anchor, e3 = r2.focus;
          t3.key === s2 && or(t3, l2), e3.key === s2 && or(e3, l2);
        }
        return as() === s2 && cs(o2), l2;
      }
      insertAfter(t3, e2 = true) {
        Vr(), ro(this, t3);
        const n2 = this.getWritable(), r2 = t3.getWritable(), i2 = r2.getParent(), s2 = Nr();
        let o2 = false, l2 = false;
        if (null !== i2) {
          const e3 = t3.getIndexWithinParent();
          if (os(r2), cr(s2)) {
            const t4 = i2.__key, n3 = s2.anchor, r3 = s2.focus;
            o2 = "element" === n3.type && n3.key === t4 && n3.offset === e3 + 1, l2 = "element" === r3.type && r3.key === t4 && r3.offset === e3 + 1;
          }
        }
        const c2 = this.getNextSibling(), a2 = this.getParentOrThrow().getWritable(), u2 = r2.__key, f3 = n2.__next;
        if (null === c2) a2.__last = u2;
        else {
          c2.getWritable().__prev = u2;
        }
        if (a2.__size++, n2.__next = u2, r2.__next = f3, r2.__prev = n2.__key, r2.__parent = n2.__parent, e2 && cr(s2)) {
          const t4 = this.getIndexWithinParent();
          Er(s2, a2, t4 + 1);
          const e3 = a2.__key;
          o2 && s2.anchor.set(e3, t4 + 2, "element"), l2 && s2.focus.set(e3, t4 + 2, "element");
        }
        return t3;
      }
      insertBefore(t3, e2 = true) {
        Vr(), ro(this, t3);
        const n2 = this.getWritable(), r2 = t3.getWritable(), i2 = r2.__key;
        os(r2);
        const s2 = this.getPreviousSibling(), o2 = this.getParentOrThrow().getWritable(), l2 = n2.__prev, c2 = this.getIndexWithinParent();
        if (null === s2) o2.__first = i2;
        else {
          s2.getWritable().__next = i2;
        }
        o2.__size++, n2.__prev = i2, r2.__prev = l2, r2.__next = n2.__key, r2.__parent = n2.__parent;
        const a2 = Nr();
        if (e2 && cr(a2)) {
          Er(a2, this.getParentOrThrow(), c2);
        }
        return t3;
      }
      isParentRequired() {
        return false;
      }
      createParentElementNode() {
        return Pi();
      }
      selectStart() {
        return this.selectPrevious();
      }
      selectEnd() {
        return this.selectNext(0, 0);
      }
      selectPrevious(t3, e2) {
        Vr();
        const n2 = this.getPreviousSibling(), r2 = this.getParentOrThrow();
        if (null === n2) return r2.select(0, 0);
        if (di(n2)) return n2.select();
        if (!Qn(n2)) {
          const t4 = n2.getIndexWithinParent() + 1;
          return r2.select(t4, t4);
        }
        return n2.select(t3, e2);
      }
      selectNext(t3, e2) {
        Vr();
        const n2 = this.getNextSibling(), r2 = this.getParentOrThrow();
        if (null === n2) return r2.select();
        if (di(n2)) return n2.select(0, 0);
        if (!Qn(n2)) {
          const t4 = n2.getIndexWithinParent();
          return r2.select(t4, t4);
        }
        return n2.select(t3, e2);
      }
      markDirty() {
        this.getWritable();
      }
      reconcileObservedMutation(t3, e2) {
        this.markDirty();
      }
    };
    On = class _On extends An {
      static getType() {
        return "linebreak";
      }
      static clone(t3) {
        return new _On(t3.__key);
      }
      constructor(t3) {
        super(t3);
      }
      getTextContent() {
        return "\n";
      }
      createDOM() {
        return document.createElement("br");
      }
      updateDOM() {
        return false;
      }
      isInline() {
        return true;
      }
      static importDOM() {
        return { br: (t3) => function(t4) {
          const e2 = t4.parentElement;
          if (null !== e2 && po(e2)) {
            const n2 = e2.firstChild;
            if (n2 === t4 || n2.nextSibling === t4 && Ln(n2)) {
              const n3 = e2.lastChild;
              if (n3 === t4 || n3.previousSibling === t4 && Ln(n3)) return true;
            }
          }
          return false;
        }(t3) || function(t4) {
          const e2 = t4.parentElement;
          if (null !== e2 && po(e2)) {
            const n2 = e2.firstChild;
            if (n2 === t4 || n2.nextSibling === t4 && Ln(n2)) return false;
            const r2 = e2.lastChild;
            if (r2 === t4 || r2.previousSibling === t4 && Ln(r2)) return true;
          }
          return false;
        }(t3) ? null : { conversion: Dn, priority: 0 } };
      }
      static importJSON(t3) {
        return Pn().updateFromJSON(t3);
      }
    };
    Jn = class _Jn extends An {
      static getType() {
        return "text";
      }
      static clone(t3) {
        return new _Jn(t3.__text, t3.__key);
      }
      afterCloneFrom(t3) {
        super.afterCloneFrom(t3), this.__text = t3.__text, this.__format = t3.__format, this.__style = t3.__style, this.__mode = t3.__mode, this.__detail = t3.__detail;
      }
      constructor(t3 = "", e2) {
        super(e2), this.__text = t3, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
      }
      getFormat() {
        return this.getLatest().__format;
      }
      getDetail() {
        return this.getLatest().__detail;
      }
      getMode() {
        const t3 = this.getLatest();
        return G[t3.__mode];
      }
      getStyle() {
        return this.getLatest().__style;
      }
      isToken() {
        return 1 === this.getLatest().__mode;
      }
      isComposing() {
        return this.__key === as();
      }
      isSegmented() {
        return 2 === this.getLatest().__mode;
      }
      isDirectionless() {
        return !!(1 & this.getLatest().__detail);
      }
      isUnmergeable() {
        return !!(2 & this.getLatest().__detail);
      }
      hasFormat(t3) {
        const e2 = j[t3];
        return !!(this.getFormat() & e2);
      }
      isSimpleText() {
        return "text" === this.__type && 0 === this.__mode;
      }
      getTextContent() {
        return this.getLatest().__text;
      }
      getFormatFlags(t3, e2) {
        return rs(this.getLatest().__format, t3, e2);
      }
      canHaveFormat() {
        return true;
      }
      isInline() {
        return true;
      }
      createDOM(t3, e2) {
        const n2 = this.__format, r2 = In(0, n2), i2 = zn(0, n2), s2 = null === r2 ? i2 : r2, o2 = document.createElement(s2);
        let l2 = o2;
        this.hasFormat("code") && o2.setAttribute("spellcheck", "false"), null !== r2 && (l2 = document.createElement(i2), o2.appendChild(l2));
        Rn(l2, this, 0, n2, this.__text, t3);
        const c2 = this.__style;
        return "" !== c2 && (o2.style.cssText = c2), o2;
      }
      updateDOM(e2, n2, r2) {
        const i2 = this.__text, s2 = e2.__format, o2 = this.__format, l2 = In(0, s2), c2 = In(0, o2), a2 = zn(0, s2), u2 = zn(0, o2);
        if ((null === l2 ? a2 : l2) !== (null === c2 ? u2 : c2)) return true;
        if (l2 === c2 && a2 !== u2) {
          const e3 = n2.firstChild;
          null == e3 && t(48);
          const s3 = document.createElement(u2);
          return Rn(s3, this, 0, o2, i2, r2), n2.replaceChild(s3, e3), false;
        }
        let f3 = n2;
        null !== c2 && null !== l2 && (f3 = n2.firstChild, null == f3 && t(49)), Bn(i2, f3, this);
        const d3 = r2.theme.text;
        void 0 !== d3 && s2 !== o2 && Kn(0, s2, o2, f3, d3);
        const h4 = e2.__style, g4 = this.__style;
        return h4 !== g4 && (n2.style.cssText = g4), false;
      }
      static importDOM() {
        return { "#text": () => ({ conversion: Yn, priority: 0 }), b: () => ({ conversion: $n, priority: 0 }), code: () => ({ conversion: Gn, priority: 0 }), em: () => ({ conversion: Gn, priority: 0 }), i: () => ({ conversion: Gn, priority: 0 }), mark: () => ({ conversion: Gn, priority: 0 }), s: () => ({ conversion: Gn, priority: 0 }), span: () => ({ conversion: Un, priority: 0 }), strong: () => ({ conversion: Gn, priority: 0 }), sub: () => ({ conversion: Gn, priority: 0 }), sup: () => ({ conversion: Gn, priority: 0 }), u: () => ({ conversion: Gn, priority: 0 }) };
      }
      static importJSON(t3) {
        return Xn().updateFromJSON(t3);
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setTextContent(t3.text).setFormat(t3.format).setDetail(t3.detail).setMode(t3.mode).setStyle(t3.style);
      }
      exportDOM(e2) {
        let { element: n2 } = super.exportDOM(e2);
        return fo(n2) || t(132), n2.style.whiteSpace = "pre-wrap", this.hasFormat("lowercase") ? n2.style.textTransform = "lowercase" : this.hasFormat("uppercase") ? n2.style.textTransform = "uppercase" : this.hasFormat("capitalize") && (n2.style.textTransform = "capitalize"), this.hasFormat("bold") && (n2 = Wn(n2, "b")), this.hasFormat("italic") && (n2 = Wn(n2, "i")), this.hasFormat("strikethrough") && (n2 = Wn(n2, "s")), this.hasFormat("underline") && (n2 = Wn(n2, "u")), { element: n2 };
      }
      exportJSON() {
        return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), ...super.exportJSON() };
      }
      selectionTransform(t3, e2) {
      }
      setFormat(t3) {
        const e2 = this.getWritable();
        return e2.__format = "string" == typeof t3 ? j[t3] : t3, e2;
      }
      setDetail(t3) {
        const e2 = this.getWritable();
        return e2.__detail = "string" == typeof t3 ? V[t3] : t3, e2;
      }
      setStyle(t3) {
        const e2 = this.getWritable();
        return e2.__style = t3, e2;
      }
      toggleFormat(t3) {
        const e2 = rs(this.getFormat(), t3, null);
        return this.setFormat(e2);
      }
      toggleDirectionless() {
        const t3 = this.getWritable();
        return t3.__detail ^= 1, t3;
      }
      toggleUnmergeable() {
        const t3 = this.getWritable();
        return t3.__detail ^= 2, t3;
      }
      setMode(t3) {
        const e2 = q[t3];
        if (this.__mode === e2) return this;
        const n2 = this.getWritable();
        return n2.__mode = e2, n2;
      }
      setTextContent(t3) {
        if (this.__text === t3) return this;
        const e2 = this.getWritable();
        return e2.__text = t3, e2;
      }
      select(t3, e2) {
        Vr();
        let n2 = t3, r2 = e2;
        const i2 = Nr(), s2 = this.getTextContent(), o2 = this.__key;
        if ("string" == typeof s2) {
          const t4 = s2.length;
          void 0 === n2 && (n2 = t4), void 0 === r2 && (r2 = t4);
        } else n2 = 0, r2 = 0;
        if (!cr(i2)) return Sr(o2, n2, o2, r2, "text", "text");
        {
          const t4 = as();
          t4 !== i2.anchor.key && t4 !== i2.focus.key || cs(o2), i2.setTextNodeRange(this, n2, this, r2);
        }
        return i2;
      }
      selectStart() {
        return this.select(0, 0);
      }
      selectEnd() {
        const t3 = this.getTextContentSize();
        return this.select(t3, t3);
      }
      spliceText(t3, e2, n2, r2) {
        const i2 = this.getWritable(), s2 = i2.__text, o2 = n2.length;
        let l2 = t3;
        l2 < 0 && (l2 = o2 + l2, l2 < 0 && (l2 = 0));
        const c2 = Nr();
        if (r2 && cr(c2)) {
          const e3 = t3 + o2;
          c2.setTextNodeRange(i2, e3, i2, e3);
        }
        const a2 = s2.slice(0, l2) + n2 + s2.slice(l2 + e2);
        return i2.__text = a2, i2;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      splitText(...t3) {
        Vr();
        const e2 = this.getLatest(), n2 = e2.getTextContent();
        if ("" === n2) return [];
        const r2 = e2.__key, i2 = as(), s2 = n2.length;
        t3.sort((t4, e3) => t4 - e3), t3.push(s2);
        const o2 = [], l2 = t3.length;
        for (let e3 = 0, r3 = 0; e3 < s2 && r3 <= l2; r3++) {
          const i3 = t3[r3];
          i3 > e3 && (o2.push(n2.slice(e3, i3)), e3 = i3);
        }
        const c2 = o2.length;
        if (1 === c2) return [e2];
        const a2 = o2[0], u2 = e2.getParent();
        let f3;
        const d3 = e2.getFormat(), h4 = e2.getStyle(), g4 = e2.__detail;
        let _5 = false, p3 = null, y4 = null;
        const m4 = Nr();
        if (cr(m4)) {
          const [t4, e3] = m4.isBackward() ? [m4.focus, m4.anchor] : [m4.anchor, m4.focus];
          "text" === t4.type && t4.key === r2 && (p3 = t4), "text" === e3.type && e3.key === r2 && (y4 = e3);
        }
        e2.isSegmented() ? (f3 = Xn(a2), f3.__format = d3, f3.__style = h4, f3.__detail = g4, _5 = true) : f3 = e2.setTextContent(a2);
        const x4 = [f3];
        for (let t4 = 1; t4 < c2; t4++) {
          const e3 = Xn(o2[t4]);
          e3.__format = d3, e3.__style = h4, e3.__detail = g4;
          const n3 = e3.__key;
          i2 === r2 && cs(n3), x4.push(e3);
        }
        const C4 = p3 ? p3.offset : null, S4 = y4 ? y4.offset : null;
        let v4 = 0;
        for (const t4 of x4) {
          if (!p3 && !y4) break;
          const e3 = v4 + t4.getTextContentSize();
          if (null !== p3 && null !== C4 && C4 <= e3 && C4 >= v4 && (p3.set(t4.getKey(), C4 - v4, "text"), C4 < e3 && (p3 = null)), null !== y4 && null !== S4 && S4 <= e3 && S4 >= v4) {
            y4.set(t4.getKey(), S4 - v4, "text");
            break;
          }
          v4 = e3;
        }
        if (null !== u2) {
          !function(t5) {
            const e4 = t5.getPreviousSibling(), n3 = t5.getNextSibling();
            null !== e4 && ls(e4);
            null !== n3 && ls(n3);
          }(this);
          const t4 = u2.getWritable(), e3 = this.getIndexWithinParent();
          _5 ? (t4.splice(e3, 0, x4), this.remove()) : t4.splice(e3, 1, x4), cr(m4) && Er(m4, u2, e3, c2 - 1);
        }
        return x4;
      }
      mergeWithSibling(e2) {
        const n2 = e2 === this.getPreviousSibling();
        n2 || e2 === this.getNextSibling() || t(50);
        const r2 = this.__key, i2 = e2.__key, s2 = this.__text, o2 = s2.length;
        as() === i2 && cs(r2);
        const l2 = Nr();
        if (cr(l2)) {
          const t3 = l2.anchor, s3 = l2.focus;
          null !== t3 && t3.key === i2 && Or(t3, n2, r2, e2, o2), null !== s3 && s3.key === i2 && Or(s3, n2, r2, e2, o2);
        }
        const c2 = e2.__text, a2 = n2 ? c2 + s2 : s2 + c2;
        this.setTextContent(a2);
        const u2 = this.getWritable();
        return e2.remove(), u2;
      }
      isTextEntity() {
        return false;
      }
    };
    jn = /* @__PURE__ */ new WeakMap();
    qn = { code: "code", em: "italic", i: "italic", mark: "highlight", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
    tr = class _tr extends Jn {
      static getType() {
        return "tab";
      }
      static clone(t3) {
        return new _tr(t3.__key);
      }
      constructor(t3) {
        super("	", t3), this.__detail = 2;
      }
      static importDOM() {
        return null;
      }
      createDOM(t3) {
        const e2 = super.createDOM(t3), n2 = Ls(t3.theme, "tab");
        if (void 0 !== n2) {
          e2.classList.add(...n2);
        }
        return e2;
      }
      static importJSON(t3) {
        return er().updateFromJSON(t3);
      }
      setTextContent(e2) {
        return "	" !== e2 && "" !== e2 && t(126), super.setTextContent("	");
      }
      spliceText(e2, n2, r2, i2) {
        return "" === r2 && 0 === n2 || "	" === r2 && 1 === n2 || t(286), this;
      }
      setDetail(e2) {
        return 2 !== e2 && t(127), this;
      }
      setMode(e2) {
        return "normal" !== e2 && t(128), this;
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
    };
    rr = class {
      constructor(t3, e2, n2) {
        this._selection = null, this.key = t3, this.offset = e2, this.type = n2;
      }
      is(t3) {
        return this.key === t3.key && this.offset === t3.offset && this.type === t3.type;
      }
      isBefore(t3) {
        if (this.key === t3.key) return this.offset < t3.offset;
        return nl(pl(ll(this, "next")), pl(ll(t3, "next"))) < 0;
      }
      getNode() {
        const e2 = us(this.key);
        return null === e2 && t(20), e2;
      }
      set(t3, e2, n2, r2) {
        const i2 = this._selection, s2 = this.key;
        r2 && this.key === t3 && this.offset === e2 && this.type === n2 || (this.key = t3, this.offset = e2, this.type = n2, jr() || (as() === s2 && cs(t3), null !== i2 && (i2.setCachedNodes(null), i2.dirty = true)));
      }
    };
    lr = class _lr {
      constructor(t3) {
        this._cachedNodes = null, this._nodes = t3, this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(t3) {
        this._cachedNodes = t3;
      }
      is(t3) {
        if (!ur(t3)) return false;
        const e2 = this._nodes, n2 = t3._nodes;
        return e2.size === n2.size && Array.from(e2).every((t4) => n2.has(t4));
      }
      isCollapsed() {
        return false;
      }
      isBackward() {
        return false;
      }
      getStartEndPoints() {
        return null;
      }
      add(t3) {
        this.dirty = true, this._nodes.add(t3), this._cachedNodes = null;
      }
      delete(t3) {
        this.dirty = true, this._nodes.delete(t3), this._cachedNodes = null;
      }
      clear() {
        this.dirty = true, this._nodes.clear(), this._cachedNodes = null;
      }
      has(t3) {
        return this._nodes.has(t3);
      }
      clone() {
        return new _lr(new Set(this._nodes));
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(t3) {
      }
      insertText() {
      }
      insertNodes(t3) {
        const e2 = this.getNodes(), n2 = e2.length, r2 = e2[n2 - 1];
        let i2;
        if (Qn(r2)) i2 = r2.select();
        else {
          const t4 = r2.getIndexWithinParent() + 1;
          i2 = r2.getParentOrThrow().select(t4, t4);
        }
        i2.insertNodes(t3);
        for (let t4 = 0; t4 < n2; t4++) e2[t4].remove();
      }
      getNodes() {
        const t3 = this._cachedNodes;
        if (null !== t3) return t3;
        const e2 = this._nodes, n2 = [];
        for (const t4 of e2) {
          const e3 = us(t4);
          null !== e3 && n2.push(e3);
        }
        return jr() || (this._cachedNodes = n2), n2;
      }
      getTextContent() {
        const t3 = this.getNodes();
        let e2 = "";
        for (let n2 = 0; n2 < t3.length; n2++) e2 += t3[n2].getTextContent();
        return e2;
      }
      deleteNodes() {
        const t3 = this.getNodes();
        if ((Nr() || wr()) === this && t3[0]) {
          const e2 = Jo(t3[0], "next");
          al(tl(e2, e2));
        }
        for (const e2 of t3) e2.remove();
      }
    };
    ar = class _ar {
      constructor(t3, e2, n2, r2) {
        this.anchor = t3, this.focus = e2, t3._selection = this, e2._selection = this, this._cachedNodes = null, this.format = n2, this.style = r2, this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(t3) {
        this._cachedNodes = t3;
      }
      is(t3) {
        return !!cr(t3) && (this.anchor.is(t3.anchor) && this.focus.is(t3.focus) && this.format === t3.format && this.style === t3.style);
      }
      isCollapsed() {
        return this.anchor.is(this.focus);
      }
      getNodes() {
        const t3 = this._cachedNodes;
        if (null !== t3) return t3;
        const e2 = function(t4) {
          const e3 = [], [n2, r2] = t4.getTextSlices();
          n2 && e3.push(n2.caret.origin);
          const i2 = /* @__PURE__ */ new Set(), s2 = /* @__PURE__ */ new Set();
          for (const n3 of t4) if (Ko(n3)) {
            const { origin: t5 } = n3;
            0 === e3.length ? i2.add(t5) : (s2.add(t5), e3.push(t5));
          } else {
            const { origin: t5 } = n3;
            di(t5) && s2.has(t5) || e3.push(t5);
          }
          r2 && e3.push(r2.caret.origin);
          if (zo(t4.focus) && di(t4.focus.origin) && null === t4.focus.getNodeAtCaret()) for (let n3 = Vo(t4.focus.origin, "previous"); Ko(n3) && i2.has(n3.origin) && !n3.origin.isEmpty() && n3.origin.is(e3[e3.length - 1]); n3 = Ho(n3)) i2.delete(n3.origin), e3.pop();
          for (; e3.length > 1; ) {
            const t5 = e3[e3.length - 1];
            if (!di(t5) || s2.has(t5) || t5.isEmpty() || i2.has(t5)) break;
            e3.pop();
          }
          if (0 === e3.length && t4.isCollapsed()) {
            const n3 = pl(t4.anchor), r3 = pl(t4.anchor.getFlipped()), i3 = (t5) => Lo(t5) ? t5.origin : t5.getNodeAtCaret(), s3 = i3(n3) || i3(r3) || (t4.anchor.getNodeAtCaret() ? n3.origin : r3.origin);
            e3.push(s3);
          }
          return e3;
        }(xl(fl(this), "next"));
        return jr() || (this._cachedNodes = e2), e2;
      }
      setTextNodeRange(t3, e2, n2, r2) {
        this.anchor.set(t3.__key, e2, "text"), this.focus.set(n2.__key, r2, "text");
      }
      getTextContent() {
        const t3 = this.getNodes();
        if (0 === t3.length) return "";
        const e2 = t3[0], n2 = t3[t3.length - 1], r2 = this.anchor, i2 = this.focus, s2 = r2.isBefore(i2), [o2, l2] = dr(this);
        let c2 = "", a2 = true;
        for (let u2 = 0; u2 < t3.length; u2++) {
          const f3 = t3[u2];
          if (di(f3) && !f3.isInline()) a2 || (c2 += "\n"), a2 = !f3.isEmpty();
          else if (a2 = false, Qn(f3)) {
            let t4 = f3.getTextContent();
            f3 === e2 ? f3 === n2 ? "element" === r2.type && "element" === i2.type && i2.offset !== r2.offset || (t4 = o2 < l2 ? t4.slice(o2, l2) : t4.slice(l2, o2)) : t4 = s2 ? t4.slice(o2) : t4.slice(l2) : f3 === n2 && (t4 = s2 ? t4.slice(0, l2) : t4.slice(0, o2)), c2 += t4;
          } else !_i(f3) && !Fn(f3) || f3 === n2 && this.isCollapsed() || (c2 += f3.getTextContent());
        }
        return c2;
      }
      applyDOMRange(t3) {
        const e2 = qr(), n2 = e2.getEditorState()._selection, r2 = xr(t3.startContainer, t3.startOffset, t3.endContainer, t3.endOffset, e2, n2);
        if (null === r2) return;
        const [i2, s2] = r2;
        this.anchor.set(i2.key, i2.offset, i2.type, true), this.focus.set(s2.key, s2.offset, s2.type, true), vt(this);
      }
      clone() {
        const t3 = this.anchor, e2 = this.focus;
        return new _ar(ir(t3.key, t3.offset, t3.type), ir(e2.key, e2.offset, e2.type), this.format, this.style);
      }
      toggleFormat(t3) {
        this.format = rs(this.format, t3, null), this.dirty = true;
      }
      setStyle(t3) {
        this.style = t3, this.dirty = true;
      }
      hasFormat(t3) {
        const e2 = j[t3];
        return !!(this.format & e2);
      }
      insertRawText(t3) {
        const e2 = t3.split(/(\r?\n|\t)/), n2 = [], r2 = e2.length;
        for (let t4 = 0; t4 < r2; t4++) {
          const r3 = e2[t4];
          "\n" === r3 || "\r\n" === r3 ? n2.push(Pn()) : "	" === r3 ? n2.push(er()) : n2.push(Xn(r3));
        }
        this.insertNodes(n2);
      }
      insertText(e2) {
        const n2 = this.anchor, r2 = this.focus, i2 = this.format, s2 = this.style;
        let o2 = n2, l2 = r2;
        !this.isCollapsed() && r2.isBefore(n2) && (o2 = r2, l2 = n2), "element" === o2.type && function(t3, e3, n3, r3) {
          const i3 = t3.getNode(), s3 = i3.getChildAtIndex(t3.offset), o3 = Xn(), l3 = yi(i3) ? Pi().append(o3) : o3;
          o3.setFormat(n3), o3.setStyle(r3), null === s3 ? i3.append(l3) : s3.insertBefore(l3), t3.is(e3) && e3.set(o3.__key, 0, "text"), t3.set(o3.__key, 0, "text");
        }(o2, l2, i2, s2), "element" === l2.type && cl(l2, pl(ll(l2, "next")));
        const c2 = o2.offset;
        let a2 = l2.offset;
        const u2 = this.getNodes(), f3 = u2.length;
        let d3 = u2[0];
        Qn(d3) || t(26);
        const h4 = d3.getTextContent().length, g4 = d3.getParentOrThrow();
        let _5 = u2[f3 - 1];
        if (1 === f3 && "element" === l2.type && (a2 = h4, l2.set(o2.key, a2, "text")), this.isCollapsed() && c2 === h4 && (Zi(d3) || !d3.canInsertTextAfter() || !g4.canInsertTextAfter() && null === d3.getNextSibling())) {
          let t3 = d3.getNextSibling();
          if (Qn(t3) && t3.canInsertTextBefore() && !Zi(t3) || (t3 = Xn(), t3.setFormat(i2), t3.setStyle(s2), g4.canInsertTextAfter() ? d3.insertAfter(t3) : g4.insertAfter(t3)), t3.select(0, 0), d3 = t3, "" !== e2) return void this.insertText(e2);
        } else if (this.isCollapsed() && 0 === c2 && (Zi(d3) || !d3.canInsertTextBefore() || !g4.canInsertTextBefore() && null === d3.getPreviousSibling())) {
          let t3 = d3.getPreviousSibling();
          if (Qn(t3) && !Zi(t3) || (t3 = Xn(), t3.setFormat(i2), g4.canInsertTextBefore() ? d3.insertBefore(t3) : g4.insertBefore(t3)), t3.select(), d3 = t3, "" !== e2) return void this.insertText(e2);
        } else if (d3.isSegmented() && c2 !== h4) {
          const t3 = Xn(d3.getTextContent());
          t3.setFormat(i2), d3.replace(t3), d3 = t3;
        } else if (!this.isCollapsed() && "" !== e2) {
          const t3 = _5.getParent();
          if (!g4.canInsertTextBefore() || !g4.canInsertTextAfter() || di(t3) && (!t3.canInsertTextBefore() || !t3.canInsertTextAfter())) return this.insertText(""), mr(this.anchor, this.focus, null), void this.insertText(e2);
        }
        if (1 === f3) {
          if (Qi(d3)) {
            const t4 = Xn(e2);
            return t4.select(), void d3.replace(t4);
          }
          const t3 = d3.getFormat(), n3 = d3.getStyle();
          if (c2 !== a2 || t3 === i2 && n3 === s2) {
            if (nr(d3)) {
              const t4 = Xn(e2);
              return t4.setFormat(i2), t4.setStyle(s2), t4.select(), void d3.replace(t4);
            }
          } else {
            if ("" !== d3.getTextContent()) {
              const t4 = Xn(e2);
              if (t4.setFormat(i2), t4.setStyle(s2), t4.select(), 0 === c2) d3.insertBefore(t4, false);
              else {
                const [e3] = d3.splitText(c2);
                e3.insertAfter(t4, false);
              }
              return void (t4.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= e2.length));
            }
            d3.setFormat(i2), d3.setStyle(s2);
          }
          const r3 = a2 - c2;
          d3 = d3.spliceText(c2, r3, e2, true), "" === d3.getTextContent() ? d3.remove() : "text" === this.anchor.type && (d3.isComposing() ? this.anchor.offset -= e2.length : (this.format = t3, this.style = n3));
        } else {
          const t3 = /* @__PURE__ */ new Set([...d3.getParentKeys(), ..._5.getParentKeys()]), n3 = di(d3) ? d3 : d3.getParentOrThrow();
          let r3 = di(_5) ? _5 : _5.getParentOrThrow(), i3 = _5;
          if (!n3.is(r3) && r3.isInline()) do {
            i3 = r3, r3 = r3.getParentOrThrow();
          } while (r3.isInline());
          if ("text" === l2.type && (0 !== a2 || "" === _5.getTextContent()) || "element" === l2.type && _5.getIndexWithinParent() < a2) if (Qn(_5) && !Qi(_5) && a2 !== _5.getTextContentSize()) {
            if (_5.isSegmented()) {
              const t4 = Xn(_5.getTextContent());
              _5.replace(t4), _5 = t4;
            }
            yi(l2.getNode()) || "text" !== l2.type || (_5 = _5.spliceText(0, a2, "")), t3.add(_5.__key);
          } else {
            const t4 = _5.getParentOrThrow();
            t4.canBeEmpty() || 1 !== t4.getChildrenSize() ? _5.remove() : t4.remove();
          }
          else t3.add(_5.__key);
          const s3 = r3.getChildren(), o3 = new Set(u2), g5 = n3.is(r3), p3 = n3.isInline() && null === d3.getNextSibling() ? n3 : d3;
          for (let t4 = s3.length - 1; t4 >= 0; t4--) {
            const e3 = s3[t4];
            if (e3.is(d3) || di(e3) && e3.isParentOf(d3)) break;
            e3.isAttached() && (!o3.has(e3) || e3.is(i3) ? g5 || p3.insertAfter(e3, false) : e3.remove());
          }
          if (!g5) {
            let e3 = r3, n4 = null;
            for (; null !== e3; ) {
              const r4 = e3.getChildren(), i4 = r4.length;
              (0 === i4 || r4[i4 - 1].is(n4)) && (t3.delete(e3.__key), n4 = e3), e3 = e3.getParent();
            }
          }
          if (Qi(d3)) if (c2 === h4) d3.select();
          else {
            const t4 = Xn(e2);
            t4.select(), d3.replace(t4);
          }
          else d3 = d3.spliceText(c2, h4 - c2, e2, true), "" === d3.getTextContent() ? d3.remove() : d3.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= e2.length);
          for (let e3 = 1; e3 < f3; e3++) {
            const n4 = u2[e3], r4 = n4.__key;
            t3.has(r4) || n4.remove();
          }
        }
      }
      removeText() {
        const t3 = Nr() === this;
        ul(this, _l(fl(this))), t3 && Nr() !== this && ms(this);
      }
      formatText(t3, e2 = null) {
        if (this.isCollapsed()) return this.toggleFormat(t3), void cs(null);
        const n2 = this.getNodes(), r2 = [];
        for (const t4 of n2) Qn(t4) && r2.push(t4);
        const i2 = (e3) => {
          n2.forEach((n3) => {
            if (di(n3)) {
              const r3 = n3.getFormatFlags(t3, e3);
              n3.setTextFormat(r3);
            }
          });
        }, s2 = r2.length;
        if (0 === s2) return this.toggleFormat(t3), cs(null), void i2(e2);
        const o2 = this.anchor, l2 = this.focus, c2 = this.isBackward(), a2 = c2 ? l2 : o2, u2 = c2 ? o2 : l2;
        let f3 = 0, d3 = r2[0], h4 = "element" === a2.type ? 0 : a2.offset;
        if ("text" === a2.type && h4 === d3.getTextContentSize() && (f3 = 1, d3 = r2[1], h4 = 0), null == d3) return;
        const g4 = d3.getFormatFlags(t3, e2);
        i2(g4);
        const _5 = s2 - 1;
        let p3 = r2[_5];
        const y4 = "text" === u2.type ? u2.offset : p3.getTextContentSize();
        if (d3.is(p3)) {
          if (h4 === y4) return;
          if (Zi(d3) || 0 === h4 && y4 === d3.getTextContentSize()) d3.setFormat(g4);
          else {
            const t4 = d3.splitText(h4, y4), e3 = 0 === h4 ? t4[0] : t4[1];
            e3.setFormat(g4), "text" === a2.type && a2.set(e3.__key, 0, "text"), "text" === u2.type && u2.set(e3.__key, y4 - h4, "text");
          }
          return void (this.format = g4);
        }
        0 === h4 || Zi(d3) || ([, d3] = d3.splitText(h4), h4 = 0), d3.setFormat(g4);
        const m4 = p3.getFormatFlags(t3, g4);
        y4 > 0 && (y4 === p3.getTextContentSize() || Zi(p3) || ([p3] = p3.splitText(y4)), p3.setFormat(m4));
        for (let e3 = f3 + 1; e3 < _5; e3++) {
          const n3 = r2[e3], i3 = n3.getFormatFlags(t3, m4);
          n3.setFormat(i3);
        }
        "text" === a2.type && a2.set(d3.__key, h4, "text"), "text" === u2.type && u2.set(p3.__key, y4, "text"), this.format = g4 | m4;
      }
      insertNodes(e2) {
        if (0 === e2.length) return;
        if (this.isCollapsed() || this.removeText(), "root" === this.anchor.key) {
          this.insertParagraph();
          const n3 = Nr();
          return cr(n3) || t(134), n3.insertNodes(e2);
        }
        const n2 = (this.isBackward() ? this.focus : this.anchor).getNode(), r2 = mo(n2, yo), i2 = e2[e2.length - 1];
        if (di(r2) && "__language" in r2) {
          if ("__language" in e2[0]) this.insertText(e2[0].getTextContent());
          else {
            const t3 = Ir(this);
            r2.splice(t3, 0, e2), i2.selectEnd();
          }
          return;
        }
        if (!e2.some((t3) => (di(t3) || _i(t3)) && !t3.isInline())) {
          di(r2) || t(211, n2.constructor.name, n2.getType());
          const s3 = Ir(this);
          return r2.splice(s3, 0, e2), void i2.selectEnd();
        }
        const s2 = function(t3) {
          const e3 = Pi();
          let n3 = null;
          for (let r3 = 0; r3 < t3.length; r3++) {
            const i3 = t3[r3], s3 = Fn(i3);
            if (s3 || _i(i3) && i3.isInline() || di(i3) && i3.isInline() || Qn(i3) || i3.isParentRequired()) {
              if (null === n3 && (n3 = i3.createParentElementNode(), e3.append(n3), s3)) continue;
              null !== n3 && n3.append(i3);
            } else e3.append(i3), n3 = null;
          }
          return e3;
        }(e2), o2 = s2.getLastDescendant(), l2 = s2.getChildren(), c2 = !di(r2) || !r2.isEmpty() ? this.insertParagraph() : null, a2 = l2[l2.length - 1];
        let u2 = l2[0];
        var f3;
        di(f3 = u2) && yo(f3) && !f3.isEmpty() && di(r2) && (!r2.isEmpty() || r2.canMergeWhenEmpty()) && (di(r2) || t(211, n2.constructor.name, n2.getType()), r2.append(...u2.getChildren()), u2 = l2[1]), u2 && (null === r2 && t(212, n2.constructor.name, n2.getType()), function(e3, n3, r3) {
          const i3 = n3.getParentOrThrow().getLastChild();
          let s3 = n3;
          const o3 = [n3];
          for (; s3 !== i3; ) s3.getNextSibling() || t(140), s3 = s3.getNextSibling(), o3.push(s3);
          let l3 = e3;
          for (const t3 of o3) l3 = l3.insertAfter(t3);
        }(r2, u2));
        const d3 = mo(o2, yo);
        c2 && di(d3) && (c2.canMergeWhenEmpty() || yo(a2)) && (d3.append(...c2.getChildren()), c2.remove()), di(r2) && r2.isEmpty() && r2.remove(), o2.selectEnd();
        const h4 = di(r2) ? r2.getLastChild() : null;
        Fn(h4) && d3 !== r2 && h4.remove();
      }
      insertParagraph() {
        if ("root" === this.anchor.key) {
          const t3 = Pi();
          return ps().splice(this.anchor.offset, 0, [t3]), t3.select(), t3;
        }
        const e2 = Ir(this), n2 = mo(this.anchor.getNode(), yo);
        di(n2) || t(213);
        const r2 = n2.getChildAtIndex(e2), i2 = r2 ? [r2, ...r2.getNextSiblings()] : [], s2 = n2.insertNewAfter(this, false);
        return s2 ? (s2.append(...i2), s2.selectStart(), s2) : null;
      }
      insertLineBreak(t3) {
        const e2 = Pn();
        if (this.insertNodes([e2]), t3) {
          const t4 = e2.getParentOrThrow(), n2 = e2.getIndexWithinParent();
          t4.select(n2, n2);
        }
      }
      extract() {
        const t3 = this.getNodes(), e2 = t3.length, n2 = e2 - 1, r2 = this.anchor, i2 = this.focus;
        let s2 = t3[0], o2 = t3[n2];
        const [l2, c2] = dr(this);
        if (0 === e2) return [];
        if (1 === e2) {
          if (Qn(s2) && !this.isCollapsed()) {
            const t4 = l2 > c2 ? c2 : l2, e3 = l2 > c2 ? l2 : c2, n3 = s2.splitText(t4, e3), r3 = 0 === t4 ? n3[0] : n3[1];
            return null != r3 ? [r3] : [];
          }
          return [s2];
        }
        const a2 = r2.isBefore(i2);
        if (Qn(s2)) {
          const e3 = a2 ? l2 : c2;
          e3 === s2.getTextContentSize() ? t3.shift() : 0 !== e3 && ([, s2] = s2.splitText(e3), t3[0] = s2);
        }
        if (Qn(o2)) {
          const e3 = o2.getTextContent().length, r3 = a2 ? c2 : l2;
          0 === r3 ? t3.pop() : r3 !== e3 && ([o2] = o2.splitText(r3), t3[n2] = o2);
        }
        return t3;
      }
      modify(t3, e2, n2) {
        if (Kr(this, t3, e2, n2)) return;
        const r2 = "move" === t3, i2 = qr(), s2 = lo(Xs(i2));
        if (!s2) return;
        const o2 = i2._blockCursorElement, l2 = i2._rootElement, c2 = this.focus.getNode();
        if (null === l2 || null === o2 || !di(c2) || c2.isInline() || c2.canBeEmpty() || oo(o2, i2, l2), this.dirty) {
          let t4 = Us(i2, this.anchor.key), e3 = Us(i2, this.focus.key);
          "text" === this.anchor.type && (t4 = ns(t4)), "text" === this.focus.type && (e3 = ns(e3)), t4 && e3 && Dr(s2, t4, this.anchor.offset, e3, this.focus.offset);
        }
        if (function(t4, e3, n3, r3) {
          t4.modify(e3, n3, r3);
        }(s2, t3, e2 ? "backward" : "forward", n2), s2.rangeCount > 0) {
          const t4 = s2.getRangeAt(0), n3 = this.anchor.getNode(), i3 = yi(n3) ? n3 : Zs(n3);
          if (this.applyDOMRange(t4), this.dirty = true, !r2) {
            const n4 = this.getNodes(), r3 = [];
            let o3 = false;
            for (let t5 = 0; t5 < n4.length; t5++) {
              const e3 = n4[t5];
              qs(e3, i3) ? r3.push(e3) : o3 = true;
            }
            if (o3 && r3.length > 0) if (e2) {
              const t5 = r3[0];
              di(t5) ? t5.selectStart() : t5.getParentOrThrow().selectStart();
            } else {
              const t5 = r3[r3.length - 1];
              di(t5) ? t5.selectEnd() : t5.getParentOrThrow().selectEnd();
            }
            s2.anchorNode === t4.startContainer && s2.anchorOffset === t4.startOffset || function(t5) {
              const e3 = t5.focus, n5 = t5.anchor, r4 = n5.key, i4 = n5.offset, s3 = n5.type;
              n5.set(e3.key, e3.offset, e3.type, true), e3.set(r4, i4, s3, true);
            }(this);
          }
        }
        "lineboundary" === n2 && Kr(this, t3, e2, n2, "decorators");
      }
      forwardDeletion(t3, e2, n2) {
        if (!n2 && ("element" === t3.type && di(e2) && t3.offset === e2.getChildrenSize() || "text" === t3.type && t3.offset === e2.getTextContentSize())) {
          const t4 = e2.getParent(), n3 = e2.getNextSibling() || (null === t4 ? null : t4.getNextSibling());
          if (di(n3) && n3.isShadowRoot()) return true;
        }
        return false;
      }
      deleteCharacter(t3) {
        const e2 = this.isCollapsed();
        if (this.isCollapsed()) {
          const e3 = this.anchor;
          let n2 = e3.getNode();
          if (this.forwardDeletion(e3, n2, t3)) return;
          const r2 = Qo(ll(e3, t3 ? "previous" : "next"));
          if (r2.getTextSlices().every((t4) => null === t4 || 0 === t4.distance)) {
            let t4 = { type: "initial" };
            for (const e4 of r2.iterNodeCarets("shadowRoot")) if (Ko(e4)) if (e4.origin.isInline()) ;
            else {
              if (e4.origin.isShadowRoot()) {
                if ("merge-block" === t4.type) break;
                if (di(r2.anchor.origin) && r2.anchor.origin.isEmpty()) {
                  const t5 = pl(e4);
                  ul(this, tl(t5, t5)), r2.anchor.origin.remove();
                }
                return;
              }
              "merge-next-block" !== t4.type && "merge-block" !== t4.type || (t4 = { block: t4.block, caret: e4, type: "merge-block" });
            }
            else {
              if ("merge-block" === t4.type) break;
              if (zo(e4)) {
                if (di(e4.origin)) {
                  if (e4.origin.isInline()) {
                    if (!e4.origin.isParentOf(r2.anchor.origin)) break;
                  } else t4 = { block: e4.origin, type: "merge-next-block" };
                  continue;
                }
                if (_i(e4.origin)) {
                  if (e4.origin.isIsolated()) ;
                  else if ("merge-next-block" === t4.type && (e4.origin.isKeyboardSelectable() || !e4.origin.isInline()) && di(r2.anchor.origin) && r2.anchor.origin.isEmpty()) {
                    r2.anchor.origin.remove();
                    const t5 = kr();
                    t5.add(e4.origin.getKey()), ms(t5);
                  } else e4.origin.remove();
                  return;
                }
                break;
              }
            }
            if ("merge-block" === t4.type) {
              const { caret: e4, block: n3 } = t4;
              return ul(this, tl(!e4.origin.isEmpty() && n3.isEmpty() ? dl(Jo(n3, e4.direction)) : r2.anchor, e4)), this.removeText();
            }
          }
          const i2 = this.focus;
          if (this.modify("extend", t3, "character"), this.isCollapsed()) {
            if (t3 && 0 === e3.offset && hr(this, e3.getNode())) return;
          } else {
            const r3 = "text" === i2.type ? i2.getNode() : null;
            if (n2 = "text" === e3.type ? e3.getNode() : null, null !== r3 && r3.isSegmented()) {
              const e4 = i2.offset, s2 = r3.getTextContentSize();
              if (r3.is(n2) || t3 && e4 !== s2 || !t3 && 0 !== e4) return void _r(r3, t3, e4);
            } else if (null !== n2 && n2.isSegmented()) {
              const i3 = e3.offset, s2 = n2.getTextContentSize();
              if (n2.is(r3) || t3 && 0 !== i3 || !t3 && i3 !== s2) return void _r(n2, t3, i3);
            }
            !function(t4, e4) {
              const n3 = t4.anchor, r4 = t4.focus, i3 = n3.getNode(), s2 = r4.getNode();
              if (i3 === s2 && "text" === n3.type && "text" === r4.type) {
                const t5 = n3.offset, s3 = r4.offset, o2 = t5 < s3, l2 = o2 ? t5 : s3, c2 = o2 ? s3 : t5, a2 = c2 - 1;
                if (l2 !== a2) {
                  (function(t6) {
                    return !(Ss(t6) || gr(t6));
                  })(i3.getTextContent().slice(l2, c2)) && (e4 ? r4.set(r4.key, a2, r4.type) : n3.set(n3.key, a2, n3.type));
                }
              }
            }(this, t3);
          }
        }
        if (this.removeText(), t3 && !e2 && this.isCollapsed() && "element" === this.anchor.type && 0 === this.anchor.offset) {
          const t4 = this.anchor.getNode();
          t4.isEmpty() && yi(t4.getParent()) && null === t4.getPreviousSibling() && hr(this, t4);
        }
      }
      deleteLine(t3) {
        this.isCollapsed() && this.modify("extend", t3, "lineboundary"), this.isCollapsed() ? this.deleteCharacter(t3) : this.removeText();
      }
      deleteWord(t3) {
        if (this.isCollapsed()) {
          const e2 = this.anchor, n2 = e2.getNode();
          if (this.forwardDeletion(e2, n2, t3)) return;
          this.modify("extend", t3, "word");
        }
        this.removeText();
      }
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getStartEndPoints() {
        return [this.anchor, this.focus];
      }
    };
    gr = (() => {
      try {
        const t3 = new RegExp("\\p{Emoji}", "u"), e2 = t3.test.bind(t3);
        if (e2("\u2764\uFE0F") && e2("#\uFE0F\u20E3") && e2("\u{1F44D}")) return e2;
      } catch (t3) {
      }
      return () => false;
    })();
    Br = null;
    Rr = null;
    Wr = false;
    Jr = false;
    Ur = 0;
    $r = { characterData: true, childList: true, subtree: true };
    ai = class _ai {
      constructor(t3, e2, n2) {
        this.element = t3, this.before = e2 || null, this.after = n2 || null;
      }
      withBefore(t3) {
        return new _ai(this.element, t3, this.after);
      }
      withAfter(t3) {
        return new _ai(this.element, this.before, t3);
      }
      withElement(t3) {
        return this.element === t3 ? this : new _ai(t3, this.before, this.after);
      }
      insertChild(e2) {
        const n2 = this.before || this.getManagedLineBreak();
        return null !== n2 && n2.parentElement !== this.element && t(222), this.element.insertBefore(e2, n2), this;
      }
      removeChild(e2) {
        return e2.parentElement !== this.element && t(223), this.element.removeChild(e2), this;
      }
      replaceChild(e2, n2) {
        return n2.parentElement !== this.element && t(224), this.element.replaceChild(e2, n2), this;
      }
      getFirstChild() {
        const t3 = this.after ? this.after.nextSibling : this.element.firstChild;
        return t3 === this.before || t3 === this.getManagedLineBreak() ? null : t3;
      }
      getManagedLineBreak() {
        return this.element.__lexicalLineBreak || null;
      }
      setManagedLineBreak(t3) {
        if (null === t3) this.removeManagedLineBreak();
        else {
          const e2 = "decorator" === t3 && (l || o);
          this.insertManagedLineBreak(e2);
        }
      }
      removeManagedLineBreak() {
        const t3 = this.getManagedLineBreak();
        if (t3) {
          const e2 = this.element, n2 = "IMG" === t3.nodeName ? t3.nextSibling : null;
          n2 && e2.removeChild(n2), e2.removeChild(t3), e2.__lexicalLineBreak = void 0;
        }
      }
      insertManagedLineBreak(t3) {
        const e2 = this.getManagedLineBreak();
        if (e2) {
          if (t3 === ("IMG" === e2.nodeName)) return;
          this.removeManagedLineBreak();
        }
        const n2 = this.element, r2 = this.before, i2 = document.createElement("br");
        if (n2.insertBefore(i2, r2), t3) {
          const t4 = document.createElement("img");
          t4.setAttribute("data-lexical-linebreak", "true"), t4.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;", t4.alt = "", n2.insertBefore(t4, i2), n2.__lexicalLineBreak = t4;
        } else n2.__lexicalLineBreak = i2;
      }
      getFirstChildOffset() {
        let t3 = 0;
        for (let e2 = this.after; null !== e2; e2 = e2.previousSibling) t3++;
        return t3;
      }
      resolveChildIndex(t3, e2, n2, r2) {
        if (n2 === this.element) {
          const e3 = this.getFirstChildOffset();
          return [t3, Math.min(e3 + t3.getChildrenSize(), Math.max(e3, r2))];
        }
        const i2 = ui(e2, n2);
        i2.push(r2);
        const s2 = ui(e2, this.element);
        let o2 = t3.getIndexWithinParent();
        for (let t4 = 0; t4 < s2.length; t4++) {
          const e3 = i2[t4], n3 = s2[t4];
          if (void 0 === e3 || e3 < n3) break;
          if (e3 > n3) {
            o2 += 1;
            break;
          }
        }
        return [t3.getParentOrThrow(), o2];
      }
    };
    fi = class extends An {
      constructor(t3) {
        super(t3), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__style = "", this.__indent = 0, this.__dir = null, this.__textFormat = 0, this.__textStyle = "";
      }
      afterCloneFrom(t3) {
        super.afterCloneFrom(t3), this.__first = t3.__first, this.__last = t3.__last, this.__size = t3.__size, this.__indent = t3.__indent, this.__format = t3.__format, this.__style = t3.__style, this.__dir = t3.__dir, this.__textFormat = t3.__textFormat, this.__textStyle = t3.__textStyle;
      }
      getFormat() {
        return this.getLatest().__format;
      }
      getFormatType() {
        const t3 = this.getFormat();
        return H[t3] || "";
      }
      getStyle() {
        return this.getLatest().__style;
      }
      getIndent() {
        return this.getLatest().__indent;
      }
      getChildren() {
        const t3 = [];
        let e2 = this.getFirstChild();
        for (; null !== e2; ) t3.push(e2), e2 = e2.getNextSibling();
        return t3;
      }
      getChildrenKeys() {
        const t3 = [];
        let e2 = this.getFirstChild();
        for (; null !== e2; ) t3.push(e2.__key), e2 = e2.getNextSibling();
        return t3;
      }
      getChildrenSize() {
        return this.getLatest().__size;
      }
      isEmpty() {
        return 0 === this.getChildrenSize();
      }
      isDirty() {
        const t3 = qr()._dirtyElements;
        return null !== t3 && t3.has(this.__key);
      }
      isLastChild() {
        const t3 = this.getLatest(), e2 = this.getParentOrThrow().getLastChild();
        return null !== e2 && e2.is(t3);
      }
      getAllTextNodes() {
        const t3 = [];
        let e2 = this.getFirstChild();
        for (; null !== e2; ) {
          if (Qn(e2) && t3.push(e2), di(e2)) {
            const n2 = e2.getAllTextNodes();
            t3.push(...n2);
          }
          e2 = e2.getNextSibling();
        }
        return t3;
      }
      getFirstDescendant() {
        let t3 = this.getFirstChild();
        for (; di(t3); ) {
          const e2 = t3.getFirstChild();
          if (null === e2) break;
          t3 = e2;
        }
        return t3;
      }
      getLastDescendant() {
        let t3 = this.getLastChild();
        for (; di(t3); ) {
          const e2 = t3.getLastChild();
          if (null === e2) break;
          t3 = e2;
        }
        return t3;
      }
      getDescendantByIndex(t3) {
        const e2 = this.getChildren(), n2 = e2.length;
        if (t3 >= n2) {
          const t4 = e2[n2 - 1];
          return di(t4) && t4.getLastDescendant() || t4 || null;
        }
        const r2 = e2[t3];
        return di(r2) && r2.getFirstDescendant() || r2 || null;
      }
      getFirstChild() {
        const t3 = this.getLatest().__first;
        return null === t3 ? null : us(t3);
      }
      getFirstChildOrThrow() {
        const e2 = this.getFirstChild();
        return null === e2 && t(45, this.__key), e2;
      }
      getLastChild() {
        const t3 = this.getLatest().__last;
        return null === t3 ? null : us(t3);
      }
      getLastChildOrThrow() {
        const e2 = this.getLastChild();
        return null === e2 && t(96, this.__key), e2;
      }
      getChildAtIndex(t3) {
        const e2 = this.getChildrenSize();
        let n2, r2;
        if (t3 < e2 / 2) {
          for (n2 = this.getFirstChild(), r2 = 0; null !== n2 && r2 <= t3; ) {
            if (r2 === t3) return n2;
            n2 = n2.getNextSibling(), r2++;
          }
          return null;
        }
        for (n2 = this.getLastChild(), r2 = e2 - 1; null !== n2 && r2 >= t3; ) {
          if (r2 === t3) return n2;
          n2 = n2.getPreviousSibling(), r2--;
        }
        return null;
      }
      getTextContent() {
        let t3 = "";
        const e2 = this.getChildren(), n2 = e2.length;
        for (let r2 = 0; r2 < n2; r2++) {
          const i2 = e2[r2];
          t3 += i2.getTextContent(), di(i2) && r2 !== n2 - 1 && !i2.isInline() && (t3 += B);
        }
        return t3;
      }
      getTextContentSize() {
        let t3 = 0;
        const e2 = this.getChildren(), n2 = e2.length;
        for (let r2 = 0; r2 < n2; r2++) {
          const i2 = e2[r2];
          t3 += i2.getTextContentSize(), di(i2) && r2 !== n2 - 1 && !i2.isInline() && (t3 += B.length);
        }
        return t3;
      }
      getDirection() {
        return this.getLatest().__dir;
      }
      getTextFormat() {
        return this.getLatest().__textFormat;
      }
      hasFormat(t3) {
        if ("" !== t3) {
          const e2 = Y[t3];
          return !!(this.getFormat() & e2);
        }
        return false;
      }
      hasTextFormat(t3) {
        const e2 = j[t3];
        return !!(this.getTextFormat() & e2);
      }
      getFormatFlags(t3, e2) {
        return rs(this.getLatest().__textFormat, t3, e2);
      }
      getTextStyle() {
        return this.getLatest().__textStyle;
      }
      select(t3, e2) {
        Vr();
        const n2 = Nr();
        let r2 = t3, i2 = e2;
        const s2 = this.getChildrenSize();
        if (!this.canBeEmpty()) {
          if (0 === t3 && 0 === e2) {
            const t4 = this.getFirstChild();
            if (Qn(t4) || di(t4)) return t4.select(0, 0);
          } else if (!(void 0 !== t3 && t3 !== s2 || void 0 !== e2 && e2 !== s2)) {
            const t4 = this.getLastChild();
            if (Qn(t4) || di(t4)) return t4.select();
          }
        }
        void 0 === r2 && (r2 = s2), void 0 === i2 && (i2 = s2);
        const o2 = this.__key;
        return cr(n2) ? (n2.anchor.set(o2, r2, "element"), n2.focus.set(o2, i2, "element"), n2.dirty = true, n2) : Sr(o2, r2, o2, i2, "element", "element");
      }
      selectStart() {
        const t3 = this.getFirstDescendant();
        return t3 ? t3.selectStart() : this.select();
      }
      selectEnd() {
        const t3 = this.getLastDescendant();
        return t3 ? t3.selectEnd() : this.select();
      }
      clear() {
        const t3 = this.getWritable();
        return this.getChildren().forEach((t4) => t4.remove()), t3;
      }
      append(...t3) {
        return this.splice(this.getChildrenSize(), 0, t3);
      }
      setDirection(t3) {
        const e2 = this.getWritable();
        return e2.__dir = t3, e2;
      }
      setFormat(t3) {
        return this.getWritable().__format = "" !== t3 ? Y[t3] : 0, this;
      }
      setStyle(t3) {
        return this.getWritable().__style = t3 || "", this;
      }
      setTextFormat(t3) {
        const e2 = this.getWritable();
        return e2.__textFormat = t3, e2;
      }
      setTextStyle(t3) {
        const e2 = this.getWritable();
        return e2.__textStyle = t3, e2;
      }
      setIndent(t3) {
        return this.getWritable().__indent = t3, this;
      }
      splice(e2, n2, r2) {
        const i2 = r2.length, s2 = this.getChildrenSize(), o2 = this.getWritable();
        e2 + n2 <= s2 || t(226, String(e2), String(n2), String(s2));
        const l2 = o2.__key, c2 = [], a2 = [], u2 = this.getChildAtIndex(e2 + n2);
        let f3 = null, d3 = s2 - n2 + i2;
        if (0 !== e2) if (e2 === s2) f3 = this.getLastChild();
        else {
          const t3 = this.getChildAtIndex(e2);
          null !== t3 && (f3 = t3.getPreviousSibling());
        }
        if (n2 > 0) {
          let e3 = null === f3 ? this.getFirstChild() : f3.getNextSibling();
          for (let r3 = 0; r3 < n2; r3++) {
            null === e3 && t(100);
            const n3 = e3.getNextSibling(), r4 = e3.__key;
            os(e3.getWritable()), a2.push(r4), e3 = n3;
          }
        }
        let h4 = f3;
        for (let e3 = 0; e3 < i2; e3++) {
          const n3 = r2[e3];
          null !== h4 && n3.is(h4) && (f3 = h4 = h4.getPreviousSibling());
          const i3 = n3.getWritable();
          i3.__parent === l2 && d3--, os(i3);
          const s3 = n3.__key;
          if (null === h4) o2.__first = s3, i3.__prev = null;
          else {
            const t3 = h4.getWritable();
            t3.__next = s3, i3.__prev = t3.__key;
          }
          n3.__key === l2 && t(76), i3.__parent = l2, c2.push(s3), h4 = n3;
        }
        if (e2 + n2 === s2) {
          if (null !== h4) {
            h4.getWritable().__next = null, o2.__last = h4.__key;
          }
        } else if (null !== u2) {
          const t3 = u2.getWritable();
          if (null !== h4) {
            const e3 = h4.getWritable();
            t3.__prev = h4.__key, e3.__next = u2.__key;
          } else t3.__prev = null;
        }
        if (o2.__size = d3, a2.length) {
          const t3 = Nr();
          if (cr(t3)) {
            const e3 = new Set(a2), n3 = new Set(c2), { anchor: r3, focus: i3 } = t3;
            hi(r3, e3, n3) && Ar(r3, r3.getNode(), this, f3, u2), hi(i3, e3, n3) && Ar(i3, i3.getNode(), this, f3, u2), 0 !== d3 || this.canBeEmpty() || to(this) || this.remove();
          }
        }
        return o2;
      }
      getDOMSlot(t3) {
        return new ai(t3);
      }
      exportDOM(t3) {
        const { element: e2 } = super.exportDOM(t3);
        if (fo(e2)) {
          const t4 = this.getIndent();
          t4 > 0 && (e2.style.paddingInlineStart = 40 * t4 + "px");
          const n2 = this.getDirection();
          n2 && (e2.dir = n2);
        }
        return { element: e2 };
      }
      exportJSON() {
        const t3 = { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), ...super.exportJSON() }, e2 = this.getTextFormat(), n2 = this.getTextStyle();
        return 0 !== e2 && (t3.textFormat = e2), "" !== n2 && (t3.textStyle = n2), t3;
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setFormat(t3.format).setIndent(t3.indent).setDirection(t3.direction).setTextFormat(t3.textFormat || 0).setTextStyle(t3.textStyle || "");
      }
      insertNewAfter(t3, e2) {
        return null;
      }
      canIndent() {
        return true;
      }
      collapseAtStart(t3) {
        return false;
      }
      excludeFromCopy(t3) {
        return false;
      }
      canReplaceWith(t3) {
        return true;
      }
      canInsertAfter(t3) {
        return true;
      }
      canBeEmpty() {
        return true;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      isInline() {
        return false;
      }
      isShadowRoot() {
        return false;
      }
      canMergeWith(t3) {
        return false;
      }
      extractWithChild(t3, e2, n2) {
        return false;
      }
      canMergeWhenEmpty() {
        return false;
      }
      reconcileObservedMutation(t3, e2) {
        const n2 = this.getDOMSlot(t3);
        let r2 = n2.getFirstChild();
        for (let t4 = this.getFirstChild(); t4; t4 = t4.getNextSibling()) {
          const i2 = e2.getElementByKey(t4.getKey());
          null !== i2 && (null == r2 ? (n2.insertChild(i2), r2 = i2) : r2 !== i2 && n2.replaceChild(i2, r2), r2 = r2.nextSibling);
        }
      }
    };
    gi = class extends An {
      decorate(e2, n2) {
        t(47);
      }
      isIsolated() {
        return false;
      }
      isInline() {
        return true;
      }
      isKeyboardSelectable() {
        return true;
      }
    };
    pi = class _pi extends fi {
      static getType() {
        return "root";
      }
      static clone() {
        return new _pi();
      }
      constructor() {
        super("root"), this.__cachedText = null;
      }
      getTopLevelElementOrThrow() {
        t(51);
      }
      getTextContent() {
        const t3 = this.__cachedText;
        return !jr() && qr()._dirtyType !== y || null === t3 ? super.getTextContent() : t3;
      }
      remove() {
        t(52);
      }
      replace(e2) {
        t(53);
      }
      insertBefore(e2) {
        t(54);
      }
      insertAfter(e2) {
        t(55);
      }
      updateDOM(t3, e2) {
        return false;
      }
      splice(e2, n2, r2) {
        for (const e3 of r2) di(e3) || _i(e3) || t(282);
        return super.splice(e2, n2, r2);
      }
      static importJSON(t3) {
        return ps().updateFromJSON(t3);
      }
      collapseAtStart() {
        return true;
      }
    };
    Si = class _Si {
      constructor(t3, e2) {
        this._nodeMap = t3, this._selection = e2 || null, this._flushSync = false, this._readOnly = false;
      }
      isEmpty() {
        return 1 === this._nodeMap.size && null === this._selection;
      }
      read(t3, e2) {
        return ri(e2 && e2.editor || null, this, t3);
      }
      clone(t3) {
        const e2 = new _Si(this._nodeMap, void 0 === t3 ? this._selection : t3);
        return e2._readOnly = true, e2;
      }
      toJSON() {
        return ri(null, this, () => ({ root: Ci(ps()) }));
      }
    };
    vi = "historic";
    ki = "history-push";
    Ti = "history-merge";
    bi = "paste";
    Ni = "collaboration";
    wi = "skip-collab";
    Ei = "skip-scroll-into-view";
    Mi = "skip-dom-selection";
    Ai = class extends fi {
      static getType() {
        return "artificial";
      }
      createDOM(t3) {
        return document.createElement("div");
      }
    };
    Oi = class _Oi extends fi {
      static getType() {
        return "paragraph";
      }
      static clone(t3) {
        return new _Oi(t3.__key);
      }
      createDOM(t3) {
        const e2 = document.createElement("p"), n2 = Ls(t3.theme, "paragraph");
        if (void 0 !== n2) {
          e2.classList.add(...n2);
        }
        return e2;
      }
      updateDOM(t3, e2, n2) {
        return false;
      }
      static importDOM() {
        return { p: (t3) => ({ conversion: Di, priority: 0 }) };
      }
      exportDOM(t3) {
        const { element: e2 } = super.exportDOM(t3);
        if (fo(e2)) {
          this.isEmpty() && e2.append(document.createElement("br"));
          const t4 = this.getFormatType();
          t4 && (e2.style.textAlign = t4);
        }
        return { element: e2 };
      }
      static importJSON(t3) {
        return Pi().updateFromJSON(t3);
      }
      exportJSON() {
        return { ...super.exportJSON(), textFormat: this.getTextFormat(), textStyle: this.getTextStyle() };
      }
      insertNewAfter(t3, e2) {
        const n2 = Pi();
        n2.setTextFormat(t3.format), n2.setTextStyle(t3.style);
        const r2 = this.getDirection();
        return n2.setDirection(r2), n2.setFormat(this.getFormatType()), n2.setStyle(this.getStyle()), this.insertAfter(n2, e2), n2;
      }
      collapseAtStart() {
        const t3 = this.getChildren();
        if (0 === t3.length || Qn(t3[0]) && "" === t3[0].getTextContent().trim()) {
          if (null !== this.getNextSibling()) return this.selectNext(), this.remove(), true;
          if (null !== this.getPreviousSibling()) return this.selectPrevious(), this.remove(), true;
        }
        return false;
      }
    };
    Li = 0;
    Ii = 1;
    zi = 2;
    Ki = 3;
    Bi = 4;
    Ji = class {
      constructor(t3, e2, n2, r2, i2, s2, o2, l2) {
        this._createEditorArgs = l2, this._parentEditor = e2, this._rootElement = null, this._editorState = t3, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = false, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = r2, this._nodes = n2, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = y, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = ks(), this._onError = i2, this._htmlConversions = s2, this._editable = o2, this._headless = null !== e2 && e2._headless, this._window = null, this._blockCursorElement = null;
      }
      isComposing() {
        return null != this._compositionKey;
      }
      registerUpdateListener(t3) {
        const e2 = this._listeners.update;
        return e2.add(t3), () => {
          e2.delete(t3);
        };
      }
      registerEditableListener(t3) {
        const e2 = this._listeners.editable;
        return e2.add(t3), () => {
          e2.delete(t3);
        };
      }
      registerDecoratorListener(t3) {
        const e2 = this._listeners.decorator;
        return e2.add(t3), () => {
          e2.delete(t3);
        };
      }
      registerTextContentListener(t3) {
        const e2 = this._listeners.textcontent;
        return e2.add(t3), () => {
          e2.delete(t3);
        };
      }
      registerRootListener(t3) {
        const e2 = this._listeners.root;
        return t3(this._rootElement, null), e2.add(t3), () => {
          t3(null, this._rootElement), e2.delete(t3);
        };
      }
      registerCommand(e2, n2, r2) {
        void 0 === r2 && t(35);
        const i2 = this._commands;
        i2.has(e2) || i2.set(e2, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
        const s2 = i2.get(e2);
        void 0 === s2 && t(36, String(e2));
        const o2 = s2[r2];
        return o2.add(n2), () => {
          o2.delete(n2), s2.every((t3) => 0 === t3.size) && i2.delete(e2);
        };
      }
      registerMutationListener(t3, e2, n2) {
        const r2 = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(t3)).klass, i2 = this._listeners.mutation;
        i2.set(e2, r2);
        const s2 = n2 && n2.skipInitialization;
        return void 0 !== s2 && s2 || this.initializeMutationListener(e2, r2), () => {
          i2.delete(e2);
        };
      }
      getRegisteredNode(e2) {
        const n2 = this._nodes.get(e2.getType());
        return void 0 === n2 && t(37, e2.name), n2;
      }
      resolveRegisteredNodeAfterReplacements(t3) {
        for (; t3.replaceWithKlass; ) t3 = this.getRegisteredNode(t3.replaceWithKlass);
        return t3;
      }
      initializeMutationListener(t3, e2) {
        const n2 = this._editorState, r2 = vo(n2).get(e2.getType());
        if (!r2) return;
        const i2 = /* @__PURE__ */ new Map();
        for (const t4 of r2.keys()) i2.set(t4, "created");
        i2.size > 0 && t3(i2, { dirtyLeaves: /* @__PURE__ */ new Set(), prevEditorState: n2, updateTags: /* @__PURE__ */ new Set(["registerMutationListener"]) });
      }
      registerNodeTransformToKlass(t3, e2) {
        const n2 = this.getRegisteredNode(t3);
        return n2.transforms.add(e2), n2;
      }
      registerNodeTransform(t3, e2) {
        const n2 = this.registerNodeTransformToKlass(t3, e2), r2 = [n2], i2 = n2.replaceWithKlass;
        if (null != i2) {
          const t4 = this.registerNodeTransformToKlass(i2, e2);
          r2.push(t4);
        }
        return function(t4, e3) {
          const n3 = vo(t4.getEditorState()), r3 = [];
          for (const t5 of e3) {
            const e4 = n3.get(t5);
            e4 && r3.push(e4);
          }
          if (0 === r3.length) return;
          t4.update(() => {
            for (const t5 of r3) for (const e4 of t5.keys()) {
              const t6 = us(e4);
              t6 && t6.markDirty();
            }
          }, null === t4._pendingEditorState ? { tag: Ti } : void 0);
        }(this, r2.map((t4) => t4.klass.getType())), () => {
          r2.forEach((t4) => t4.transforms.delete(e2));
        };
      }
      hasNode(t3) {
        return this._nodes.has(t3.getType());
      }
      hasNodes(t3) {
        return t3.every(this.hasNode.bind(this));
      }
      dispatchCommand(t3, e2) {
        return Ws(this, t3, e2);
      }
      getDecorators() {
        return this._decorators;
      }
      getRootElement() {
        return this._rootElement;
      }
      getKey() {
        return this._key;
      }
      setRootElement(t3) {
        const e2 = this._rootElement;
        if (t3 !== e2) {
          const n2 = Ls(this._config.theme, "root"), r2 = this._pendingEditorState || this._editorState;
          if (this._rootElement = t3, Ri(this, e2, t3, r2), null !== e2 && (this._config.disableEvents || En(e2), null != n2 && e2.classList.remove(...n2)), null !== t3) {
            const e3 = Gs(t3), r3 = t3.style;
            r3.userSelect = "text", r3.whiteSpace = "pre-wrap", r3.wordBreak = "break-word", t3.setAttribute("data-lexical-editor", "true"), this._window = e3, this._dirtyType = x, at(this), this._updateTags.add(Ti), ii(this), this._config.disableEvents || function(t4, e4) {
              const n3 = t4.ownerDocument, r4 = on.get(n3);
              (void 0 === r4 || r4 < 1) && n3.addEventListener("selectionchange", Tn), on.set(n3, (r4 || 0) + 1), t4.__lexicalEditor = e4;
              const i2 = vn(t4);
              for (let n4 = 0; n4 < tn.length; n4++) {
                const [r5, s2] = tn[n4], o2 = "function" == typeof s2 ? (t5) => {
                  Nn(t5) || (bn(t5), (e4.isEditable() || "click" === r5) && s2(t5, e4));
                } : (t5) => {
                  if (Nn(t5)) return;
                  bn(t5);
                  const n5 = e4.isEditable();
                  switch (r5) {
                    case "cut":
                      return n5 && Ws(e4, Ue, t5);
                    case "copy":
                      return Ws(e4, Je, t5);
                    case "paste":
                      return n5 && Ws(e4, ge, t5);
                    case "dragstart":
                      return n5 && Ws(e4, Be, t5);
                    case "dragover":
                      return n5 && Ws(e4, Re, t5);
                    case "dragend":
                      return n5 && Ws(e4, We, t5);
                    case "focus":
                      return n5 && Ws(e4, qe, t5);
                    case "blur":
                      return n5 && Ws(e4, Ge, t5);
                    case "drop":
                      return n5 && Ws(e4, ze, t5);
                  }
                };
                t4.addEventListener(r5, o2), i2.push(() => {
                  t4.removeEventListener(r5, o2);
                });
              }
            }(t3, this), null != n2 && t3.classList.add(...n2);
          } else this._window = null, this._updateTags.add(Ti), ii(this);
          si("root", this, false, t3, e2);
        }
      }
      getElementByKey(t3) {
        return this._keyToDOMMap.get(t3) || null;
      }
      getEditorState() {
        return this._editorState;
      }
      setEditorState(e2, n2) {
        e2.isEmpty() && t(38);
        let r2 = e2;
        r2._readOnly && (r2 = mi(e2), r2._selection = e2._selection ? e2._selection.clone() : null), ct(this);
        const i2 = this._pendingEditorState, s2 = this._updateTags, o2 = void 0 !== n2 ? n2.tag : null;
        null === i2 || i2.isEmpty() || (null != o2 && s2.add(o2), ii(this)), this._pendingEditorState = r2, this._dirtyType = x, this._dirtyElements.set("root", false), this._compositionKey = null, null != o2 && s2.add(o2), this._updating || ii(this);
      }
      parseEditorState(t3, e2) {
        return function(t4, e3, n2) {
          const r2 = xi(), i2 = Br, s2 = Wr, o2 = Rr, l2 = e3._dirtyElements, c2 = e3._dirtyLeaves, a2 = e3._cloneNotNeeded, u2 = e3._dirtyType;
          e3._dirtyElements = /* @__PURE__ */ new Map(), e3._dirtyLeaves = /* @__PURE__ */ new Set(), e3._cloneNotNeeded = /* @__PURE__ */ new Set(), e3._dirtyType = 0, Br = r2, Wr = false, Rr = e3;
          try {
            const i3 = e3._nodes;
            ni(t4.root, i3), n2 && n2(), r2._readOnly = true;
          } catch (t5) {
            t5 instanceof Error && e3._onError(t5);
          } finally {
            e3._dirtyElements = l2, e3._dirtyLeaves = c2, e3._cloneNotNeeded = a2, e3._dirtyType = u2, Br = i2, Wr = s2, Rr = o2;
          }
          return r2;
        }("string" == typeof t3 ? JSON.parse(t3) : t3, this, e2);
      }
      read(t3) {
        return ii(this), this.getEditorState().read(t3, { editor: this });
      }
      update(t3, e2) {
        !function(t4, e3, n2) {
          t4._updating ? t4._updates.push([e3, n2]) : li(t4, e3, n2);
        }(this, t3, e2);
      }
      focus(t3, e2 = {}) {
        const n2 = this._rootElement;
        null !== n2 && (n2.setAttribute("autocapitalize", "off"), ci(this, () => {
          const r2 = Nr(), i2 = ps();
          null !== r2 ? r2.dirty || ms(r2.clone()) : 0 !== i2.getChildrenSize() && ("rootStart" === e2.defaultSelection ? i2.selectStart() : i2.selectEnd()), Ys("focus"), Hs(() => {
            n2.removeAttribute("autocapitalize"), t3 && t3();
          });
        }), null === this._pendingEditorState && n2.removeAttribute("autocapitalize"));
      }
      blur() {
        const t3 = this._rootElement;
        null !== t3 && t3.blur();
        const e2 = lo(this._window);
        null !== e2 && e2.removeAllRanges();
      }
      isEditable() {
        return this._editable;
      }
      setEditable(t3) {
        this._editable !== t3 && (this._editable = t3, si("editable", this, true, t3));
      }
      toJSON() {
        return { editorState: this._editorState.toJSON() };
      }
    };
    Ji.version = "0.32.1+prod.esm";
    Ui = 1;
    ji = "function" == typeof queueMicrotask ? queueMicrotask : (t3) => {
      Promise.resolve().then(t3);
    };
    As = { ctrlKey: !r, metaKey: r };
    Os = { altKey: r, ctrlKey: !r };
    Co = /* @__PURE__ */ new WeakMap();
    So = /* @__PURE__ */ new Map();
    wo = { next: "previous", previous: "next" };
    Eo = class {
      constructor(t3) {
        this.origin = t3;
      }
      [Symbol.iterator]() {
        return el({ hasNext: zo, initial: this.getAdjacentCaret(), map: (t3) => t3, step: (t3) => t3.getAdjacentCaret() });
      }
      getAdjacentCaret() {
        return Jo(this.getNodeAtCaret(), this.direction);
      }
      getSiblingCaret() {
        return Jo(this.origin, this.direction);
      }
      remove() {
        const t3 = this.getNodeAtCaret();
        return t3 && t3.remove(), this;
      }
      replaceOrInsert(t3, e2) {
        const n2 = this.getNodeAtCaret();
        return t3.is(this.origin) || t3.is(n2) || (null === n2 ? this.insert(t3) : n2.replace(t3, e2)), this;
      }
      splice(e2, n2, r2 = "next") {
        const i2 = r2 === this.direction ? n2 : Array.from(n2).reverse();
        let s2 = this;
        const o2 = this.getParentAtCaret(), l2 = /* @__PURE__ */ new Map();
        for (let t3 = s2.getAdjacentCaret(); null !== t3 && l2.size < e2; t3 = t3.getAdjacentCaret()) {
          const e3 = t3.origin.getWritable();
          l2.set(e3.getKey(), e3);
        }
        for (const e3 of i2) {
          if (l2.size > 0) {
            const n3 = s2.getNodeAtCaret();
            if (n3) if (l2.delete(n3.getKey()), l2.delete(e3.getKey()), n3.is(e3) || s2.origin.is(e3)) ;
            else {
              const t3 = e3.getParent();
              t3 && t3.is(o2) && e3.remove(), n3.replace(e3);
            }
            else null === n3 && t(263, Array.from(l2).join(" "));
          } else s2.insert(e3);
          s2 = Jo(e3, this.direction);
        }
        for (const t3 of l2.values()) t3.remove();
        return this;
      }
    };
    Mo = class _Mo extends Eo {
      type = "child";
      getLatest() {
        const t3 = this.origin.getLatest();
        return t3 === this.origin ? this : Vo(t3, this.direction);
      }
      getParentCaret(t3 = "root") {
        return Jo(Do(this.getParentAtCaret(), t3), this.direction);
      }
      getFlipped() {
        const t3 = Oo(this.direction);
        return Jo(this.getNodeAtCaret(), t3) || Vo(this.origin, t3);
      }
      getParentAtCaret() {
        return this.origin;
      }
      getChildCaret() {
        return this;
      }
      isSameNodeCaret(t3) {
        return t3 instanceof _Mo && this.direction === t3.direction && this.origin.is(t3.origin);
      }
      isSamePointCaret(t3) {
        return this.isSameNodeCaret(t3);
      }
    };
    Ao = { root: yi, shadowRoot: to };
    Po = class _Po extends Eo {
      type = "sibling";
      getLatest() {
        const t3 = this.origin.getLatest();
        return t3 === this.origin ? this : Jo(t3, this.direction);
      }
      getSiblingCaret() {
        return this;
      }
      getParentAtCaret() {
        return this.origin.getParent();
      }
      getChildCaret() {
        return di(this.origin) ? Vo(this.origin, this.direction) : null;
      }
      getParentCaret(t3 = "root") {
        return Jo(Do(this.getParentAtCaret(), t3), this.direction);
      }
      getFlipped() {
        const t3 = Oo(this.direction);
        return Jo(this.getNodeAtCaret(), t3) || Vo(this.origin.getParentOrThrow(), t3);
      }
      isSamePointCaret(t3) {
        return t3 instanceof _Po && this.direction === t3.direction && this.origin.is(t3.origin);
      }
      isSameNodeCaret(t3) {
        return (t3 instanceof _Po || t3 instanceof Fo) && this.direction === t3.direction && this.origin.is(t3.origin);
      }
    };
    Fo = class _Fo extends Eo {
      type = "text";
      constructor(t3, e2) {
        super(t3), this.offset = e2;
      }
      getLatest() {
        const t3 = this.origin.getLatest();
        return t3 === this.origin ? this : Uo(t3, this.direction, this.offset);
      }
      getParentAtCaret() {
        return this.origin.getParent();
      }
      getChildCaret() {
        return null;
      }
      getParentCaret(t3 = "root") {
        return Jo(Do(this.getParentAtCaret(), t3), this.direction);
      }
      getFlipped() {
        return Uo(this.origin, Oo(this.direction), this.offset);
      }
      isSamePointCaret(t3) {
        return t3 instanceof _Fo && this.direction === t3.direction && this.origin.is(t3.origin) && this.offset === t3.offset;
      }
      isSameNodeCaret(t3) {
        return (t3 instanceof Po || t3 instanceof _Fo) && this.direction === t3.direction && this.origin.is(t3.origin);
      }
      getSiblingCaret() {
        return Jo(this.origin, this.direction);
      }
    };
    Bo = { next: class extends Fo {
      direction = "next";
      getNodeAtCaret() {
        return this.origin.getNextSibling();
      }
      insert(t3) {
        return this.origin.insertAfter(t3), this;
      }
    }, previous: class extends Fo {
      direction = "previous";
      getNodeAtCaret() {
        return this.origin.getPreviousSibling();
      }
      insert(t3) {
        return this.origin.insertBefore(t3), this;
      }
    } };
    Ro = { next: class extends Po {
      direction = "next";
      getNodeAtCaret() {
        return this.origin.getNextSibling();
      }
      insert(t3) {
        return this.origin.insertAfter(t3), this;
      }
    }, previous: class extends Po {
      direction = "previous";
      getNodeAtCaret() {
        return this.origin.getPreviousSibling();
      }
      insert(t3) {
        return this.origin.insertBefore(t3), this;
      }
    } };
    Wo = { next: class extends Mo {
      direction = "next";
      getNodeAtCaret() {
        return this.origin.getFirstChild();
      }
      insert(t3) {
        return this.origin.splice(0, 0, [t3]), this;
      }
    }, previous: class extends Mo {
      direction = "previous";
      getNodeAtCaret() {
        return this.origin.getLastChild();
      }
      insert(t3) {
        return this.origin.splice(this.origin.getChildrenSize(), 0, [t3]), this;
      }
    } };
    qo = class _qo {
      type = "node-caret-range";
      constructor(t3, e2, n2) {
        this.anchor = t3, this.focus = e2, this.direction = n2;
      }
      getLatest() {
        const t3 = this.anchor.getLatest(), e2 = this.focus.getLatest();
        return t3 === this.anchor && e2 === this.focus ? this : new _qo(t3, e2, this.direction);
      }
      isCollapsed() {
        return this.anchor.isSamePointCaret(this.focus);
      }
      getTextSlices() {
        const t3 = (t4) => {
          const e3 = this[t4].getLatest();
          return Lo(e3) ? function(t5, e4) {
            const { direction: n3, origin: r2 } = t5, i2 = $o(r2, "focus" === e4 ? Oo(n3) : n3);
            return jo(t5, i2 - t5.offset);
          }(e3, t4) : null;
        }, e2 = t3("anchor"), n2 = t3("focus");
        if (e2 && n2) {
          const { caret: t4 } = e2, { caret: r2 } = n2;
          if (t4.isSameNodeCaret(r2)) return [jo(t4, r2.offset - t4.offset), null];
        }
        return [e2, n2];
      }
      iterNodeCarets(t3 = "root") {
        const e2 = Lo(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest(), n2 = this.focus.getLatest(), r2 = Lo(n2), i2 = (e3) => e3.isSameNodeCaret(n2) ? null : Ho(e3) || e3.getParentCaret(t3);
        return el({ hasNext: (t4) => null !== t4 && !(r2 && n2.isSameNodeCaret(t4)), initial: e2.isSameNodeCaret(n2) ? null : i2(e2), map: (t4) => t4, step: i2 });
      }
      [Symbol.iterator]() {
        return this.iterNodeCarets("root");
      }
    };
    Go = class {
      type = "slice";
      constructor(t3, e2) {
        this.caret = t3, this.distance = e2;
      }
      getSliceIndices() {
        const { distance: t3, caret: { offset: e2 } } = this, n2 = e2 + t3;
        return n2 < e2 ? [n2, e2] : [e2, n2];
      }
      getTextContent() {
        const [t3, e2] = this.getSliceIndices();
        return this.caret.origin.getTextContent().slice(t3, e2);
      }
      getTextContentSize() {
        return Math.abs(this.distance);
      }
      removeTextSlice() {
        const { caret: { origin: t3, direction: e2 } } = this, [n2, r2] = this.getSliceIndices(), i2 = t3.getTextContent();
        return Uo(t3.setTextContent(i2.slice(0, n2) + i2.slice(r2)), e2, n2);
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/lexical@0.32.1/node_modules/lexical/Lexical.node.mjs
var mod, $addUpdateTag2, $applyNodeReplacement2, $caretFromPoint2, $caretRangeFromSelection2, $cloneWithProperties2, $comparePointCaretNext2, $copyNode2, $createLineBreakNode2, $createNodeSelection2, $createParagraphNode2, $createPoint2, $createRangeSelection2, $createRangeSelectionFromDom2, $createTabNode2, $createTextNode2, $extendCaretToRange2, $getAdjacentChildCaret2, $getAdjacentNode2, $getAdjacentSiblingOrParentSiblingCaret2, $getCaretInDirection2, $getCaretRange2, $getCaretRangeInDirection2, $getCharacterOffsets2, $getChildCaret2, $getChildCaretAtIndex2, $getChildCaretOrSelf2, $getCollapsedCaretRange2, $getCommonAncestor2, $getCommonAncestorResultBranchOrder2, $getEditor2, $getNearestNodeFromDOMNode2, $getNearestRootOrShadowRoot2, $getNodeByKey2, $getNodeByKeyOrThrow2, $getPreviousSelection2, $getRoot2, $getSelection2, $getSiblingCaret2, $getState2, $getStateChange2, $getTextContent2, $getTextNodeOffset2, $getTextPointCaret2, $getTextPointCaretSlice2, $getWritableNodeState2, $hasAncestor2, $hasUpdateTag2, $insertNodes2, $isBlockElementNode2, $isChildCaret2, $isDecoratorNode2, $isElementNode2, $isExtendableTextPointCaret2, $isInlineElementOrDecoratorNode2, $isLeafNode2, $isLineBreakNode2, $isNodeCaret2, $isNodeSelection2, $isParagraphNode2, $isRangeSelection2, $isRootNode2, $isRootOrShadowRoot2, $isSiblingCaret2, $isTabNode2, $isTextNode2, $isTextPointCaret2, $isTextPointCaretSlice2, $isTokenOrSegmented2, $isTokenOrTab2, $nodesOfType2, $normalizeCaret2, $normalizeSelection__EXPERIMENTAL, $onUpdate2, $parseSerializedNode2, $removeTextFromCaretRange2, $rewindSiblingCaret2, $selectAll2, $setCompositionKey2, $setPointFromCaret2, $setSelection2, $setSelectionFromCaretRange2, $setState2, $splitAtPointCaretNext2, $splitNode2, $updateRangeSelectionFromCaretRange2, ArtificialNode__DO_NOT_USE2, BLUR_COMMAND2, CAN_REDO_COMMAND2, CAN_UNDO_COMMAND2, CLEAR_EDITOR_COMMAND2, CLEAR_HISTORY_COMMAND2, CLICK_COMMAND2, COLLABORATION_TAG2, COMMAND_PRIORITY_CRITICAL2, COMMAND_PRIORITY_EDITOR2, COMMAND_PRIORITY_HIGH2, COMMAND_PRIORITY_LOW2, COMMAND_PRIORITY_NORMAL2, CONTROLLED_TEXT_INSERTION_COMMAND2, COPY_COMMAND2, CUT_COMMAND2, DELETE_CHARACTER_COMMAND2, DELETE_LINE_COMMAND2, DELETE_WORD_COMMAND2, DRAGEND_COMMAND2, DRAGOVER_COMMAND2, DRAGSTART_COMMAND2, DROP_COMMAND2, DecoratorNode2, ElementNode2, FOCUS_COMMAND2, FORMAT_ELEMENT_COMMAND2, FORMAT_TEXT_COMMAND2, HISTORIC_TAG2, HISTORY_MERGE_TAG2, HISTORY_PUSH_TAG2, INDENT_CONTENT_COMMAND2, INSERT_LINE_BREAK_COMMAND2, INSERT_PARAGRAPH_COMMAND2, INSERT_TAB_COMMAND2, INTERNAL_$isBlock2, IS_ALL_FORMATTING2, IS_BOLD2, IS_CODE2, IS_HIGHLIGHT2, IS_ITALIC2, IS_STRIKETHROUGH2, IS_SUBSCRIPT2, IS_SUPERSCRIPT2, IS_UNDERLINE2, KEY_ARROW_DOWN_COMMAND2, KEY_ARROW_LEFT_COMMAND2, KEY_ARROW_RIGHT_COMMAND2, KEY_ARROW_UP_COMMAND2, KEY_BACKSPACE_COMMAND2, KEY_DELETE_COMMAND2, KEY_DOWN_COMMAND2, KEY_ENTER_COMMAND2, KEY_ESCAPE_COMMAND2, KEY_MODIFIER_COMMAND2, KEY_SPACE_COMMAND2, KEY_TAB_COMMAND2, LineBreakNode2, MOVE_TO_END2, MOVE_TO_START2, NODE_STATE_KEY2, OUTDENT_CONTENT_COMMAND2, PASTE_COMMAND2, PASTE_TAG2, ParagraphNode2, REDO_COMMAND2, REMOVE_TEXT_COMMAND2, RootNode2, SELECTION_CHANGE_COMMAND2, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, SELECT_ALL_COMMAND2, SKIP_COLLAB_TAG2, SKIP_DOM_SELECTION_TAG2, SKIP_SCROLL_INTO_VIEW_TAG2, TEXT_TYPE_TO_FORMAT2, TabNode2, TextNode2, UNDO_COMMAND2, createCommand2, createEditor2, createState2, flipDirection2, getDOMOwnerDocument2, getDOMSelection2, getDOMSelectionFromTarget2, getDOMTextNode2, getEditorPropertyFromDOMNode2, getNearestEditorFromDOMNode2, isBlockDomNode2, isCurrentlyReadOnlyMode2, isDOMDocumentNode2, isDOMNode2, isDOMTextNode2, isDOMUnmanaged2, isDocumentFragment2, isExactShortcutMatch2, isHTMLAnchorElement2, isHTMLElement2, isInlineDomNode2, isLexicalEditor2, isModifierMatch2, isSelectionCapturedInDecoratorInput2, isSelectionWithinEditor2, makeStepwiseIterator2, removeFromParent2, resetRandomKey2, setDOMUnmanaged2, setNodeIndentFromDOM2;
var init_Lexical_node = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/lexical@0.32.1/node_modules/lexical/Lexical.node.mjs"() {
    mod = await (process.env.NODE_ENV !== "production" ? Promise.resolve().then(() => (init_Lexical_dev(), Lexical_dev_exports)) : Promise.resolve().then(() => (init_Lexical_prod(), Lexical_prod_exports)));
    $addUpdateTag2 = mod.$addUpdateTag;
    $applyNodeReplacement2 = mod.$applyNodeReplacement;
    $caretFromPoint2 = mod.$caretFromPoint;
    $caretRangeFromSelection2 = mod.$caretRangeFromSelection;
    $cloneWithProperties2 = mod.$cloneWithProperties;
    $comparePointCaretNext2 = mod.$comparePointCaretNext;
    $copyNode2 = mod.$copyNode;
    $createLineBreakNode2 = mod.$createLineBreakNode;
    $createNodeSelection2 = mod.$createNodeSelection;
    $createParagraphNode2 = mod.$createParagraphNode;
    $createPoint2 = mod.$createPoint;
    $createRangeSelection2 = mod.$createRangeSelection;
    $createRangeSelectionFromDom2 = mod.$createRangeSelectionFromDom;
    $createTabNode2 = mod.$createTabNode;
    $createTextNode2 = mod.$createTextNode;
    $extendCaretToRange2 = mod.$extendCaretToRange;
    $getAdjacentChildCaret2 = mod.$getAdjacentChildCaret;
    $getAdjacentNode2 = mod.$getAdjacentNode;
    $getAdjacentSiblingOrParentSiblingCaret2 = mod.$getAdjacentSiblingOrParentSiblingCaret;
    $getCaretInDirection2 = mod.$getCaretInDirection;
    $getCaretRange2 = mod.$getCaretRange;
    $getCaretRangeInDirection2 = mod.$getCaretRangeInDirection;
    $getCharacterOffsets2 = mod.$getCharacterOffsets;
    $getChildCaret2 = mod.$getChildCaret;
    $getChildCaretAtIndex2 = mod.$getChildCaretAtIndex;
    $getChildCaretOrSelf2 = mod.$getChildCaretOrSelf;
    $getCollapsedCaretRange2 = mod.$getCollapsedCaretRange;
    $getCommonAncestor2 = mod.$getCommonAncestor;
    $getCommonAncestorResultBranchOrder2 = mod.$getCommonAncestorResultBranchOrder;
    $getEditor2 = mod.$getEditor;
    $getNearestNodeFromDOMNode2 = mod.$getNearestNodeFromDOMNode;
    $getNearestRootOrShadowRoot2 = mod.$getNearestRootOrShadowRoot;
    $getNodeByKey2 = mod.$getNodeByKey;
    $getNodeByKeyOrThrow2 = mod.$getNodeByKeyOrThrow;
    $getPreviousSelection2 = mod.$getPreviousSelection;
    $getRoot2 = mod.$getRoot;
    $getSelection2 = mod.$getSelection;
    $getSiblingCaret2 = mod.$getSiblingCaret;
    $getState2 = mod.$getState;
    $getStateChange2 = mod.$getStateChange;
    $getTextContent2 = mod.$getTextContent;
    $getTextNodeOffset2 = mod.$getTextNodeOffset;
    $getTextPointCaret2 = mod.$getTextPointCaret;
    $getTextPointCaretSlice2 = mod.$getTextPointCaretSlice;
    $getWritableNodeState2 = mod.$getWritableNodeState;
    $hasAncestor2 = mod.$hasAncestor;
    $hasUpdateTag2 = mod.$hasUpdateTag;
    $insertNodes2 = mod.$insertNodes;
    $isBlockElementNode2 = mod.$isBlockElementNode;
    $isChildCaret2 = mod.$isChildCaret;
    $isDecoratorNode2 = mod.$isDecoratorNode;
    $isElementNode2 = mod.$isElementNode;
    $isExtendableTextPointCaret2 = mod.$isExtendableTextPointCaret;
    $isInlineElementOrDecoratorNode2 = mod.$isInlineElementOrDecoratorNode;
    $isLeafNode2 = mod.$isLeafNode;
    $isLineBreakNode2 = mod.$isLineBreakNode;
    $isNodeCaret2 = mod.$isNodeCaret;
    $isNodeSelection2 = mod.$isNodeSelection;
    $isParagraphNode2 = mod.$isParagraphNode;
    $isRangeSelection2 = mod.$isRangeSelection;
    $isRootNode2 = mod.$isRootNode;
    $isRootOrShadowRoot2 = mod.$isRootOrShadowRoot;
    $isSiblingCaret2 = mod.$isSiblingCaret;
    $isTabNode2 = mod.$isTabNode;
    $isTextNode2 = mod.$isTextNode;
    $isTextPointCaret2 = mod.$isTextPointCaret;
    $isTextPointCaretSlice2 = mod.$isTextPointCaretSlice;
    $isTokenOrSegmented2 = mod.$isTokenOrSegmented;
    $isTokenOrTab2 = mod.$isTokenOrTab;
    $nodesOfType2 = mod.$nodesOfType;
    $normalizeCaret2 = mod.$normalizeCaret;
    $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;
    $onUpdate2 = mod.$onUpdate;
    $parseSerializedNode2 = mod.$parseSerializedNode;
    $removeTextFromCaretRange2 = mod.$removeTextFromCaretRange;
    $rewindSiblingCaret2 = mod.$rewindSiblingCaret;
    $selectAll2 = mod.$selectAll;
    $setCompositionKey2 = mod.$setCompositionKey;
    $setPointFromCaret2 = mod.$setPointFromCaret;
    $setSelection2 = mod.$setSelection;
    $setSelectionFromCaretRange2 = mod.$setSelectionFromCaretRange;
    $setState2 = mod.$setState;
    $splitAtPointCaretNext2 = mod.$splitAtPointCaretNext;
    $splitNode2 = mod.$splitNode;
    $updateRangeSelectionFromCaretRange2 = mod.$updateRangeSelectionFromCaretRange;
    ArtificialNode__DO_NOT_USE2 = mod.ArtificialNode__DO_NOT_USE;
    BLUR_COMMAND2 = mod.BLUR_COMMAND;
    CAN_REDO_COMMAND2 = mod.CAN_REDO_COMMAND;
    CAN_UNDO_COMMAND2 = mod.CAN_UNDO_COMMAND;
    CLEAR_EDITOR_COMMAND2 = mod.CLEAR_EDITOR_COMMAND;
    CLEAR_HISTORY_COMMAND2 = mod.CLEAR_HISTORY_COMMAND;
    CLICK_COMMAND2 = mod.CLICK_COMMAND;
    COLLABORATION_TAG2 = mod.COLLABORATION_TAG;
    COMMAND_PRIORITY_CRITICAL2 = mod.COMMAND_PRIORITY_CRITICAL;
    COMMAND_PRIORITY_EDITOR2 = mod.COMMAND_PRIORITY_EDITOR;
    COMMAND_PRIORITY_HIGH2 = mod.COMMAND_PRIORITY_HIGH;
    COMMAND_PRIORITY_LOW2 = mod.COMMAND_PRIORITY_LOW;
    COMMAND_PRIORITY_NORMAL2 = mod.COMMAND_PRIORITY_NORMAL;
    CONTROLLED_TEXT_INSERTION_COMMAND2 = mod.CONTROLLED_TEXT_INSERTION_COMMAND;
    COPY_COMMAND2 = mod.COPY_COMMAND;
    CUT_COMMAND2 = mod.CUT_COMMAND;
    DELETE_CHARACTER_COMMAND2 = mod.DELETE_CHARACTER_COMMAND;
    DELETE_LINE_COMMAND2 = mod.DELETE_LINE_COMMAND;
    DELETE_WORD_COMMAND2 = mod.DELETE_WORD_COMMAND;
    DRAGEND_COMMAND2 = mod.DRAGEND_COMMAND;
    DRAGOVER_COMMAND2 = mod.DRAGOVER_COMMAND;
    DRAGSTART_COMMAND2 = mod.DRAGSTART_COMMAND;
    DROP_COMMAND2 = mod.DROP_COMMAND;
    DecoratorNode2 = mod.DecoratorNode;
    ElementNode2 = mod.ElementNode;
    FOCUS_COMMAND2 = mod.FOCUS_COMMAND;
    FORMAT_ELEMENT_COMMAND2 = mod.FORMAT_ELEMENT_COMMAND;
    FORMAT_TEXT_COMMAND2 = mod.FORMAT_TEXT_COMMAND;
    HISTORIC_TAG2 = mod.HISTORIC_TAG;
    HISTORY_MERGE_TAG2 = mod.HISTORY_MERGE_TAG;
    HISTORY_PUSH_TAG2 = mod.HISTORY_PUSH_TAG;
    INDENT_CONTENT_COMMAND2 = mod.INDENT_CONTENT_COMMAND;
    INSERT_LINE_BREAK_COMMAND2 = mod.INSERT_LINE_BREAK_COMMAND;
    INSERT_PARAGRAPH_COMMAND2 = mod.INSERT_PARAGRAPH_COMMAND;
    INSERT_TAB_COMMAND2 = mod.INSERT_TAB_COMMAND;
    INTERNAL_$isBlock2 = mod.INTERNAL_$isBlock;
    IS_ALL_FORMATTING2 = mod.IS_ALL_FORMATTING;
    IS_BOLD2 = mod.IS_BOLD;
    IS_CODE2 = mod.IS_CODE;
    IS_HIGHLIGHT2 = mod.IS_HIGHLIGHT;
    IS_ITALIC2 = mod.IS_ITALIC;
    IS_STRIKETHROUGH2 = mod.IS_STRIKETHROUGH;
    IS_SUBSCRIPT2 = mod.IS_SUBSCRIPT;
    IS_SUPERSCRIPT2 = mod.IS_SUPERSCRIPT;
    IS_UNDERLINE2 = mod.IS_UNDERLINE;
    KEY_ARROW_DOWN_COMMAND2 = mod.KEY_ARROW_DOWN_COMMAND;
    KEY_ARROW_LEFT_COMMAND2 = mod.KEY_ARROW_LEFT_COMMAND;
    KEY_ARROW_RIGHT_COMMAND2 = mod.KEY_ARROW_RIGHT_COMMAND;
    KEY_ARROW_UP_COMMAND2 = mod.KEY_ARROW_UP_COMMAND;
    KEY_BACKSPACE_COMMAND2 = mod.KEY_BACKSPACE_COMMAND;
    KEY_DELETE_COMMAND2 = mod.KEY_DELETE_COMMAND;
    KEY_DOWN_COMMAND2 = mod.KEY_DOWN_COMMAND;
    KEY_ENTER_COMMAND2 = mod.KEY_ENTER_COMMAND;
    KEY_ESCAPE_COMMAND2 = mod.KEY_ESCAPE_COMMAND;
    KEY_MODIFIER_COMMAND2 = mod.KEY_MODIFIER_COMMAND;
    KEY_SPACE_COMMAND2 = mod.KEY_SPACE_COMMAND;
    KEY_TAB_COMMAND2 = mod.KEY_TAB_COMMAND;
    LineBreakNode2 = mod.LineBreakNode;
    MOVE_TO_END2 = mod.MOVE_TO_END;
    MOVE_TO_START2 = mod.MOVE_TO_START;
    NODE_STATE_KEY2 = mod.NODE_STATE_KEY;
    OUTDENT_CONTENT_COMMAND2 = mod.OUTDENT_CONTENT_COMMAND;
    PASTE_COMMAND2 = mod.PASTE_COMMAND;
    PASTE_TAG2 = mod.PASTE_TAG;
    ParagraphNode2 = mod.ParagraphNode;
    REDO_COMMAND2 = mod.REDO_COMMAND;
    REMOVE_TEXT_COMMAND2 = mod.REMOVE_TEXT_COMMAND;
    RootNode2 = mod.RootNode;
    SELECTION_CHANGE_COMMAND2 = mod.SELECTION_CHANGE_COMMAND;
    SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2 = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;
    SELECT_ALL_COMMAND2 = mod.SELECT_ALL_COMMAND;
    SKIP_COLLAB_TAG2 = mod.SKIP_COLLAB_TAG;
    SKIP_DOM_SELECTION_TAG2 = mod.SKIP_DOM_SELECTION_TAG;
    SKIP_SCROLL_INTO_VIEW_TAG2 = mod.SKIP_SCROLL_INTO_VIEW_TAG;
    TEXT_TYPE_TO_FORMAT2 = mod.TEXT_TYPE_TO_FORMAT;
    TabNode2 = mod.TabNode;
    TextNode2 = mod.TextNode;
    UNDO_COMMAND2 = mod.UNDO_COMMAND;
    createCommand2 = mod.createCommand;
    createEditor2 = mod.createEditor;
    createState2 = mod.createState;
    flipDirection2 = mod.flipDirection;
    getDOMOwnerDocument2 = mod.getDOMOwnerDocument;
    getDOMSelection2 = mod.getDOMSelection;
    getDOMSelectionFromTarget2 = mod.getDOMSelectionFromTarget;
    getDOMTextNode2 = mod.getDOMTextNode;
    getEditorPropertyFromDOMNode2 = mod.getEditorPropertyFromDOMNode;
    getNearestEditorFromDOMNode2 = mod.getNearestEditorFromDOMNode;
    isBlockDomNode2 = mod.isBlockDomNode;
    isCurrentlyReadOnlyMode2 = mod.isCurrentlyReadOnlyMode;
    isDOMDocumentNode2 = mod.isDOMDocumentNode;
    isDOMNode2 = mod.isDOMNode;
    isDOMTextNode2 = mod.isDOMTextNode;
    isDOMUnmanaged2 = mod.isDOMUnmanaged;
    isDocumentFragment2 = mod.isDocumentFragment;
    isExactShortcutMatch2 = mod.isExactShortcutMatch;
    isHTMLAnchorElement2 = mod.isHTMLAnchorElement;
    isHTMLElement2 = mod.isHTMLElement;
    isInlineDomNode2 = mod.isInlineDomNode;
    isLexicalEditor2 = mod.isLexicalEditor;
    isModifierMatch2 = mod.isModifierMatch;
    isSelectionCapturedInDecoratorInput2 = mod.isSelectionCapturedInDecoratorInput;
    isSelectionWithinEditor2 = mod.isSelectionWithinEditor;
    makeStepwiseIterator2 = mod.makeStepwiseIterator;
    removeFromParent2 = mod.removeFromParent;
    resetRandomKey2 = mod.resetRandomKey;
    setDOMUnmanaged2 = mod.setDOMUnmanaged;
    setNodeIndentFromDOM2 = mod.setNodeIndentFromDOM;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/selection@0.32.1/node_modules/@lexical/selection/LexicalSelection.dev.mjs
var LexicalSelection_dev_exports = {};
__export(LexicalSelection_dev_exports, {
  $addNodeStyle: () => $addNodeStyle,
  $cloneWithProperties: () => $cloneWithProperties2,
  $copyBlockFormatIndent: () => $copyBlockFormatIndent,
  $ensureForwardRangeSelection: () => $ensureForwardRangeSelection,
  $forEachSelectedTextNode: () => $forEachSelectedTextNode,
  $getSelectionStyleValueForProperty: () => $getSelectionStyleValueForProperty,
  $isAtNodeEnd: () => $isAtNodeEnd,
  $isParentElementRTL: () => $isParentElementRTL,
  $moveCaretSelection: () => $moveCaretSelection,
  $moveCharacter: () => $moveCharacter,
  $patchStyleText: () => $patchStyleText,
  $selectAll: () => $selectAll2,
  $setBlocksType: () => $setBlocksType,
  $shouldOverrideDefaultCharacterSelection: () => $shouldOverrideDefaultCharacterSelection,
  $sliceSelectedTextNodeContent: () => $sliceSelectedTextNodeContent,
  $trimTextContentFromAnchor: () => $trimTextContentFromAnchor,
  $wrapNodes: () => $wrapNodes,
  createDOMRange: () => createDOMRange,
  createRectsFromDOMRange: () => createRectsFromDOMRange,
  getCSSFromStyleObject: () => getCSSFromStyleObject,
  getStyleObjectFromCSS: () => getStyleObjectFromCSS,
  trimTextContentFromAnchor: () => trimTextContentFromAnchor
});
function formatDevErrorMessage2(message) {
  throw new Error(message);
}
function getDOMTextNode3(element) {
  let node = element;
  while (node != null) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function getDOMIndexWithinParent(node) {
  const parent = node.parentNode;
  if (parent == null) {
    throw new Error("Should never happen");
  }
  return [parent, Array.from(parent.childNodes).indexOf(node)];
}
function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
  const anchorKey = anchorNode.getKey();
  const focusKey = focusNode.getKey();
  const range = document.createRange();
  let anchorDOM = editor.getElementByKey(anchorKey);
  let focusDOM = editor.getElementByKey(focusKey);
  let anchorOffset = _anchorOffset;
  let focusOffset = _focusOffset;
  if ($isTextNode2(anchorNode)) {
    anchorDOM = getDOMTextNode3(anchorDOM);
  }
  if ($isTextNode2(focusNode)) {
    focusDOM = getDOMTextNode3(focusDOM);
  }
  if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
    return null;
  }
  if (anchorDOM.nodeName === "BR") {
    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
  }
  if (focusDOM.nodeName === "BR") {
    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
  }
  const firstChild = anchorDOM.firstChild;
  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
    focusOffset = 1;
  }
  try {
    range.setStart(anchorDOM, anchorOffset);
    range.setEnd(focusDOM, focusOffset);
  } catch (e2) {
    return null;
  }
  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
    range.setStart(focusDOM, focusOffset);
    range.setEnd(anchorDOM, anchorOffset);
  }
  return range;
}
function createRectsFromDOMRange(editor, range) {
  const rootElement = editor.getRootElement();
  if (rootElement === null) {
    return [];
  }
  const rootRect = rootElement.getBoundingClientRect();
  const computedStyle = getComputedStyle(rootElement);
  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  const selectionRects = Array.from(range.getClientRects());
  let selectionRectsLength = selectionRects.length;
  selectionRects.sort((a2, b3) => {
    const top = a2.top - b3.top;
    if (Math.abs(top) <= 3) {
      return a2.left - b3.left;
    }
    return top;
  });
  let prevRect;
  for (let i2 = 0; i2 < selectionRectsLength; i2++) {
    const selectionRect = selectionRects[i2];
    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
    if (isOverlappingRect || selectionSpansElement) {
      selectionRects.splice(i2--, 1);
      selectionRectsLength--;
      continue;
    }
    prevRect = selectionRect;
  }
  return selectionRects;
}
function getStyleObjectFromRawCSS(css) {
  const styleObject = {};
  if (!css) {
    return styleObject;
  }
  const styles = css.split(";");
  for (const style of styles) {
    if (style !== "") {
      const [key2, value] = style.split(/:([^]+)/);
      if (key2 && value) {
        styleObject[key2.trim()] = value.trim();
      }
    }
  }
  return styleObject;
}
function getStyleObjectFromCSS(css) {
  let value = CSS_TO_STYLES.get(css);
  if (value === void 0) {
    value = getStyleObjectFromRawCSS(css);
    CSS_TO_STYLES.set(css, value);
  }
  {
    Object.freeze(value);
  }
  return value;
}
function getCSSFromStyleObject(styles) {
  let css = "";
  for (const style in styles) {
    if (style) {
      css += `${style}: ${styles[style]};`;
    }
  }
  return css;
}
function $sliceSelectedTextNodeContent(selection, textNode) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (textNode.isSelected(selection) && !$isTokenOrSegmented2(textNode) && anchorAndFocus !== null) {
    const [anchor, focus] = anchorAndFocus;
    const isBackward = selection.isBackward();
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isAnchor = textNode.is(anchorNode);
    const isFocus = textNode.is(focusNode);
    if (isAnchor || isFocus) {
      const [anchorOffset, focusOffset] = $getCharacterOffsets2(selection);
      const isSame = anchorNode.is(focusNode);
      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
      const isLast = textNode.is(isBackward ? anchorNode : focusNode);
      let startOffset = 0;
      let endOffset = void 0;
      if (isSame) {
        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
      } else if (isFirst) {
        const offset = isBackward ? focusOffset : anchorOffset;
        startOffset = offset;
        endOffset = void 0;
      } else if (isLast) {
        const offset = isBackward ? anchorOffset : focusOffset;
        startOffset = 0;
        endOffset = offset;
      }
      textNode.__text = textNode.__text.slice(startOffset, endOffset);
    }
  }
  return textNode;
}
function $isAtNodeEnd(point) {
  if (point.type === "text") {
    return point.offset === point.getNode().getTextContentSize();
  }
  const node = point.getNode();
  if (!$isElementNode2(node)) {
    formatDevErrorMessage2(`isAtNodeEnd: node must be a TextNode or ElementNode`);
  }
  return point.offset === node.getChildrenSize();
}
function $trimTextContentFromAnchor(editor, anchor, delCount) {
  let currentNode = anchor.getNode();
  let remaining = delCount;
  if ($isElementNode2(currentNode)) {
    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
    if (descendantNode !== null) {
      currentNode = descendantNode;
    }
  }
  while (remaining > 0 && currentNode !== null) {
    if ($isElementNode2(currentNode)) {
      const lastDescendant = currentNode.getLastDescendant();
      if (lastDescendant !== null) {
        currentNode = lastDescendant;
      }
    }
    let nextNode = currentNode.getPreviousSibling();
    let additionalElementWhitespace = 0;
    if (nextNode === null) {
      let parent = currentNode.getParentOrThrow();
      let parentSibling = parent.getPreviousSibling();
      while (parentSibling === null) {
        parent = parent.getParent();
        if (parent === null) {
          nextNode = null;
          break;
        }
        parentSibling = parent.getPreviousSibling();
      }
      if (parent !== null) {
        additionalElementWhitespace = parent.isInline() ? 0 : 2;
        nextNode = parentSibling;
      }
    }
    let text = currentNode.getTextContent();
    if (text === "" && $isElementNode2(currentNode) && !currentNode.isInline()) {
      text = "\n\n";
    }
    const currentNodeSize = text.length;
    if (!$isTextNode2(currentNode) || remaining >= currentNodeSize) {
      const parent = currentNode.getParent();
      currentNode.remove();
      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode2(parent)) {
        parent.remove();
      }
      remaining -= currentNodeSize + additionalElementWhitespace;
      currentNode = nextNode;
    } else {
      const key2 = currentNode.getKey();
      const prevTextContent = editor.getEditorState().read(() => {
        const prevNode = $getNodeByKey2(key2);
        if ($isTextNode2(prevNode) && prevNode.isSimpleText()) {
          return prevNode.getTextContent();
        }
        return null;
      });
      const offset = currentNodeSize - remaining;
      const slicedText = text.slice(0, offset);
      if (prevTextContent !== null && prevTextContent !== text) {
        const prevSelection = $getPreviousSelection2();
        let target = currentNode;
        if (!currentNode.isSimpleText()) {
          const textNode = $createTextNode2(prevTextContent);
          currentNode.replace(textNode);
          target = textNode;
        } else {
          currentNode.setTextContent(prevTextContent);
        }
        if ($isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
          const prevOffset = prevSelection.anchor.offset;
          target.select(prevOffset, prevOffset);
        }
      } else if (currentNode.isSimpleText()) {
        const isSelected = anchor.key === key2;
        let anchorOffset = anchor.offset;
        if (anchorOffset < remaining) {
          anchorOffset = currentNodeSize;
        }
        const splitStart = isSelected ? anchorOffset - remaining : 0;
        const splitEnd = isSelected ? anchorOffset : offset;
        if (isSelected && splitStart === 0) {
          const [excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        } else {
          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        }
      } else {
        const textNode = $createTextNode2(slicedText);
        currentNode.replace(textNode);
      }
      remaining = 0;
    }
  }
}
function $addNodeStyle(node) {
  const CSSText = node.getStyle();
  const styles = getStyleObjectFromRawCSS(CSSText);
  CSS_TO_STYLES.set(CSSText, styles);
}
function $patchStyle(target, patch) {
  if (!($isRangeSelection2(target) ? target.isCollapsed() : $isTextNode2(target) || $isElementNode2(target))) {
    formatDevErrorMessage2(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);
  }
  const prevStyles = getStyleObjectFromCSS($isRangeSelection2(target) ? target.style : $isTextNode2(target) ? target.getStyle() : target.getTextStyle());
  const newStyles = Object.entries(patch).reduce((styles, [key2, value]) => {
    if (typeof value === "function") {
      styles[key2] = value(prevStyles[key2], target);
    } else if (value === null) {
      delete styles[key2];
    } else {
      styles[key2] = value;
    }
    return styles;
  }, {
    ...prevStyles
  });
  const newCSSText = getCSSFromStyleObject(newStyles);
  if ($isRangeSelection2(target) || $isTextNode2(target)) {
    target.setStyle(newCSSText);
  } else {
    target.setTextStyle(newCSSText);
  }
  CSS_TO_STYLES.set(newCSSText, newStyles);
}
function $patchStyleText(selection, patch) {
  if ($isRangeSelection2(selection) && selection.isCollapsed()) {
    $patchStyle(selection, patch);
    const emptyNode = selection.anchor.getNode();
    if ($isElementNode2(emptyNode) && emptyNode.isEmpty()) {
      $patchStyle(emptyNode, patch);
    }
  }
  $forEachSelectedTextNode((textNode) => {
    $patchStyle(textNode, patch);
  });
}
function $forEachSelectedTextNode(fn3) {
  const selection = $getSelection2();
  if (!selection) {
    return;
  }
  const slicedTextNodes = /* @__PURE__ */ new Map();
  const getSliceIndices = (node) => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];
  if ($isRangeSelection2(selection)) {
    for (const slice of $caretRangeFromSelection2(selection).getTextSlices()) {
      if (slice) {
        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());
      }
    }
  }
  const selectedNodes = selection.getNodes();
  for (const selectedNode of selectedNodes) {
    if (!($isTextNode2(selectedNode) && selectedNode.canHaveFormat())) {
      continue;
    }
    const [startOffset, endOffset] = getSliceIndices(selectedNode);
    if (endOffset === startOffset) {
      continue;
    }
    if ($isTokenOrSegmented2(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {
      fn3(selectedNode);
    } else {
      const splitNodes = selectedNode.splitText(startOffset, endOffset);
      const replacement = splitNodes[startOffset === 0 ? 0 : 1];
      fn3(replacement);
    }
  }
  if ($isRangeSelection2(selection) && selection.anchor.type === "text" && selection.focus.type === "text" && selection.anchor.key === selection.focus.key) {
    $ensureForwardRangeSelection(selection);
  }
}
function $ensureForwardRangeSelection(selection) {
  if (selection.isBackward()) {
    const {
      anchor,
      focus
    } = selection;
    const {
      key: key2,
      offset,
      type
    } = anchor;
    anchor.set(focus.key, focus.offset, focus.type);
    focus.set(key2, offset, type);
  }
}
function $copyBlockFormatIndent(srcNode, destNode) {
  const format = srcNode.getFormatType();
  const indent = srcNode.getIndent();
  if (format !== destNode.getFormatType()) {
    destNode.setFormat(format);
  }
  if (indent !== destNode.getIndent()) {
    destNode.setIndent(indent);
  }
}
function $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {
  if (selection === null) {
    return;
  }
  const anchorAndFocus = selection.getStartEndPoints();
  const blockMap = /* @__PURE__ */ new Map();
  let newSelection = null;
  if (anchorAndFocus) {
    const [anchor, focus] = anchorAndFocus;
    newSelection = $createRangeSelection2();
    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);
    newSelection.focus.set(focus.key, focus.offset, focus.type);
    const anchorBlock = $getAncestor2(anchor.getNode(), INTERNAL_$isBlock2);
    const focusBlock = $getAncestor2(focus.getNode(), INTERNAL_$isBlock2);
    if ($isElementNode2(anchorBlock)) {
      blockMap.set(anchorBlock.getKey(), anchorBlock);
    }
    if ($isElementNode2(focusBlock)) {
      blockMap.set(focusBlock.getKey(), focusBlock);
    }
  }
  for (const node of selection.getNodes()) {
    if ($isElementNode2(node) && INTERNAL_$isBlock2(node)) {
      blockMap.set(node.getKey(), node);
    } else if (anchorAndFocus === null) {
      const ancestorBlock = $getAncestor2(node, INTERNAL_$isBlock2);
      if ($isElementNode2(ancestorBlock)) {
        blockMap.set(ancestorBlock.getKey(), ancestorBlock);
      }
    }
  }
  for (const [key2, prevNode] of blockMap) {
    const element = $createElement();
    $afterCreateElement(prevNode, element);
    prevNode.replace(element, true);
    if (newSelection) {
      if (key2 === newSelection.anchor.key) {
        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);
      }
      if (key2 === newSelection.focus.key) {
        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);
      }
    }
  }
  if (newSelection && selection.is($getSelection2())) {
    $setSelection2(newSelection);
  }
}
function isPointAttached(point) {
  return point.getNode().isAttached();
}
function $removeParentEmptyElements(startingNode) {
  let node = startingNode;
  while (node !== null && !$isRootOrShadowRoot2(node)) {
    const latest = node.getLatest();
    const parentNode = node.getParent();
    if (latest.getChildrenSize() === 0) {
      node.remove(true);
    }
    node = parentNode;
  }
}
function $wrapNodes(selection, createElement, wrappingElement = null) {
  const anchorAndFocus = selection.getStartEndPoints();
  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
  const nodes = selection.getNodes();
  const nodesLength = nodes.length;
  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0)) {
    const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
    const children = target.getChildren();
    let element = createElement();
    element.setFormat(target.getFormatType());
    element.setIndent(target.getIndent());
    children.forEach((child) => element.append(child));
    if (wrappingElement) {
      element = wrappingElement.append(element);
    }
    target.replace(element);
    return;
  }
  let topLevelNode = null;
  let descendants = [];
  for (let i2 = 0; i2 < nodesLength; i2++) {
    const node = nodes[i2];
    if ($isRootOrShadowRoot2(node)) {
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
      descendants = [];
      topLevelNode = node;
    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor2(node, topLevelNode)) {
      descendants.push(node);
    } else {
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
      descendants = [node];
    }
  }
  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
}
function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
  if (nodes.length === 0) {
    return;
  }
  const firstNode = nodes[0];
  const elementMapping = /* @__PURE__ */ new Map();
  const elements = [];
  let target = $isElementNode2(firstNode) ? firstNode : firstNode.getParentOrThrow();
  if (target.isInline()) {
    target = target.getParentOrThrow();
  }
  let targetIsPrevSibling = false;
  while (target !== null) {
    const prevSibling = target.getPreviousSibling();
    if (prevSibling !== null) {
      target = prevSibling;
      targetIsPrevSibling = true;
      break;
    }
    target = target.getParentOrThrow();
    if ($isRootOrShadowRoot2(target)) {
      break;
    }
  }
  const emptyElements = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < nodesLength; i2++) {
    const node = nodes[i2];
    if ($isElementNode2(node) && node.getChildrenSize() === 0) {
      emptyElements.add(node.getKey());
    }
  }
  const movedNodes = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < nodesLength; i2++) {
    const node = nodes[i2];
    let parent = node.getParent();
    if (parent !== null && parent.isInline()) {
      parent = parent.getParent();
    }
    if (parent !== null && $isLeafNode2(node) && !movedNodes.has(node.getKey())) {
      const parentKey = parent.getKey();
      if (elementMapping.get(parentKey) === void 0) {
        const targetElement = createElement();
        targetElement.setFormat(parent.getFormatType());
        targetElement.setIndent(parent.getIndent());
        elements.push(targetElement);
        elementMapping.set(parentKey, targetElement);
        parent.getChildren().forEach((child) => {
          targetElement.append(child);
          movedNodes.add(child.getKey());
          if ($isElementNode2(child)) {
            child.getChildrenKeys().forEach((key2) => movedNodes.add(key2));
          }
        });
        $removeParentEmptyElements(parent);
      }
    } else if (emptyElements.has(node.getKey())) {
      if (!$isElementNode2(node)) {
        formatDevErrorMessage2(`Expected node in emptyElements to be an ElementNode`);
      }
      const targetElement = createElement();
      targetElement.setFormat(node.getFormatType());
      targetElement.setIndent(node.getIndent());
      elements.push(targetElement);
      node.remove(true);
    }
  }
  if (wrappingElement !== null) {
    for (let i2 = 0; i2 < elements.length; i2++) {
      const element = elements[i2];
      wrappingElement.append(element);
    }
  }
  let lastElement = null;
  if ($isRootOrShadowRoot2(target)) {
    if (targetIsPrevSibling) {
      if (wrappingElement !== null) {
        target.insertAfter(wrappingElement);
      } else {
        for (let i2 = elements.length - 1; i2 >= 0; i2--) {
          const element = elements[i2];
          target.insertAfter(element);
        }
      }
    } else {
      const firstChild = target.getFirstChild();
      if ($isElementNode2(firstChild)) {
        target = firstChild;
      }
      if (firstChild === null) {
        if (wrappingElement) {
          target.append(wrappingElement);
        } else {
          for (let i2 = 0; i2 < elements.length; i2++) {
            const element = elements[i2];
            target.append(element);
            lastElement = element;
          }
        }
      } else {
        if (wrappingElement !== null) {
          firstChild.insertBefore(wrappingElement);
        } else {
          for (let i2 = 0; i2 < elements.length; i2++) {
            const element = elements[i2];
            firstChild.insertBefore(element);
            lastElement = element;
          }
        }
      }
    }
  } else {
    if (wrappingElement) {
      target.insertAfter(wrappingElement);
    } else {
      for (let i2 = elements.length - 1; i2 >= 0; i2--) {
        const element = elements[i2];
        target.insertAfter(element);
        lastElement = element;
      }
    }
  }
  const prevSelection = $getPreviousSelection2();
  if ($isRangeSelection2(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
    $setSelection2(prevSelection.clone());
  } else if (lastElement !== null) {
    lastElement.selectEnd();
  } else {
    selection.dirty = true;
  }
}
function $isEditorVerticalOrientation(selection) {
  const anchorNode = selection.anchor.getNode();
  const parent = $isRootNode2(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
  const editor = $getEditor2();
  const domElement = editor.getElementByKey(parent.getKey());
  if (domElement === null) {
    return false;
  }
  const view = domElement.ownerDocument.defaultView;
  if (view === null) {
    return false;
  }
  const computedStyle = view.getComputedStyle(domElement);
  return computedStyle.writingMode === "vertical-rl";
}
function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
  const isVertical = $isEditorVerticalOrientation(selection);
  const adjustedIsBackward = isVertical ? !isBackward : isBackward;
  const focusCaret = $caretFromPoint2(selection.focus, adjustedIsBackward ? "previous" : "next");
  if ($isExtendableTextPointCaret2(focusCaret)) {
    return false;
  }
  for (const nextCaret of $extendCaretToRange2(focusCaret)) {
    if ($isChildCaret2(nextCaret)) {
      return !nextCaret.origin.isInline();
    } else if ($isElementNode2(nextCaret.origin)) {
      continue;
    } else if ($isDecoratorNode2(nextCaret.origin)) {
      return true;
    }
    break;
  }
  return false;
}
function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
  selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
}
function $isParentElementRTL(selection) {
  const anchorNode = selection.anchor.getNode();
  const parent = $isRootNode2(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
  return parent.getDirection() === "rtl";
}
function $moveCharacter(selection, isHoldingShift, isBackward) {
  const isRTL = $isParentElementRTL(selection);
  const isVertical = $isEditorVerticalOrientation(selection);
  let adjustedIsBackward;
  if (isVertical) {
    adjustedIsBackward = !isBackward;
  } else if (isRTL) {
    adjustedIsBackward = !isBackward;
  } else {
    adjustedIsBackward = isBackward;
  }
  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, "character");
}
function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
  const css = node.getStyle();
  const styleObject = getStyleObjectFromCSS(css);
  if (styleObject !== null) {
    return styleObject[styleProperty] || defaultValue;
  }
  return defaultValue;
}
function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
  let styleValue = null;
  const nodes = selection.getNodes();
  const anchor = selection.anchor;
  const focus = selection.focus;
  const isBackward = selection.isBackward();
  const endOffset = isBackward ? focus.offset : anchor.offset;
  const endNode = isBackward ? focus.getNode() : anchor.getNode();
  if ($isRangeSelection2(selection) && selection.isCollapsed() && selection.style !== "") {
    const css = selection.style;
    const styleObject = getStyleObjectFromCSS(css);
    if (styleObject !== null && styleProperty in styleObject) {
      return styleObject[styleProperty];
    }
  }
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (i2 !== 0 && endOffset === 0 && node.is(endNode)) {
      continue;
    }
    if ($isTextNode2(node)) {
      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
      if (styleValue === null) {
        styleValue = nodeStyleValue;
      } else if (styleValue !== nodeStyleValue) {
        styleValue = "";
        break;
      }
    }
  }
  return styleValue === null ? defaultValue : styleValue;
}
function $getAncestor2(node, predicate) {
  let parent = node;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
var CSS_TO_STYLES, trimTextContentFromAnchor;
var init_LexicalSelection_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/selection@0.32.1/node_modules/@lexical/selection/LexicalSelection.dev.mjs"() {
    await init_Lexical_node();
    await init_Lexical_node();
    CSS_TO_STYLES = /* @__PURE__ */ new Map();
    trimTextContentFromAnchor = $trimTextContentFromAnchor;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/selection@0.32.1/node_modules/@lexical/selection/LexicalSelection.prod.mjs
var LexicalSelection_prod_exports = {};
__export(LexicalSelection_prod_exports, {
  $addNodeStyle: () => z2,
  $cloneWithProperties: () => $cloneWithProperties2,
  $copyBlockFormatIndent: () => D2,
  $ensureForwardRangeSelection: () => $2,
  $forEachSelectedTextNode: () => L2,
  $getSelectionStyleValueForProperty: () => Y2,
  $isAtNodeEnd: () => O2,
  $isParentElementRTL: () => G2,
  $moveCaretSelection: () => q2,
  $moveCharacter: () => J2,
  $patchStyleText: () => M2,
  $selectAll: () => $selectAll2,
  $setBlocksType: () => _2,
  $shouldOverrideDefaultCharacterSelection: () => X2,
  $sliceSelectedTextNodeContent: () => b2,
  $trimTextContentFromAnchor: () => R2,
  $wrapNodes: () => H2,
  createDOMRange: () => E2,
  createRectsFromDOMRange: () => k2,
  getCSSFromStyleObject: () => F2,
  getStyleObjectFromCSS: () => B2,
  trimTextContentFromAnchor: () => ee2
});
function N2(e2, ...t3) {
  const n2 = new URL("https://lexical.dev/docs/error"), o2 = new URLSearchParams();
  o2.append("code", e2);
  for (const e3 of t3) o2.append("v", e3);
  throw n2.search = o2.toString(), Error(`Minified Lexical error #${e2}; visit ${n2.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function P2(e2) {
  let t3 = e2;
  for (; null != t3; ) {
    if (t3.nodeType === Node.TEXT_NODE) return t3;
    t3 = t3.firstChild;
  }
  return null;
}
function K2(e2) {
  const t3 = e2.parentNode;
  if (null == t3) throw new Error("Should never happen");
  return [t3, Array.from(t3.childNodes).indexOf(e2)];
}
function E2(t3, n2, o2, l2, r2) {
  const s2 = n2.getKey(), i2 = l2.getKey(), c2 = document.createRange();
  let f3 = t3.getElementByKey(s2), u2 = t3.getElementByKey(i2), g4 = o2, a2 = r2;
  if ($isTextNode2(n2) && (f3 = P2(f3)), $isTextNode2(l2) && (u2 = P2(u2)), void 0 === n2 || void 0 === l2 || null === f3 || null === u2) return null;
  "BR" === f3.nodeName && ([f3, g4] = K2(f3)), "BR" === u2.nodeName && ([u2, a2] = K2(u2));
  const d3 = f3.firstChild;
  f3 === u2 && null != d3 && "BR" === d3.nodeName && 0 === g4 && 0 === a2 && (a2 = 1);
  try {
    c2.setStart(f3, g4), c2.setEnd(u2, a2);
  } catch (e2) {
    return null;
  }
  return !c2.collapsed || g4 === a2 && s2 === i2 || (c2.setStart(u2, a2), c2.setEnd(f3, g4)), c2;
}
function k2(e2, t3) {
  const n2 = e2.getRootElement();
  if (null === n2) return [];
  const o2 = n2.getBoundingClientRect(), l2 = getComputedStyle(n2), r2 = parseFloat(l2.paddingLeft) + parseFloat(l2.paddingRight), s2 = Array.from(t3.getClientRects());
  let i2, c2 = s2.length;
  s2.sort((e3, t4) => {
    const n3 = e3.top - t4.top;
    return Math.abs(n3) <= 3 ? e3.left - t4.left : n3;
  });
  for (let e3 = 0; e3 < c2; e3++) {
    const t4 = s2[e3], n3 = i2 && i2.top <= t4.top && i2.top + i2.height > t4.top && i2.left + i2.width > t4.left, l3 = t4.width + r2 === o2.width;
    n3 || l3 ? (s2.splice(e3--, 1), c2--) : i2 = t4;
  }
  return s2;
}
function I2(e2) {
  const t3 = {};
  if (!e2) return t3;
  const n2 = e2.split(";");
  for (const e3 of n2) if ("" !== e3) {
    const [n3, o2] = e3.split(/:([^]+)/);
    n3 && o2 && (t3[n3.trim()] = o2.trim());
  }
  return t3;
}
function B2(e2) {
  let t3 = C2.get(e2);
  return void 0 === t3 && (t3 = I2(e2), C2.set(e2, t3)), t3;
}
function F2(e2) {
  let t3 = "";
  for (const n2 in e2) n2 && (t3 += `${n2}: ${e2[n2]};`);
  return t3;
}
function b2(e2, o2) {
  const l2 = e2.getStartEndPoints();
  if (o2.isSelected(e2) && !$isTokenOrSegmented2(o2) && null !== l2) {
    const [t3, r2] = l2, s2 = e2.isBackward(), i2 = t3.getNode(), c2 = r2.getNode(), f3 = o2.is(i2), u2 = o2.is(c2);
    if (f3 || u2) {
      const [t4, l3] = $getCharacterOffsets2(e2), r3 = i2.is(c2), f4 = o2.is(s2 ? c2 : i2), u3 = o2.is(s2 ? i2 : c2);
      let g4, a2 = 0;
      if (r3) a2 = t4 > l3 ? l3 : t4, g4 = t4 > l3 ? t4 : l3;
      else if (f4) {
        a2 = s2 ? l3 : t4, g4 = void 0;
      } else if (u3) {
        a2 = 0, g4 = s2 ? t4 : l3;
      }
      o2.__text = o2.__text.slice(a2, g4);
    }
  }
  return o2;
}
function O2(e2) {
  if ("text" === e2.type) return e2.offset === e2.getNode().getTextContentSize();
  const t3 = e2.getNode();
  return $isElementNode2(t3) || N2(177), e2.offset === t3.getChildrenSize();
}
function R2(t3, n2, f3) {
  let u2 = n2.getNode(), g4 = f3;
  if ($isElementNode2(u2)) {
    const e2 = u2.getDescendantByIndex(n2.offset);
    null !== e2 && (u2 = e2);
  }
  for (; g4 > 0 && null !== u2; ) {
    if ($isElementNode2(u2)) {
      const e2 = u2.getLastDescendant();
      null !== e2 && (u2 = e2);
    }
    let f4 = u2.getPreviousSibling(), a2 = 0;
    if (null === f4) {
      let e2 = u2.getParentOrThrow(), t4 = e2.getPreviousSibling();
      for (; null === t4; ) {
        if (e2 = e2.getParent(), null === e2) {
          f4 = null;
          break;
        }
        t4 = e2.getPreviousSibling();
      }
      null !== e2 && (a2 = e2.isInline() ? 0 : 2, f4 = t4);
    }
    let d3 = u2.getTextContent();
    "" === d3 && $isElementNode2(u2) && !u2.isInline() && (d3 = "\n\n");
    const p3 = d3.length;
    if (!$isTextNode2(u2) || g4 >= p3) {
      const e2 = u2.getParent();
      u2.remove(), null == e2 || 0 !== e2.getChildrenSize() || $isRootNode2(e2) || e2.remove(), g4 -= p3 + a2, u2 = f4;
    } else {
      const o2 = u2.getKey(), l2 = t3.getEditorState().read(() => {
        const t4 = $getNodeByKey2(o2);
        return $isTextNode2(t4) && t4.isSimpleText() ? t4.getTextContent() : null;
      }), f5 = p3 - g4, a3 = d3.slice(0, f5);
      if (null !== l2 && l2 !== d3) {
        const e2 = $getPreviousSelection2();
        let t4 = u2;
        if (u2.isSimpleText()) u2.setTextContent(l2);
        else {
          const e3 = $createTextNode2(l2);
          u2.replace(e3), t4 = e3;
        }
        if ($isRangeSelection2(e2) && e2.isCollapsed()) {
          const n3 = e2.anchor.offset;
          t4.select(n3, n3);
        }
      } else if (u2.isSimpleText()) {
        const e2 = n2.key === o2;
        let t4 = n2.offset;
        t4 < g4 && (t4 = p3);
        const l3 = e2 ? t4 - g4 : 0, r2 = e2 ? t4 : f5;
        if (e2 && 0 === l3) {
          const [e3] = u2.splitText(l3, r2);
          e3.remove();
        } else {
          const [, e3] = u2.splitText(l3, r2);
          e3.remove();
        }
      } else {
        const e2 = $createTextNode2(a3);
        u2.replace(e2);
      }
      g4 = 0;
    }
  }
}
function z2(e2) {
  const t3 = e2.getStyle(), n2 = I2(t3);
  C2.set(t3, n2);
}
function A2(t3, n2) {
  ($isRangeSelection2(t3) ? t3.isCollapsed() : $isTextNode2(t3) || $isElementNode2(t3)) || N2(280);
  const l2 = B2($isRangeSelection2(t3) ? t3.style : $isTextNode2(t3) ? t3.getStyle() : t3.getTextStyle()), r2 = Object.entries(n2).reduce((e2, [n3, o2]) => ("function" == typeof o2 ? e2[n3] = o2(l2[n3], t3) : null === o2 ? delete e2[n3] : e2[n3] = o2, e2), { ...l2 }), s2 = F2(r2);
  $isRangeSelection2(t3) || $isTextNode2(t3) ? t3.setStyle(s2) : t3.setTextStyle(s2), C2.set(s2, r2);
}
function M2(e2, t3) {
  if ($isRangeSelection2(e2) && e2.isCollapsed()) {
    A2(e2, t3);
    const n2 = e2.anchor.getNode();
    $isElementNode2(n2) && n2.isEmpty() && A2(n2, t3);
  }
  L2((e3) => {
    A2(e3, t3);
  });
}
function L2(n2) {
  const o2 = $getSelection2();
  if (!o2) return;
  const l2 = /* @__PURE__ */ new Map();
  if ($isRangeSelection2(o2)) for (const e2 of $caretRangeFromSelection2(o2).getTextSlices()) e2 && l2.set(e2.caret.origin.getKey(), e2.getSliceIndices());
  const r2 = o2.getNodes();
  for (const o3 of r2) {
    if (!$isTextNode2(o3) || !o3.canHaveFormat()) continue;
    const [r3, i2] = (s2 = o3, l2.get(s2.getKey()) || [0, s2.getTextContentSize()]);
    if (i2 !== r3) if ($isTokenOrSegmented2(o3) || 0 === r3 && i2 === o3.getTextContentSize()) n2(o3);
    else {
      n2(o3.splitText(r3, i2)[0 === r3 ? 0 : 1]);
    }
  }
  var s2;
  $isRangeSelection2(o2) && "text" === o2.anchor.type && "text" === o2.focus.type && o2.anchor.key === o2.focus.key && $2(o2);
}
function $2(e2) {
  if (e2.isBackward()) {
    const { anchor: t3, focus: n2 } = e2, { key: o2, offset: l2, type: r2 } = t3;
    t3.set(n2.key, n2.offset, n2.type), n2.set(o2, l2, r2);
  }
}
function D2(e2, t3) {
  const n2 = e2.getFormatType(), o2 = e2.getIndent();
  n2 !== t3.getFormatType() && t3.setFormat(n2), o2 !== t3.getIndent() && t3.setIndent(o2);
}
function _2(e2, t3, n2 = D2) {
  if (null === e2) return;
  const l2 = e2.getStartEndPoints(), r2 = /* @__PURE__ */ new Map();
  let s2 = null;
  if (l2) {
    const [e3, t4] = l2;
    s2 = $createRangeSelection2(), s2.anchor.set(e3.key, e3.offset, e3.type), s2.focus.set(t4.key, t4.offset, t4.type);
    const n3 = Z2(e3.getNode(), INTERNAL_$isBlock2), i2 = Z2(t4.getNode(), INTERNAL_$isBlock2);
    $isElementNode2(n3) && r2.set(n3.getKey(), n3), $isElementNode2(i2) && r2.set(i2.getKey(), i2);
  }
  for (const t4 of e2.getNodes()) if ($isElementNode2(t4) && INTERNAL_$isBlock2(t4)) r2.set(t4.getKey(), t4);
  else if (null === l2) {
    const e3 = Z2(t4, INTERNAL_$isBlock2);
    $isElementNode2(e3) && r2.set(e3.getKey(), e3);
  }
  for (const [e3, o2] of r2) {
    const l3 = t3();
    n2(o2, l3), o2.replace(l3, true), s2 && (e3 === s2.anchor.key && s2.anchor.set(l3.getKey(), s2.anchor.offset, s2.anchor.type), e3 === s2.focus.key && s2.focus.set(l3.getKey(), s2.focus.offset, s2.focus.type));
  }
  s2 && e2.is($getSelection2()) && $setSelection2(s2);
}
function U2(e2) {
  return e2.getNode().isAttached();
}
function j2(e2) {
  let t3 = e2;
  for (; null !== t3 && !$isRootOrShadowRoot2(t3); ) {
    const e3 = t3.getLatest(), n2 = t3.getParent();
    0 === e3.getChildrenSize() && t3.remove(true), t3 = n2;
  }
}
function H2(e2, t3, n2 = null) {
  const o2 = e2.getStartEndPoints(), l2 = o2 ? o2[0] : null, r2 = e2.getNodes(), s2 = r2.length;
  if (null !== l2 && (0 === s2 || 1 === s2 && "element" === l2.type && 0 === l2.getNode().getChildrenSize())) {
    const e3 = "text" === l2.type ? l2.getNode().getParentOrThrow() : l2.getNode(), o3 = e3.getChildren();
    let r3 = t3();
    return r3.setFormat(e3.getFormatType()), r3.setIndent(e3.getIndent()), o3.forEach((e4) => r3.append(e4)), n2 && (r3 = n2.append(r3)), void e3.replace(r3);
  }
  let i2 = null, c2 = [];
  for (let o3 = 0; o3 < s2; o3++) {
    const l3 = r2[o3];
    $isRootOrShadowRoot2(l3) ? (V2(e2, c2, c2.length, t3, n2), c2 = [], i2 = l3) : null === i2 || null !== i2 && $hasAncestor2(l3, i2) ? c2.push(l3) : (V2(e2, c2, c2.length, t3, n2), c2 = [l3]);
  }
  V2(e2, c2, c2.length, t3, n2);
}
function V2(e2, t3, n2, l2, r2 = null) {
  if (0 === t3.length) return;
  const i2 = t3[0], f3 = /* @__PURE__ */ new Map(), u2 = [];
  let g4 = $isElementNode2(i2) ? i2 : i2.getParentOrThrow();
  g4.isInline() && (g4 = g4.getParentOrThrow());
  let a2 = false;
  for (; null !== g4; ) {
    const e3 = g4.getPreviousSibling();
    if (null !== e3) {
      g4 = e3, a2 = true;
      break;
    }
    if (g4 = g4.getParentOrThrow(), $isRootOrShadowRoot2(g4)) break;
  }
  const h4 = /* @__PURE__ */ new Set();
  for (let e3 = 0; e3 < n2; e3++) {
    const n3 = t3[e3];
    $isElementNode2(n3) && 0 === n3.getChildrenSize() && h4.add(n3.getKey());
  }
  const m4 = /* @__PURE__ */ new Set();
  for (let e3 = 0; e3 < n2; e3++) {
    const n3 = t3[e3];
    let r3 = n3.getParent();
    if (null !== r3 && r3.isInline() && (r3 = r3.getParent()), null !== r3 && $isLeafNode2(n3) && !m4.has(n3.getKey())) {
      const e4 = r3.getKey();
      if (void 0 === f3.get(e4)) {
        const t4 = l2();
        t4.setFormat(r3.getFormatType()), t4.setIndent(r3.getIndent()), u2.push(t4), f3.set(e4, t4), r3.getChildren().forEach((e5) => {
          t4.append(e5), m4.add(e5.getKey()), $isElementNode2(e5) && e5.getChildrenKeys().forEach((e6) => m4.add(e6));
        }), j2(r3);
      }
    } else if (h4.has(n3.getKey())) {
      $isElementNode2(n3) || N2(179);
      const e4 = l2();
      e4.setFormat(n3.getFormatType()), e4.setIndent(n3.getIndent()), u2.push(e4), n3.remove(true);
    }
  }
  if (null !== r2) for (let e3 = 0; e3 < u2.length; e3++) {
    const t4 = u2[e3];
    r2.append(t4);
  }
  let S4 = null;
  if ($isRootOrShadowRoot2(g4)) if (a2) if (null !== r2) g4.insertAfter(r2);
  else for (let e3 = u2.length - 1; e3 >= 0; e3--) {
    const t4 = u2[e3];
    g4.insertAfter(t4);
  }
  else {
    const e3 = g4.getFirstChild();
    if ($isElementNode2(e3) && (g4 = e3), null === e3) if (r2) g4.append(r2);
    else for (let e4 = 0; e4 < u2.length; e4++) {
      const t4 = u2[e4];
      g4.append(t4), S4 = t4;
    }
    else if (null !== r2) e3.insertBefore(r2);
    else for (let t4 = 0; t4 < u2.length; t4++) {
      const n3 = u2[t4];
      e3.insertBefore(n3), S4 = n3;
    }
  }
  else if (r2) g4.insertAfter(r2);
  else for (let e3 = u2.length - 1; e3 >= 0; e3--) {
    const t4 = u2[e3];
    g4.insertAfter(t4), S4 = t4;
  }
  const x4 = $getPreviousSelection2();
  $isRangeSelection2(x4) && U2(x4.anchor) && U2(x4.focus) ? $setSelection2(x4.clone()) : null !== S4 ? S4.selectEnd() : e2.dirty = true;
}
function W2(e2) {
  const t3 = e2.anchor.getNode(), n2 = $isRootNode2(t3) ? t3 : t3.getParentOrThrow(), o2 = $getEditor2().getElementByKey(n2.getKey());
  if (null === o2) return false;
  const r2 = o2.ownerDocument.defaultView;
  if (null === r2) return false;
  return "vertical-rl" === r2.getComputedStyle(o2).writingMode;
}
function X2(e2, t3) {
  const n2 = W2(e2) ? !t3 : t3, l2 = $caretFromPoint2(e2.focus, n2 ? "previous" : "next");
  if ($isExtendableTextPointCaret2(l2)) return false;
  for (const e3 of $extendCaretToRange2(l2)) {
    if ($isChildCaret2(e3)) return !e3.origin.isInline();
    if (!$isElementNode2(e3.origin)) {
      if ($isDecoratorNode2(e3.origin)) return true;
      break;
    }
  }
  return false;
}
function q2(e2, t3, n2, o2) {
  e2.modify(t3 ? "extend" : "move", n2, o2);
}
function G2(e2) {
  const t3 = e2.anchor.getNode();
  return "rtl" === ($isRootNode2(t3) ? t3 : t3.getParentOrThrow()).getDirection();
}
function J2(e2, t3, n2) {
  const o2 = G2(e2);
  let l2;
  l2 = W2(e2) || o2 ? !n2 : n2, q2(e2, t3, l2, "character");
}
function Q2(e2, t3, n2) {
  const o2 = B2(e2.getStyle());
  return null !== o2 && o2[t3] || n2;
}
function Y2(t3, n2, o2 = "") {
  let l2 = null;
  const r2 = t3.getNodes(), s2 = t3.anchor, i2 = t3.focus, f3 = t3.isBackward(), u2 = f3 ? i2.offset : s2.offset, g4 = f3 ? i2.getNode() : s2.getNode();
  if ($isRangeSelection2(t3) && t3.isCollapsed() && "" !== t3.style) {
    const e2 = B2(t3.style);
    if (null !== e2 && n2 in e2) return e2[n2];
  }
  for (let t4 = 0; t4 < r2.length; t4++) {
    const s3 = r2[t4];
    if ((0 === t4 || 0 !== u2 || !s3.is(g4)) && $isTextNode2(s3)) {
      const e2 = Q2(s3, n2, o2);
      if (null === l2) l2 = e2;
      else if (l2 !== e2) {
        l2 = "";
        break;
      }
    }
  }
  return null === l2 ? o2 : l2;
}
function Z2(e2, t3) {
  let n2 = e2;
  for (; null !== n2 && null !== n2.getParent() && !t3(n2); ) n2 = n2.getParentOrThrow();
  return t3(n2) ? n2 : null;
}
var C2, ee2;
var init_LexicalSelection_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/selection@0.32.1/node_modules/@lexical/selection/LexicalSelection.prod.mjs"() {
    await init_Lexical_node();
    await init_Lexical_node();
    C2 = /* @__PURE__ */ new Map();
    ee2 = R2;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/selection@0.32.1/node_modules/@lexical/selection/LexicalSelection.node.mjs
var mod2, $addNodeStyle2, $cloneWithProperties3, $copyBlockFormatIndent2, $ensureForwardRangeSelection2, $forEachSelectedTextNode2, $getSelectionStyleValueForProperty2, $isAtNodeEnd2, $isParentElementRTL2, $moveCaretSelection2, $moveCharacter2, $patchStyleText2, $selectAll3, $setBlocksType2, $shouldOverrideDefaultCharacterSelection2, $sliceSelectedTextNodeContent2, $trimTextContentFromAnchor2, $wrapNodes2, createDOMRange2, createRectsFromDOMRange2, getCSSFromStyleObject2, getStyleObjectFromCSS2, trimTextContentFromAnchor2;
var init_LexicalSelection_node = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/selection@0.32.1/node_modules/@lexical/selection/LexicalSelection.node.mjs"() {
    mod2 = await (process.env.NODE_ENV !== "production" ? init_LexicalSelection_dev().then(() => LexicalSelection_dev_exports) : init_LexicalSelection_prod().then(() => LexicalSelection_prod_exports));
    $addNodeStyle2 = mod2.$addNodeStyle;
    $cloneWithProperties3 = mod2.$cloneWithProperties;
    $copyBlockFormatIndent2 = mod2.$copyBlockFormatIndent;
    $ensureForwardRangeSelection2 = mod2.$ensureForwardRangeSelection;
    $forEachSelectedTextNode2 = mod2.$forEachSelectedTextNode;
    $getSelectionStyleValueForProperty2 = mod2.$getSelectionStyleValueForProperty;
    $isAtNodeEnd2 = mod2.$isAtNodeEnd;
    $isParentElementRTL2 = mod2.$isParentElementRTL;
    $moveCaretSelection2 = mod2.$moveCaretSelection;
    $moveCharacter2 = mod2.$moveCharacter;
    $patchStyleText2 = mod2.$patchStyleText;
    $selectAll3 = mod2.$selectAll;
    $setBlocksType2 = mod2.$setBlocksType;
    $shouldOverrideDefaultCharacterSelection2 = mod2.$shouldOverrideDefaultCharacterSelection;
    $sliceSelectedTextNodeContent2 = mod2.$sliceSelectedTextNodeContent;
    $trimTextContentFromAnchor2 = mod2.$trimTextContentFromAnchor;
    $wrapNodes2 = mod2.$wrapNodes;
    createDOMRange2 = mod2.createDOMRange;
    createRectsFromDOMRange2 = mod2.createRectsFromDOMRange;
    getCSSFromStyleObject2 = mod2.getCSSFromStyleObject;
    getStyleObjectFromCSS2 = mod2.getStyleObjectFromCSS;
    trimTextContentFromAnchor2 = mod2.trimTextContentFromAnchor;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/utils@0.32.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs
var LexicalUtils_dev_exports = {};
__export(LexicalUtils_dev_exports, {
  $descendantsMatching: () => $descendantsMatching,
  $dfs: () => $dfs,
  $dfsIterator: () => $dfsIterator,
  $filter: () => $filter,
  $findMatchingParent: () => $findMatchingParent2,
  $firstToLastIterator: () => $firstToLastIterator,
  $getAdjacentCaret: () => $getAdjacentCaret,
  $getAdjacentSiblingOrParentSiblingCaret: () => $getAdjacentSiblingOrParentSiblingCaret3,
  $getDepth: () => $getDepth,
  $getNearestBlockElementAncestorOrThrow: () => $getNearestBlockElementAncestorOrThrow,
  $getNearestNodeOfType: () => $getNearestNodeOfType,
  $getNextRightPreorderNode: () => $getNextRightPreorderNode,
  $getNextSiblingOrParentSibling: () => $getNextSiblingOrParentSibling,
  $insertFirst: () => $insertFirst,
  $insertNodeToNearestRoot: () => $insertNodeToNearestRoot,
  $insertNodeToNearestRootAtCaret: () => $insertNodeToNearestRootAtCaret,
  $isEditorIsNestedEditor: () => $isEditorIsNestedEditor,
  $lastToFirstIterator: () => $lastToFirstIterator,
  $restoreEditorState: () => $restoreEditorState,
  $reverseDfs: () => $reverseDfs,
  $reverseDfsIterator: () => $reverseDfsIterator,
  $splitNode: () => $splitNode2,
  $unwrapAndFilterDescendants: () => $unwrapAndFilterDescendants,
  $unwrapNode: () => $unwrapNode,
  $wrapNodeInElement: () => $wrapNodeInElement,
  CAN_USE_BEFORE_INPUT: () => CAN_USE_BEFORE_INPUT2,
  CAN_USE_DOM: () => CAN_USE_DOM2,
  IS_ANDROID: () => IS_ANDROID2,
  IS_ANDROID_CHROME: () => IS_ANDROID_CHROME2,
  IS_APPLE: () => IS_APPLE2,
  IS_APPLE_WEBKIT: () => IS_APPLE_WEBKIT2,
  IS_CHROME: () => IS_CHROME2,
  IS_FIREFOX: () => IS_FIREFOX2,
  IS_IOS: () => IS_IOS2,
  IS_SAFARI: () => IS_SAFARI2,
  addClassNamesToElement: () => addClassNamesToElement,
  calculateZoomLevel: () => calculateZoomLevel,
  isBlockDomNode: () => isBlockDomNode2,
  isHTMLAnchorElement: () => isHTMLAnchorElement2,
  isHTMLElement: () => isHTMLElement2,
  isInlineDomNode: () => isInlineDomNode2,
  isMimeType: () => isMimeType,
  makeStateWrapper: () => makeStateWrapper,
  markSelection: () => markSelection,
  mediaFileReader: () => mediaFileReader,
  mergeRegister: () => mergeRegister,
  objectKlassEquals: () => objectKlassEquals,
  positionNodeOnRange: () => mlcPositionNodeOnRange,
  registerNestedElementResolver: () => registerNestedElementResolver,
  removeClassNamesFromElement: () => removeClassNamesFromElement,
  selectionAlwaysOnDisplay: () => selectionAlwaysOnDisplay
});
function formatDevErrorMessage3(message) {
  throw new Error(message);
}
function normalizeClassNames2(...classNames2) {
  const rval = [];
  for (const className of classNames2) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
function mergeRegister(...func) {
  return () => {
    for (let i2 = func.length - 1; i2 >= 0; i2--) {
      func[i2]();
    }
    func.length = 0;
  };
}
function px(value) {
  return `${value}px`;
}
function prependDOMNode(parent, node) {
  parent.insertBefore(node, parent.firstChild);
}
function mlcPositionNodeOnRange(editor, range, onReposition) {
  let rootDOMNode = null;
  let parentDOMNode = null;
  let observer = null;
  let lastNodes = [];
  const wrapperNode = document.createElement("div");
  wrapperNode.style.position = "relative";
  function position() {
    if (!(rootDOMNode !== null)) {
      formatDevErrorMessage3(`Unexpected null rootDOMNode`);
    }
    if (!(parentDOMNode !== null)) {
      formatDevErrorMessage3(`Unexpected null parentDOMNode`);
    }
    const {
      left: parentLeft,
      top: parentTop
    } = parentDOMNode.getBoundingClientRect();
    const rects = createRectsFromDOMRange2(editor, range);
    if (!wrapperNode.isConnected) {
      prependDOMNode(parentDOMNode, wrapperNode);
    }
    let hasRepositioned = false;
    for (let i2 = 0; i2 < rects.length; i2++) {
      const rect = rects[i2];
      const rectNode = lastNodes[i2] || document.createElement("div");
      const rectNodeStyle = rectNode.style;
      if (rectNodeStyle.position !== "absolute") {
        rectNodeStyle.position = "absolute";
        hasRepositioned = true;
      }
      const left = px(rect.left - parentLeft);
      if (rectNodeStyle.left !== left) {
        rectNodeStyle.left = left;
        hasRepositioned = true;
      }
      const top = px(rect.top - parentTop);
      if (rectNodeStyle.top !== top) {
        rectNode.style.top = top;
        hasRepositioned = true;
      }
      const width = px(rect.width);
      if (rectNodeStyle.width !== width) {
        rectNode.style.width = width;
        hasRepositioned = true;
      }
      const height = px(rect.height);
      if (rectNodeStyle.height !== height) {
        rectNode.style.height = height;
        hasRepositioned = true;
      }
      if (rectNode.parentNode !== wrapperNode) {
        wrapperNode.append(rectNode);
        hasRepositioned = true;
      }
      lastNodes[i2] = rectNode;
    }
    while (lastNodes.length > rects.length) {
      lastNodes.pop();
    }
    if (hasRepositioned) {
      onReposition(lastNodes);
    }
  }
  function stop() {
    parentDOMNode = null;
    rootDOMNode = null;
    if (observer !== null) {
      observer.disconnect();
    }
    observer = null;
    wrapperNode.remove();
    for (const node of lastNodes) {
      node.remove();
    }
    lastNodes = [];
  }
  function restart() {
    const currentRootDOMNode = editor.getRootElement();
    if (currentRootDOMNode === null) {
      return stop();
    }
    const currentParentDOMNode = currentRootDOMNode.parentElement;
    if (!isHTMLElement2(currentParentDOMNode)) {
      return stop();
    }
    stop();
    rootDOMNode = currentRootDOMNode;
    parentDOMNode = currentParentDOMNode;
    observer = new MutationObserver((mutations) => {
      const nextRootDOMNode = editor.getRootElement();
      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
        return restart();
      }
      for (const mutation of mutations) {
        if (!wrapperNode.contains(mutation.target)) {
          return position();
        }
      }
    });
    observer.observe(currentParentDOMNode, mutationObserverConfig);
    position();
  }
  const removeRootListener = editor.registerRootListener(restart);
  return () => {
    removeRootListener();
    stop();
  };
}
function rangeTargetFromPoint(point, node, dom2) {
  if (point.type === "text" || !$isElementNode2(node)) {
    const textDOM = getDOMTextNode2(dom2) || dom2;
    return [textDOM, point.offset];
  } else {
    const slot = node.getDOMSlot(dom2);
    return [slot.element, slot.getFirstChildOffset() + point.offset];
  }
}
function rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {
  const editorDocument = editor._window ? editor._window.document : document;
  const range = editorDocument.createRange();
  if (focusNode.isBefore(anchorNode)) {
    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));
    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));
  } else {
    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));
    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));
  }
  return range;
}
function markSelection(editor, onReposition) {
  let previousAnchorNode = null;
  let previousAnchorNodeDOM = null;
  let previousAnchorOffset = null;
  let previousFocusNode = null;
  let previousFocusNodeDOM = null;
  let previousFocusOffset = null;
  let removeRangeListener = () => {
  };
  function compute(editorState) {
    editorState.read(() => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        previousAnchorNode = null;
        previousAnchorOffset = null;
        previousFocusNode = null;
        previousFocusOffset = null;
        removeRangeListener();
        removeRangeListener = () => {
        };
        return;
      }
      const {
        anchor,
        focus
      } = selection;
      const currentAnchorNode = anchor.getNode();
      const currentAnchorNodeKey = currentAnchorNode.getKey();
      const currentAnchorOffset = anchor.offset;
      const currentFocusNode = focus.getNode();
      const currentFocusNodeKey = currentFocusNode.getKey();
      const currentFocusOffset = focus.offset;
      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);
      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);
      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();
      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();
      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {
        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);
        removeRangeListener();
        removeRangeListener = mlcPositionNodeOnRange(editor, range, (domNodes) => {
          if (onReposition === void 0) {
            for (const domNode of domNodes) {
              const domNodeStyle = domNode.style;
              if (domNodeStyle.background !== "Highlight") {
                domNodeStyle.background = "Highlight";
              }
              if (domNodeStyle.color !== "HighlightText") {
                domNodeStyle.color = "HighlightText";
              }
              if (domNodeStyle.marginTop !== px(-1.5)) {
                domNodeStyle.marginTop = px(-1.5);
              }
              if (domNodeStyle.paddingTop !== px(4)) {
                domNodeStyle.paddingTop = px(4);
              }
              if (domNodeStyle.paddingBottom !== px(0)) {
                domNodeStyle.paddingBottom = px(0);
              }
            }
          } else {
            onReposition(domNodes);
          }
        });
      }
      previousAnchorNode = currentAnchorNode;
      previousAnchorNodeDOM = currentAnchorNodeDOM;
      previousAnchorOffset = currentAnchorOffset;
      previousFocusNode = currentFocusNode;
      previousFocusNodeDOM = currentFocusNodeDOM;
      previousFocusOffset = currentFocusOffset;
    });
  }
  compute(editor.getEditorState());
  return mergeRegister(editor.registerUpdateListener(({
    editorState
  }) => compute(editorState)), () => {
    removeRangeListener();
  });
}
function selectionAlwaysOnDisplay(editor) {
  let removeSelectionMark = null;
  const onSelectionChange2 = () => {
    const domSelection = getSelection();
    const domAnchorNode = domSelection && domSelection.anchorNode;
    const editorRootElement = editor.getRootElement();
    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);
    if (isSelectionInsideEditor) {
      if (removeSelectionMark !== null) {
        removeSelectionMark();
        removeSelectionMark = null;
      }
    } else {
      if (removeSelectionMark === null) {
        removeSelectionMark = markSelection(editor);
      }
    }
  };
  document.addEventListener("selectionchange", onSelectionChange2);
  return () => {
    if (removeSelectionMark !== null) {
      removeSelectionMark();
    }
    document.removeEventListener("selectionchange", onSelectionChange2);
  };
}
function addClassNamesToElement(element, ...classNames2) {
  const classesToAdd = normalizeClassNames2(...classNames2);
  if (classesToAdd.length > 0) {
    element.classList.add(...classesToAdd);
  }
}
function removeClassNamesFromElement(element, ...classNames2) {
  const classesToRemove = normalizeClassNames2(...classNames2);
  if (classesToRemove.length > 0) {
    element.classList.remove(...classesToRemove);
  }
}
function isMimeType(file, acceptableMimeTypes) {
  for (const acceptableType of acceptableMimeTypes) {
    if (file.type.startsWith(acceptableType)) {
      return true;
    }
  }
  return false;
}
function mediaFileReader(files, acceptableMimeTypes) {
  const filesIterator = files[Symbol.iterator]();
  return new Promise((resolve, reject) => {
    const processed = [];
    const handleNextFile = () => {
      const {
        done,
        value: file
      } = filesIterator.next();
      if (done) {
        return resolve(processed);
      }
      const fileReader = new FileReader();
      fileReader.addEventListener("error", reject);
      fileReader.addEventListener("load", () => {
        const result = fileReader.result;
        if (typeof result === "string") {
          processed.push({
            file,
            result
          });
        }
        handleNextFile();
      });
      if (isMimeType(file, acceptableMimeTypes)) {
        fileReader.readAsDataURL(file);
      } else {
        handleNextFile();
      }
    };
    handleNextFile();
  });
}
function $dfs(startNode, endNode) {
  return Array.from($dfsIterator(startNode, endNode));
}
function $getAdjacentCaret(caret) {
  return caret ? caret.getAdjacentCaret() : null;
}
function $reverseDfs(startNode, endNode) {
  return Array.from($reverseDfsIterator(startNode, endNode));
}
function $dfsIterator(startNode, endNode) {
  return $dfsCaretIterator("next", startNode, endNode);
}
function $getEndCaret(startNode, direction) {
  const rval = $getAdjacentSiblingOrParentSiblingCaret3($getSiblingCaret2(startNode, direction));
  return rval && rval[0];
}
function $dfsCaretIterator(direction, startNode, endNode) {
  const root = $getRoot2();
  const start = startNode || root;
  const startCaret = $isElementNode2(start) ? $getChildCaret2(start, direction) : $getSiblingCaret2(start, direction);
  const startDepth = $getDepth(start);
  const endCaret = endNode ? $getAdjacentChildCaret2($getChildCaretOrSelf2($getSiblingCaret2(endNode, direction))) : $getEndCaret(start, direction);
  let depth = startDepth;
  return makeStepwiseIterator2({
    hasNext: (state) => state !== null,
    initial: startCaret,
    map: (state) => ({
      depth,
      node: state.origin
    }),
    step: (state) => {
      if (state.isSameNodeCaret(endCaret)) {
        return null;
      }
      if ($isChildCaret2(state)) {
        depth++;
      }
      const rval = $getAdjacentSiblingOrParentSiblingCaret3(state);
      if (!rval || rval[0].isSameNodeCaret(endCaret)) {
        return null;
      }
      depth += rval[1];
      return rval[0];
    }
  });
}
function $getNextSiblingOrParentSibling(node) {
  const rval = $getAdjacentSiblingOrParentSiblingCaret3($getSiblingCaret2(node, "next"));
  return rval && [rval[0].origin, rval[1]];
}
function $getDepth(node) {
  let depth = -1;
  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {
    depth++;
  }
  return depth;
}
function $getNextRightPreorderNode(startingNode) {
  const startCaret = $getChildCaretOrSelf2($getSiblingCaret2(startingNode, "previous"));
  const next = $getAdjacentSiblingOrParentSiblingCaret3(startCaret, "root");
  return next && next[0].origin;
}
function $reverseDfsIterator(startNode, endNode) {
  return $dfsCaretIterator("previous", startNode, endNode);
}
function $getNearestNodeOfType(node, klass) {
  let parent = node;
  while (parent != null) {
    if (parent instanceof klass) {
      return parent;
    }
    parent = parent.getParent();
  }
  return null;
}
function $getNearestBlockElementAncestorOrThrow(startNode) {
  const blockNode = $findMatchingParent2(startNode, (node) => $isElementNode2(node) && !node.isInline());
  if (!$isElementNode2(blockNode)) {
    {
      formatDevErrorMessage3(`Expected node ${startNode.__key} to have closest block element node.`);
    }
  }
  return blockNode;
}
function registerNestedElementResolver(editor, targetNode, cloneNode2, handleOverlap) {
  const $isTargetNode = (node) => {
    return node instanceof targetNode;
  };
  const $findMatch = (node) => {
    const children = node.getChildren();
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if ($isTargetNode(child)) {
        return null;
      }
    }
    let parentNode = node;
    let childNode = node;
    while (parentNode !== null) {
      childNode = parentNode;
      parentNode = parentNode.getParent();
      if ($isTargetNode(parentNode)) {
        return {
          child: childNode,
          parent: parentNode
        };
      }
    }
    return null;
  };
  const $elementNodeTransform = (node) => {
    const match = $findMatch(node);
    if (match !== null) {
      const {
        child,
        parent
      } = match;
      if (child.is(node)) {
        handleOverlap(parent, node);
        const nextSiblings = child.getNextSiblings();
        const nextSiblingsLength = nextSiblings.length;
        parent.insertAfter(child);
        if (nextSiblingsLength !== 0) {
          const newParent = cloneNode2(parent);
          child.insertAfter(newParent);
          for (let i2 = 0; i2 < nextSiblingsLength; i2++) {
            newParent.append(nextSiblings[i2]);
          }
        }
        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
          parent.remove();
        }
      }
    }
  };
  return editor.registerNodeTransform(targetNode, $elementNodeTransform);
}
function $restoreEditorState(editor, editorState) {
  const FULL_RECONCILE2 = 2;
  const nodeMap = /* @__PURE__ */ new Map();
  const activeEditorState2 = editor._pendingEditorState;
  for (const [key2, node] of editorState._nodeMap) {
    nodeMap.set(key2, $cloneWithProperties2(node));
  }
  if (activeEditorState2) {
    activeEditorState2._nodeMap = nodeMap;
  }
  editor._dirtyType = FULL_RECONCILE2;
  const selection = editorState._selection;
  $setSelection2(selection === null ? null : selection.clone());
}
function $insertNodeToNearestRoot(node) {
  const selection = $getSelection2() || $getPreviousSelection2();
  let initialCaret;
  if ($isRangeSelection2(selection)) {
    initialCaret = $caretFromPoint2(selection.focus, "next");
  } else {
    if (selection != null) {
      const nodes = selection.getNodes();
      const lastNode = nodes[nodes.length - 1];
      if (lastNode) {
        initialCaret = $getSiblingCaret2(lastNode, "next");
      }
    }
    initialCaret = initialCaret || $getChildCaret2($getRoot2(), "previous").getFlipped().insert($createParagraphNode2());
  }
  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);
  const adjacent = $getAdjacentChildCaret2(insertCaret);
  const selectionCaret = $isChildCaret2(adjacent) ? $normalizeCaret2(adjacent) : insertCaret;
  $setSelectionFromCaretRange2($getCollapsedCaretRange2(selectionCaret));
  return node.getLatest();
}
function $insertNodeToNearestRootAtCaret(node, caret, options) {
  let insertCaret = $getCaretInDirection2(caret, "next");
  for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext2(nextCaret, options)) {
    insertCaret = nextCaret;
  }
  if (!!$isTextPointCaret2(insertCaret)) {
    formatDevErrorMessage3(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);
  }
  insertCaret.insert(node.isInline() ? $createParagraphNode2().append(node) : node);
  return $getCaretInDirection2($getSiblingCaret2(node.getLatest(), "next"), caret.direction);
}
function $wrapNodeInElement(node, createElementNode) {
  const elementNode = createElementNode();
  node.replace(elementNode);
  elementNode.append(node);
  return elementNode;
}
function objectKlassEquals(object, objectClass) {
  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}
function $filter(nodes, filterFn) {
  const result = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = filterFn(nodes[i2]);
    if (node !== null) {
      result.push(node);
    }
  }
  return result;
}
function $insertFirst(parent, node) {
  $getChildCaret2(parent, "next").insert(node);
}
function needsManualZoom() {
  if (NEEDS_MANUAL_ZOOM === void 0) {
    const div = document.createElement("div");
    div.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;";
    document.body.appendChild(div);
    const noZoom = div.getBoundingClientRect();
    div.style.setProperty("zoom", "2");
    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;
    document.body.removeChild(div);
  }
  return NEEDS_MANUAL_ZOOM;
}
function calculateZoomLevel(element) {
  let zoom = 1;
  if (needsManualZoom()) {
    while (element) {
      zoom *= Number(window.getComputedStyle(element).getPropertyValue("zoom"));
      element = element.parentElement;
    }
  }
  return zoom;
}
function $isEditorIsNestedEditor(editor) {
  return editor._parentEditor !== null;
}
function $unwrapAndFilterDescendants(root, $predicate) {
  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);
}
function $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {
  let didMutate = false;
  for (const node of $lastToFirstIterator(root)) {
    if ($predicate(node)) {
      if ($onSuccess !== null) {
        $onSuccess(node);
      }
      continue;
    }
    didMutate = true;
    if ($isElementNode2(node)) {
      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || ((child) => node.insertAfter(child)));
    }
    node.remove();
  }
  return didMutate;
}
function $descendantsMatching(children, $predicate) {
  const result = [];
  const stack = Array.from(children).reverse();
  for (let child = stack.pop(); child !== void 0; child = stack.pop()) {
    if ($predicate(child)) {
      result.push(child);
    } else if ($isElementNode2(child)) {
      for (const grandchild of $lastToFirstIterator(child)) {
        stack.push(grandchild);
      }
    }
  }
  return result;
}
function $firstToLastIterator(node) {
  return $childIterator($getChildCaret2(node, "next"));
}
function $lastToFirstIterator(node) {
  return $childIterator($getChildCaret2(node, "previous"));
}
function $childIterator(startCaret) {
  const seen = /* @__PURE__ */ new Set();
  return makeStepwiseIterator2({
    hasNext: $isSiblingCaret2,
    initial: startCaret.getAdjacentCaret(),
    map: (caret) => {
      const origin = caret.origin.getLatest();
      if (seen !== null) {
        const key2 = origin.getKey();
        if (!!seen.has(key2)) {
          formatDevErrorMessage3(`$childIterator: Cycle detected, node with key ${String(key2)} has already been traversed`);
        }
        seen.add(key2);
      }
      return origin;
    },
    step: (caret) => caret.getAdjacentCaret()
  });
}
function $unwrapNode(node) {
  $rewindSiblingCaret2($getSiblingCaret2(node, "next")).splice(1, node.getChildren());
}
function $getAdjacentSiblingOrParentSiblingCaret3(startCaret, rootMode = "root") {
  let depthDiff = 0;
  let caret = startCaret;
  let nextCaret = $getAdjacentChildCaret2(caret);
  while (nextCaret === null) {
    depthDiff--;
    nextCaret = caret.getParentCaret(rootMode);
    if (!nextCaret) {
      return null;
    }
    caret = nextCaret;
    nextCaret = $getAdjacentChildCaret2(caret);
  }
  return nextCaret && [nextCaret, depthDiff];
}
function makeStateWrapper(stateConfig) {
  const $get = (node) => $getState2(node, stateConfig);
  const $set = (node, valueOrUpdater) => $setState2(node, stateConfig, valueOrUpdater);
  return {
    $get,
    $set,
    accessors: [$get, $set],
    makeGetterMethod: () => function $getter() {
      return $get(this);
    },
    makeSetterMethod: () => function $setter(valueOrUpdater) {
      return $set(this, valueOrUpdater);
    },
    stateConfig
  };
}
var CAN_USE_DOM$1, documentMode2, IS_APPLE$1, IS_FIREFOX$1, CAN_USE_BEFORE_INPUT$1, IS_SAFARI$1, IS_IOS$1, IS_ANDROID$1, IS_CHROME$1, IS_ANDROID_CHROME$1, IS_APPLE_WEBKIT$1, mutationObserverConfig, CAN_USE_BEFORE_INPUT2, CAN_USE_DOM2, IS_ANDROID2, IS_ANDROID_CHROME2, IS_APPLE2, IS_APPLE_WEBKIT2, IS_CHROME2, IS_FIREFOX2, IS_IOS2, IS_SAFARI2, $findMatchingParent2, NEEDS_MANUAL_ZOOM;
var init_LexicalUtils_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/utils@0.32.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs"() {
    await init_Lexical_node();
    await init_Lexical_node();
    await init_LexicalSelection_node();
    CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode2 = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
    IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode2 ? "getTargetRanges" in new window.InputEvent("input") : false;
    IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
    IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;
    IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;
    mutationObserverConfig = {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    };
    CAN_USE_BEFORE_INPUT2 = CAN_USE_BEFORE_INPUT$1;
    CAN_USE_DOM2 = CAN_USE_DOM$1;
    IS_ANDROID2 = IS_ANDROID$1;
    IS_ANDROID_CHROME2 = IS_ANDROID_CHROME$1;
    IS_APPLE2 = IS_APPLE$1;
    IS_APPLE_WEBKIT2 = IS_APPLE_WEBKIT$1;
    IS_CHROME2 = IS_CHROME$1;
    IS_FIREFOX2 = IS_FIREFOX$1;
    IS_IOS2 = IS_IOS$1;
    IS_SAFARI2 = IS_SAFARI$1;
    $findMatchingParent2 = (startingNode, findFn) => {
      let curr = startingNode;
      while (curr !== $getRoot2() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    };
    NEEDS_MANUAL_ZOOM = IS_FIREFOX2 || !CAN_USE_DOM2 ? false : void 0;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/utils@0.32.1/node_modules/@lexical/utils/LexicalUtils.prod.mjs
var LexicalUtils_prod_exports = {};
__export(LexicalUtils_prod_exports, {
  $descendantsMatching: () => _t2,
  $dfs: () => st2,
  $dfsIterator: () => at2,
  $filter: () => bt2,
  $findMatchingParent: () => wt2,
  $firstToLastIterator: () => kt2,
  $getAdjacentCaret: () => ct2,
  $getAdjacentSiblingOrParentSiblingCaret: () => $t2,
  $getDepth: () => pt2,
  $getNearestBlockElementAncestorOrThrow: () => yt2,
  $getNearestNodeOfType: () => vt2,
  $getNextRightPreorderNode: () => mt2,
  $getNextSiblingOrParentSibling: () => gt2,
  $insertFirst: () => Nt2,
  $insertNodeToNearestRoot: () => St2,
  $insertNodeToNearestRootAtCaret: () => At2,
  $isEditorIsNestedEditor: () => Rt2,
  $lastToFirstIterator: () => Kt2,
  $restoreEditorState: () => Et2,
  $reverseDfs: () => ft2,
  $reverseDfsIterator: () => ht2,
  $splitNode: () => $splitNode2,
  $unwrapAndFilterDescendants: () => Tt2,
  $unwrapNode: () => Ot2,
  $wrapNodeInElement: () => Ct2,
  CAN_USE_BEFORE_INPUT: () => q3,
  CAN_USE_DOM: () => J3,
  IS_ANDROID: () => Q3,
  IS_ANDROID_CHROME: () => X3,
  IS_APPLE: () => Y3,
  IS_APPLE_WEBKIT: () => Z3,
  IS_CHROME: () => tt2,
  IS_FIREFOX: () => et2,
  IS_IOS: () => nt2,
  IS_SAFARI: () => ot2,
  addClassNamesToElement: () => rt2,
  calculateZoomLevel: () => Mt2,
  isBlockDomNode: () => isBlockDomNode2,
  isHTMLAnchorElement: () => isHTMLAnchorElement2,
  isHTMLElement: () => isHTMLElement2,
  isInlineDomNode: () => isInlineDomNode2,
  isMimeType: () => lt2,
  makeStateWrapper: () => Dt2,
  markSelection: () => W3,
  mediaFileReader: () => ut2,
  mergeRegister: () => j3,
  objectKlassEquals: () => Lt2,
  positionNodeOnRange: () => z3,
  registerNestedElementResolver: () => xt2,
  removeClassNamesFromElement: () => it2,
  selectionAlwaysOnDisplay: () => G3
});
function P3(t3, ...e2) {
  const n2 = new URL("https://lexical.dev/docs/error"), o2 = new URLSearchParams();
  o2.append("code", t3);
  for (const t4 of e2) o2.append("v", t4);
  throw n2.search = o2.toString(), Error(`Minified Lexical error #${t3}; visit ${n2.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function I3(...t3) {
  const e2 = [];
  for (const n2 of t3) if (n2 && "string" == typeof n2) for (const [t4] of n2.matchAll(/\S+/g)) e2.push(t4);
  return e2;
}
function j3(...t3) {
  return () => {
    for (let e2 = t3.length - 1; e2 >= 0; e2--) t3[e2]();
    t3.length = 0;
  };
}
function F3(t3) {
  return `${t3}px`;
}
function z3(e2, n2, o2) {
  let r2 = null, i2 = null, l2 = null, u2 = [];
  const s2 = document.createElement("div");
  function c2() {
    null === r2 && P3(182), null === i2 && P3(183);
    const { left: t3, top: l3 } = i2.getBoundingClientRect(), c3 = createRectsFromDOMRange2(e2, n2);
    var f4, a3;
    s2.isConnected || (a3 = s2, (f4 = i2).insertBefore(a3, f4.firstChild));
    let d3 = false;
    for (let e3 = 0; e3 < c3.length; e3++) {
      const n3 = c3[e3], o3 = u2[e3] || document.createElement("div"), r3 = o3.style;
      "absolute" !== r3.position && (r3.position = "absolute", d3 = true);
      const i3 = F3(n3.left - t3);
      r3.left !== i3 && (r3.left = i3, d3 = true);
      const f5 = F3(n3.top - l3);
      r3.top !== f5 && (o3.style.top = f5, d3 = true);
      const a4 = F3(n3.width);
      r3.width !== a4 && (o3.style.width = a4, d3 = true);
      const g4 = F3(n3.height);
      r3.height !== g4 && (o3.style.height = g4, d3 = true), o3.parentNode !== s2 && (s2.append(o3), d3 = true), u2[e3] = o3;
    }
    for (; u2.length > c3.length; ) u2.pop();
    d3 && o2(u2);
  }
  function f3() {
    i2 = null, r2 = null, null !== l2 && l2.disconnect(), l2 = null, s2.remove();
    for (const t3 of u2) t3.remove();
    u2 = [];
  }
  s2.style.position = "relative";
  const a2 = e2.registerRootListener(function n3() {
    const o3 = e2.getRootElement();
    if (null === o3) return f3();
    const u3 = o3.parentElement;
    if (!isHTMLElement2(u3)) return f3();
    f3(), r2 = o3, i2 = u3, l2 = new MutationObserver((t3) => {
      const o4 = e2.getRootElement(), l3 = o4 && o4.parentElement;
      if (o4 !== r2 || l3 !== i2) return n3();
      for (const e3 of t3) if (!s2.contains(e3.target)) return c2();
    }), l2.observe(u3, U3), c2();
  });
  return () => {
    a2(), f3();
  };
}
function V3(t3, e2, n2) {
  if ("text" !== t3.type && $isElementNode2(e2)) {
    const o2 = e2.getDOMSlot(n2);
    return [o2.element, o2.getFirstChildOffset() + t3.offset];
  }
  return [getDOMTextNode2(n2) || n2, t3.offset];
}
function W3(t3, o2) {
  let r2 = null, i2 = null, l2 = null, u2 = null, s2 = null, c2 = null, f3 = () => {
  };
  function a2(a3) {
    a3.read(() => {
      const a4 = $getSelection2();
      if (!$isRangeSelection2(a4)) return r2 = null, l2 = null, u2 = null, c2 = null, f3(), void (f3 = () => {
      });
      const { anchor: d3, focus: g4 } = a4, p3 = d3.getNode(), m4 = p3.getKey(), h4 = d3.offset, v4 = g4.getNode(), y4 = v4.getKey(), w4 = g4.offset, x4 = t3.getElementByKey(m4), E4 = t3.getElementByKey(y4), S4 = null === r2 || x4 !== i2 || h4 !== l2 || m4 !== r2.getKey(), A4 = null === u2 || E4 !== s2 || w4 !== c2 || y4 !== u2.getKey();
      if ((S4 || A4) && null !== x4 && null !== E4) {
        const e2 = function(t4, e3, n2, o3, r3, i3, l3) {
          const u3 = (t4._window ? t4._window.document : document).createRange();
          return i3.isBefore(n2) ? (u3.setStart(...V3(r3, i3, l3)), u3.setEnd(...V3(e3, n2, o3))) : (u3.setStart(...V3(e3, n2, o3)), u3.setEnd(...V3(r3, i3, l3))), u3;
        }(t3, d3, p3, x4, g4, v4, E4);
        f3(), f3 = z3(t3, e2, (t4) => {
          if (void 0 === o2) for (const e3 of t4) {
            const t5 = e3.style;
            "Highlight" !== t5.background && (t5.background = "Highlight"), "HighlightText" !== t5.color && (t5.color = "HighlightText"), t5.marginTop !== F3(-1.5) && (t5.marginTop = F3(-1.5)), t5.paddingTop !== F3(4) && (t5.paddingTop = F3(4)), t5.paddingBottom !== F3(0) && (t5.paddingBottom = F3(0));
          }
          else o2(t4);
        });
      }
      r2 = p3, i2 = x4, l2 = h4, u2 = v4, s2 = E4, c2 = w4;
    });
  }
  return a2(t3.getEditorState()), j3(t3.registerUpdateListener(({ editorState: t4 }) => a2(t4)), () => {
    f3();
  });
}
function G3(t3) {
  let e2 = null;
  const n2 = () => {
    const n3 = getSelection(), o2 = n3 && n3.anchorNode, r2 = t3.getRootElement();
    null !== o2 && null !== r2 && r2.contains(o2) ? null !== e2 && (e2(), e2 = null) : null === e2 && (e2 = W3(t3));
  };
  return document.addEventListener("selectionchange", n2), () => {
    null !== e2 && e2(), document.removeEventListener("selectionchange", n2);
  };
}
function rt2(t3, ...e2) {
  const n2 = I3(...e2);
  n2.length > 0 && t3.classList.add(...n2);
}
function it2(t3, ...e2) {
  const n2 = I3(...e2);
  n2.length > 0 && t3.classList.remove(...n2);
}
function lt2(t3, e2) {
  for (const n2 of e2) if (t3.type.startsWith(n2)) return true;
  return false;
}
function ut2(t3, e2) {
  const n2 = t3[Symbol.iterator]();
  return new Promise((t4, o2) => {
    const r2 = [], i2 = () => {
      const { done: l2, value: u2 } = n2.next();
      if (l2) return t4(r2);
      const s2 = new FileReader();
      s2.addEventListener("error", o2), s2.addEventListener("load", () => {
        const t5 = s2.result;
        "string" == typeof t5 && r2.push({ file: u2, result: t5 }), i2();
      }), lt2(u2, e2) ? s2.readAsDataURL(u2) : i2();
    };
    i2();
  });
}
function st2(t3, e2) {
  return Array.from(at2(t3, e2));
}
function ct2(t3) {
  return t3 ? t3.getAdjacentCaret() : null;
}
function ft2(t3, e2) {
  return Array.from(ht2(t3, e2));
}
function at2(t3, e2) {
  return dt2("next", t3, e2);
}
function dt2(t3, e2, n2) {
  const r2 = $getRoot2(), d3 = e2 || r2, g4 = $isElementNode2(d3) ? $getChildCaret2(d3, t3) : $getSiblingCaret2(d3, t3), p3 = pt2(d3), m4 = n2 ? $getAdjacentChildCaret2($getChildCaretOrSelf2($getSiblingCaret2(n2, t3))) : function(t4, e3) {
    const n3 = $t2($getSiblingCaret2(t4, e3));
    return n3 && n3[0];
  }(d3, t3);
  let h4 = p3;
  return makeStepwiseIterator2({ hasNext: (t4) => null !== t4, initial: g4, map: (t4) => ({ depth: h4, node: t4.origin }), step: (t4) => {
    if (t4.isSameNodeCaret(m4)) return null;
    $isChildCaret2(t4) && h4++;
    const e3 = $t2(t4);
    return !e3 || e3[0].isSameNodeCaret(m4) ? null : (h4 += e3[1], e3[0]);
  } });
}
function gt2(t3) {
  const e2 = $t2($getSiblingCaret2(t3, "next"));
  return e2 && [e2[0].origin, e2[1]];
}
function pt2(t3) {
  let e2 = -1;
  for (let n2 = t3; null !== n2; n2 = n2.getParent()) e2++;
  return e2;
}
function mt2(t3) {
  const e2 = $t2($getChildCaretOrSelf2($getSiblingCaret2(t3, "previous")), "root");
  return e2 && e2[0].origin;
}
function ht2(t3, e2) {
  return dt2("previous", t3, e2);
}
function vt2(t3, e2) {
  let n2 = t3;
  for (; null != n2; ) {
    if (n2 instanceof e2) return n2;
    n2 = n2.getParent();
  }
  return null;
}
function yt2(t3) {
  const e2 = wt2(t3, (t4) => $isElementNode2(t4) && !t4.isInline());
  return $isElementNode2(e2) || P3(4, t3.__key), e2;
}
function xt2(t3, e2, n2, o2) {
  const r2 = (t4) => t4 instanceof e2;
  return t3.registerNodeTransform(e2, (t4) => {
    const e3 = ((t5) => {
      const e4 = t5.getChildren();
      for (let t6 = 0; t6 < e4.length; t6++) {
        const n4 = e4[t6];
        if (r2(n4)) return null;
      }
      let n3 = t5, o3 = t5;
      for (; null !== n3; ) if (o3 = n3, n3 = n3.getParent(), r2(n3)) return { child: o3, parent: n3 };
      return null;
    })(t4);
    if (null !== e3) {
      const { child: r3, parent: i2 } = e3;
      if (r3.is(t4)) {
        o2(i2, t4);
        const e4 = r3.getNextSiblings(), l2 = e4.length;
        if (i2.insertAfter(r3), 0 !== l2) {
          const t5 = n2(i2);
          r3.insertAfter(t5);
          for (let n3 = 0; n3 < l2; n3++) t5.append(e4[n3]);
        }
        i2.canBeEmpty() || 0 !== i2.getChildrenSize() || i2.remove();
      }
    }
  });
}
function Et2(t3, e2) {
  const n2 = /* @__PURE__ */ new Map(), o2 = t3._pendingEditorState;
  for (const [t4, o3] of e2._nodeMap) n2.set(t4, $cloneWithProperties2(o3));
  o2 && (o2._nodeMap = n2), t3._dirtyType = 2;
  const r2 = e2._selection;
  $setSelection2(null === r2 ? null : r2.clone());
}
function St2(t3) {
  const o2 = $getSelection2() || $getPreviousSelection2();
  let r2;
  if ($isRangeSelection2(o2)) r2 = $caretFromPoint2(o2.focus, "next");
  else {
    if (null != o2) {
      const t4 = o2.getNodes(), e2 = t4[t4.length - 1];
      e2 && (r2 = $getSiblingCaret2(e2, "next"));
    }
    r2 = r2 || $getChildCaret2($getRoot2(), "previous").getFlipped().insert($createParagraphNode2());
  }
  const c2 = At2(t3, r2), f3 = $getAdjacentChildCaret2(c2), d3 = $isChildCaret2(f3) ? $normalizeCaret2(f3) : c2;
  return $setSelectionFromCaretRange2($getCollapsedCaretRange2(d3)), t3.getLatest();
}
function At2(t3, e2, n2) {
  let o2 = $getCaretInDirection2(e2, "next");
  for (let t4 = o2; t4; t4 = $splitAtPointCaretNext2(t4, n2)) o2 = t4;
  return $isTextPointCaret2(o2) && P3(283), o2.insert(t3.isInline() ? $createParagraphNode2().append(t3) : t3), $getCaretInDirection2($getSiblingCaret2(t3.getLatest(), "next"), e2.direction);
}
function Ct2(t3, e2) {
  const n2 = e2();
  return t3.replace(n2), n2.append(t3), n2;
}
function Lt2(t3, e2) {
  return null !== t3 && Object.getPrototypeOf(t3).constructor.name === e2.name;
}
function bt2(t3, e2) {
  const n2 = [];
  for (let o2 = 0; o2 < t3.length; o2++) {
    const r2 = e2(t3[o2]);
    null !== r2 && n2.push(r2);
  }
  return n2;
}
function Nt2(t3, e2) {
  $getChildCaret2(t3, "next").insert(e2);
}
function Mt2(t3) {
  let e2 = 1;
  if (function() {
    if (void 0 === Pt2) {
      const t4 = document.createElement("div");
      t4.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;", document.body.appendChild(t4);
      const e3 = t4.getBoundingClientRect();
      t4.style.setProperty("zoom", "2"), Pt2 = t4.getBoundingClientRect().width === e3.width, document.body.removeChild(t4);
    }
    return Pt2;
  }()) for (; t3; ) e2 *= Number(window.getComputedStyle(t3).getPropertyValue("zoom")), t3 = t3.parentElement;
  return e2;
}
function Rt2(t3) {
  return null !== t3._parentEditor;
}
function Tt2(t3, e2) {
  return Bt2(t3, e2, null);
}
function Bt2(t3, e2, n2) {
  let r2 = false;
  for (const i2 of Kt2(t3)) e2(i2) ? null !== n2 && n2(i2) : (r2 = true, $isElementNode2(i2) && Bt2(i2, e2, n2 || ((t4) => i2.insertAfter(t4))), i2.remove());
  return r2;
}
function _t2(t3, e2) {
  const n2 = [], r2 = Array.from(t3).reverse();
  for (let t4 = r2.pop(); void 0 !== t4; t4 = r2.pop()) if (e2(t4)) n2.push(t4);
  else if ($isElementNode2(t4)) for (const e3 of Kt2(t4)) r2.push(e3);
  return n2;
}
function kt2(t3) {
  return Ht2($getChildCaret2(t3, "next"));
}
function Kt2(t3) {
  return Ht2($getChildCaret2(t3, "previous"));
}
function Ht2(t3) {
  return makeStepwiseIterator2({ hasNext: $isSiblingCaret2, initial: t3.getAdjacentCaret(), map: (t4) => t4.origin.getLatest(), step: (t4) => t4.getAdjacentCaret() });
}
function Ot2(t3) {
  $rewindSiblingCaret2($getSiblingCaret2(t3, "next")).splice(1, t3.getChildren());
}
function $t2(t3, e2 = "root") {
  let n2 = 0, o2 = t3, r2 = $getAdjacentChildCaret2(o2);
  for (; null === r2; ) {
    if (n2--, r2 = o2.getParentCaret(e2), !r2) return null;
    o2 = r2, r2 = $getAdjacentChildCaret2(o2);
  }
  return r2 && [r2, n2];
}
function Dt2(t3) {
  const e2 = (e3) => $getState2(e3, t3), n2 = (e3, n3) => $setState2(e3, t3, n3);
  return { $get: e2, $set: n2, accessors: [e2, n2], makeGetterMethod: () => function() {
    return e2(this);
  }, makeSetterMethod: () => function(t4) {
    return n2(this, t4);
  }, stateConfig: t3 };
}
var M3, R3, T2, B3, _3, k3, K3, H3, O3, $3, D3, U3, q3, J3, Q3, X3, Y3, Z3, tt2, et2, nt2, ot2, wt2, Pt2;
var init_LexicalUtils_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/utils@0.32.1/node_modules/@lexical/utils/LexicalUtils.prod.mjs"() {
    await init_Lexical_node();
    await init_Lexical_node();
    await init_LexicalSelection_node();
    M3 = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    R3 = M3 && "documentMode" in document ? document.documentMode : null;
    T2 = M3 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    B3 = M3 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    _3 = !(!M3 || !("InputEvent" in window) || R3) && "getTargetRanges" in new window.InputEvent("input");
    k3 = M3 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    K3 = M3 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    H3 = M3 && /Android/.test(navigator.userAgent);
    O3 = M3 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    $3 = M3 && H3 && O3;
    D3 = M3 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !O3;
    U3 = { attributes: true, characterData: true, childList: true, subtree: true };
    q3 = _3;
    J3 = M3;
    Q3 = H3;
    X3 = $3;
    Y3 = T2;
    Z3 = D3;
    tt2 = O3;
    et2 = B3;
    nt2 = K3;
    ot2 = k3;
    wt2 = (t3, e2) => {
      let n2 = t3;
      for (; n2 !== $getRoot2() && null != n2; ) {
        if (e2(n2)) return n2;
        n2 = n2.getParent();
      }
      return null;
    };
    Pt2 = !(et2 || !J3) && void 0;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/utils@0.32.1/node_modules/@lexical/utils/LexicalUtils.node.mjs
var mod3, $descendantsMatching2, $dfs2, $dfsIterator2, $filter2, $findMatchingParent3, $firstToLastIterator2, $getAdjacentCaret2, $getAdjacentSiblingOrParentSiblingCaret4, $getDepth2, $getNearestBlockElementAncestorOrThrow2, $getNearestNodeOfType2, $getNextRightPreorderNode2, $getNextSiblingOrParentSibling2, $insertFirst2, $insertNodeToNearestRoot2, $insertNodeToNearestRootAtCaret2, $isEditorIsNestedEditor2, $lastToFirstIterator2, $restoreEditorState2, $reverseDfs2, $reverseDfsIterator2, $splitNode3, $unwrapAndFilterDescendants2, $unwrapNode2, $wrapNodeInElement2, CAN_USE_BEFORE_INPUT3, CAN_USE_DOM3, IS_ANDROID3, IS_ANDROID_CHROME3, IS_APPLE3, IS_APPLE_WEBKIT3, IS_CHROME3, IS_FIREFOX3, IS_IOS3, IS_SAFARI3, addClassNamesToElement2, calculateZoomLevel2, isBlockDomNode3, isHTMLAnchorElement3, isHTMLElement3, isInlineDomNode3, isMimeType2, makeStateWrapper2, markSelection2, mediaFileReader2, mergeRegister2, objectKlassEquals2, positionNodeOnRange, registerNestedElementResolver2, removeClassNamesFromElement2, selectionAlwaysOnDisplay2;
var init_LexicalUtils_node = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/utils@0.32.1/node_modules/@lexical/utils/LexicalUtils.node.mjs"() {
    mod3 = await (process.env.NODE_ENV !== "production" ? init_LexicalUtils_dev().then(() => LexicalUtils_dev_exports) : init_LexicalUtils_prod().then(() => LexicalUtils_prod_exports));
    $descendantsMatching2 = mod3.$descendantsMatching;
    $dfs2 = mod3.$dfs;
    $dfsIterator2 = mod3.$dfsIterator;
    $filter2 = mod3.$filter;
    $findMatchingParent3 = mod3.$findMatchingParent;
    $firstToLastIterator2 = mod3.$firstToLastIterator;
    $getAdjacentCaret2 = mod3.$getAdjacentCaret;
    $getAdjacentSiblingOrParentSiblingCaret4 = mod3.$getAdjacentSiblingOrParentSiblingCaret;
    $getDepth2 = mod3.$getDepth;
    $getNearestBlockElementAncestorOrThrow2 = mod3.$getNearestBlockElementAncestorOrThrow;
    $getNearestNodeOfType2 = mod3.$getNearestNodeOfType;
    $getNextRightPreorderNode2 = mod3.$getNextRightPreorderNode;
    $getNextSiblingOrParentSibling2 = mod3.$getNextSiblingOrParentSibling;
    $insertFirst2 = mod3.$insertFirst;
    $insertNodeToNearestRoot2 = mod3.$insertNodeToNearestRoot;
    $insertNodeToNearestRootAtCaret2 = mod3.$insertNodeToNearestRootAtCaret;
    $isEditorIsNestedEditor2 = mod3.$isEditorIsNestedEditor;
    $lastToFirstIterator2 = mod3.$lastToFirstIterator;
    $restoreEditorState2 = mod3.$restoreEditorState;
    $reverseDfs2 = mod3.$reverseDfs;
    $reverseDfsIterator2 = mod3.$reverseDfsIterator;
    $splitNode3 = mod3.$splitNode;
    $unwrapAndFilterDescendants2 = mod3.$unwrapAndFilterDescendants;
    $unwrapNode2 = mod3.$unwrapNode;
    $wrapNodeInElement2 = mod3.$wrapNodeInElement;
    CAN_USE_BEFORE_INPUT3 = mod3.CAN_USE_BEFORE_INPUT;
    CAN_USE_DOM3 = mod3.CAN_USE_DOM;
    IS_ANDROID3 = mod3.IS_ANDROID;
    IS_ANDROID_CHROME3 = mod3.IS_ANDROID_CHROME;
    IS_APPLE3 = mod3.IS_APPLE;
    IS_APPLE_WEBKIT3 = mod3.IS_APPLE_WEBKIT;
    IS_CHROME3 = mod3.IS_CHROME;
    IS_FIREFOX3 = mod3.IS_FIREFOX;
    IS_IOS3 = mod3.IS_IOS;
    IS_SAFARI3 = mod3.IS_SAFARI;
    addClassNamesToElement2 = mod3.addClassNamesToElement;
    calculateZoomLevel2 = mod3.calculateZoomLevel;
    isBlockDomNode3 = mod3.isBlockDomNode;
    isHTMLAnchorElement3 = mod3.isHTMLAnchorElement;
    isHTMLElement3 = mod3.isHTMLElement;
    isInlineDomNode3 = mod3.isInlineDomNode;
    isMimeType2 = mod3.isMimeType;
    makeStateWrapper2 = mod3.makeStateWrapper;
    markSelection2 = mod3.markSelection;
    mediaFileReader2 = mod3.mediaFileReader;
    mergeRegister2 = mod3.mergeRegister;
    objectKlassEquals2 = mod3.objectKlassEquals;
    positionNodeOnRange = mod3.positionNodeOnRange;
    registerNestedElementResolver2 = mod3.registerNestedElementResolver;
    removeClassNamesFromElement2 = mod3.removeClassNamesFromElement;
    selectionAlwaysOnDisplay2 = mod3.selectionAlwaysOnDisplay;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/html@0.32.1/node_modules/@lexical/html/LexicalHtml.dev.mjs
var LexicalHtml_dev_exports = {};
__export(LexicalHtml_dev_exports, {
  $generateHtmlFromNodes: () => $generateHtmlFromNodes,
  $generateNodesFromDOM: () => $generateNodesFromDOM
});
function $generateNodesFromDOM(editor, dom2) {
  const elements = dom2.body ? dom2.body.childNodes : [];
  let lexicalNodes = [];
  const allArtificialNodes = [];
  for (let i2 = 0; i2 < elements.length; i2++) {
    const element = elements[i2];
    if (!IGNORE_TAGS.has(element.nodeName)) {
      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);
      if (lexicalNode !== null) {
        lexicalNodes = lexicalNodes.concat(lexicalNode);
      }
    }
  }
  $unwrapArtificialNodes(allArtificialNodes);
  return lexicalNodes;
}
function $generateHtmlFromNodes(editor, selection) {
  if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
    throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  }
  const container = document.createElement("div");
  const root = $getRoot2();
  const topLevelChildren = root.getChildren();
  for (let i2 = 0; i2 < topLevelChildren.length; i2++) {
    const topLevelNode = topLevelChildren[i2];
    $appendNodesToHTML(editor, topLevelNode, container, selection);
  }
  return container.innerHTML;
}
function $appendNodesToHTML(editor, currentNode, parentElement2, selection = null) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null) {
    let clone = $cloneWithProperties2(currentNode);
    clone = $isTextNode2(clone) && selection !== null ? $sliceSelectedTextNodeContent2(selection, clone) : clone;
    target = clone;
  }
  const children = $isElementNode2(target) ? target.getChildren() : [];
  const registeredNode = editor._nodes.get(target.getType());
  let exportOutput;
  if (registeredNode && registeredNode.exportDOM !== void 0) {
    exportOutput = registeredNode.exportDOM(editor, target);
  } else {
    exportOutput = target.exportDOM(editor);
  }
  const {
    element,
    after: after2
  } = exportOutput;
  if (!element) {
    return false;
  }
  const fragment = document.createDocumentFragment();
  for (let i2 = 0; i2 < children.length; i2++) {
    const childNode = children[i2];
    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);
    if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "html")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    if (isHTMLElement3(element) || isDocumentFragment2(element)) {
      element.append(fragment);
    }
    parentElement2.append(element);
    if (after2) {
      const newElement = after2.call(target, element);
      if (newElement) {
        if (isDocumentFragment2(element)) {
          element.replaceChildren(newElement);
        } else {
          element.replaceWith(newElement);
        }
      }
    }
  } else {
    parentElement2.append(fragment);
  }
  return shouldInclude;
}
function getConversionFunction(domNode, editor) {
  const {
    nodeName
  } = domNode;
  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
  let currentConversion = null;
  if (cachedConversions !== void 0) {
    for (const cachedConversion of cachedConversions) {
      const domConversion = cachedConversion(domNode);
      if (domConversion !== null && (currentConversion === null || // Given equal priority, prefer the last registered importer
      // which is typically an application custom node or HTMLConfig['import']
      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {
        currentConversion = domConversion;
      }
    }
  }
  return currentConversion !== null ? currentConversion.conversion : null;
}
function $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
  let lexicalNodes = [];
  if (IGNORE_TAGS.has(node.nodeName)) {
    return lexicalNodes;
  }
  let currentLexicalNode = null;
  const transformFunction = getConversionFunction(node, editor);
  const transformOutput = transformFunction ? transformFunction(node) : null;
  let postTransform = null;
  if (transformOutput !== null) {
    postTransform = transformOutput.after;
    const transformNodes = transformOutput.node;
    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
    if (currentLexicalNode !== null) {
      for (const [, forChildFunction] of forChildMap) {
        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
        if (!currentLexicalNode) {
          break;
        }
      }
      if (currentLexicalNode) {
        lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
      }
    }
    if (transformOutput.forChild != null) {
      forChildMap.set(node.nodeName, transformOutput.forChild);
    }
  }
  const children = node.childNodes;
  let childLexicalNodes = [];
  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot2(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode2(currentLexicalNode) || hasBlockAncestorLexicalNode;
  for (let i2 = 0; i2 < children.length; i2++) {
    childLexicalNodes.push(...$createNodesFromDOM(children[i2], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));
  }
  if (postTransform != null) {
    childLexicalNodes = postTransform(childLexicalNodes);
  }
  if (isBlockDomNode3(node)) {
    if (!hasBlockAncestorLexicalNodeForChildren) {
      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode2);
    } else {
      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {
        const artificialNode = new ArtificialNode__DO_NOT_USE2();
        allArtificialNodes.push(artificialNode);
        return artificialNode;
      });
    }
  }
  if (currentLexicalNode == null) {
    if (childLexicalNodes.length > 0) {
      lexicalNodes = lexicalNodes.concat(childLexicalNodes);
    } else {
      if (isBlockDomNode3(node) && isDomNodeBetweenTwoInlineNodes(node)) {
        lexicalNodes = lexicalNodes.concat($createLineBreakNode2());
      }
    }
  } else {
    if ($isElementNode2(currentLexicalNode)) {
      currentLexicalNode.append(...childLexicalNodes);
    }
  }
  return lexicalNodes;
}
function wrapContinuousInlines(domNode, nodes, createWrapperFn) {
  const textAlign = domNode.style.textAlign;
  const out = [];
  let continuousInlines = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if ($isBlockElementNode2(node)) {
      if (textAlign && !node.getFormat()) {
        node.setFormat(textAlign);
      }
      out.push(node);
    } else {
      continuousInlines.push(node);
      if (i2 === nodes.length - 1 || i2 < nodes.length - 1 && $isBlockElementNode2(nodes[i2 + 1])) {
        const wrapper = createWrapperFn();
        wrapper.setFormat(textAlign);
        wrapper.append(...continuousInlines);
        out.push(wrapper);
        continuousInlines = [];
      }
    }
  }
  return out;
}
function $unwrapArtificialNodes(allArtificialNodes) {
  for (const node of allArtificialNodes) {
    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE2) {
      node.insertAfter($createLineBreakNode2());
    }
  }
  for (const node of allArtificialNodes) {
    const children = node.getChildren();
    for (const child of children) {
      node.insertBefore(child);
    }
    node.remove();
  }
}
function isDomNodeBetweenTwoInlineNodes(node) {
  if (node.nextSibling == null || node.previousSibling == null) {
    return false;
  }
  return isInlineDomNode2(node.nextSibling) && isInlineDomNode2(node.previousSibling);
}
var IGNORE_TAGS;
var init_LexicalHtml_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/html@0.32.1/node_modules/@lexical/html/LexicalHtml.dev.mjs"() {
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/html@0.32.1/node_modules/@lexical/html/LexicalHtml.prod.mjs
var LexicalHtml_prod_exports = {};
__export(LexicalHtml_prod_exports, {
  $generateHtmlFromNodes: () => m2,
  $generateNodesFromDOM: () => h2
});
function h2(e2, n2) {
  const t3 = n2.body ? n2.body.childNodes : [];
  let o2 = [];
  const l2 = [];
  for (let n3 = 0; n3 < t3.length; n3++) {
    const r2 = t3[n3];
    if (!x2.has(r2.nodeName)) {
      const n4 = y2(r2, e2, l2, false);
      null !== n4 && (o2 = o2.concat(n4));
    }
  }
  return function(e3) {
    for (const n3 of e3) n3.getNextSibling() instanceof ArtificialNode__DO_NOT_USE2 && n3.insertAfter($createLineBreakNode2());
    for (const n3 of e3) {
      const e4 = n3.getChildren();
      for (const t4 of e4) n3.insertBefore(t4);
      n3.remove();
    }
  }(l2), o2;
}
function m2(e2, n2) {
  if ("undefined" == typeof document || "undefined" == typeof window && void 0 === global.window) throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const t3 = document.createElement("div"), l2 = $getRoot2().getChildren();
  for (let o2 = 0; o2 < l2.length; o2++) {
    g2(e2, l2[o2], t3, n2);
  }
  return t3.innerHTML;
}
function g2(t3, o2, c2, u2 = null) {
  let f3 = null === u2 || o2.isSelected(u2);
  const a2 = $isElementNode2(o2) && o2.excludeFromCopy("html");
  let d3 = o2;
  if (null !== u2) {
    let n2 = $cloneWithProperties2(o2);
    n2 = $isTextNode2(n2) && null !== u2 ? $sliceSelectedTextNodeContent2(u2, n2) : n2, d3 = n2;
  }
  const p3 = $isElementNode2(d3) ? d3.getChildren() : [], h4 = t3._nodes.get(d3.getType());
  let m4;
  m4 = h4 && void 0 !== h4.exportDOM ? h4.exportDOM(t3, d3) : d3.exportDOM(t3);
  const { element: x4, after: y4 } = m4;
  if (!x4) return false;
  const w4 = document.createDocumentFragment();
  for (let e2 = 0; e2 < p3.length; e2++) {
    const n2 = p3[e2], r2 = g2(t3, n2, w4, u2);
    !f3 && $isElementNode2(o2) && r2 && o2.extractWithChild(n2, u2, "html") && (f3 = true);
  }
  if (f3 && !a2) {
    if ((isHTMLElement3(x4) || isDocumentFragment2(x4)) && x4.append(w4), c2.append(x4), y4) {
      const e2 = y4.call(d3, x4);
      e2 && (isDocumentFragment2(x4) ? x4.replaceChildren(e2) : x4.replaceWith(e2));
    }
  } else c2.append(w4);
  return f3;
}
function y2(e2, n2, o2, r2, i2 = /* @__PURE__ */ new Map(), s2) {
  let h4 = [];
  if (x2.has(e2.nodeName)) return h4;
  let m4 = null;
  const g4 = function(e3, n3) {
    const { nodeName: t3 } = e3, o3 = n3._htmlConversions.get(t3.toLowerCase());
    let l2 = null;
    if (void 0 !== o3) for (const n4 of o3) {
      const t4 = n4(e3);
      null !== t4 && (null === l2 || (l2.priority || 0) <= (t4.priority || 0)) && (l2 = t4);
    }
    return null !== l2 ? l2.conversion : null;
  }(e2, n2), b3 = g4 ? g4(e2) : null;
  let C4 = null;
  if (null !== b3) {
    C4 = b3.after;
    const n3 = b3.node;
    if (m4 = Array.isArray(n3) ? n3[n3.length - 1] : n3, null !== m4) {
      for (const [, e3] of i2) if (m4 = e3(m4, s2), !m4) break;
      m4 && h4.push(...Array.isArray(n3) ? n3 : [m4]);
    }
    null != b3.forChild && i2.set(e2.nodeName, b3.forChild);
  }
  const S4 = e2.childNodes;
  let v4 = [];
  const N5 = (null == m4 || !$isRootOrShadowRoot2(m4)) && (null != m4 && $isBlockElementNode2(m4) || r2);
  for (let e3 = 0; e3 < S4.length; e3++) v4.push(...y2(S4[e3], n2, o2, N5, new Map(i2), m4));
  return null != C4 && (v4 = C4(v4)), isBlockDomNode3(e2) && (v4 = w2(e2, v4, N5 ? () => {
    const e3 = new ArtificialNode__DO_NOT_USE2();
    return o2.push(e3), e3;
  } : $createParagraphNode2)), null == m4 ? v4.length > 0 ? h4 = h4.concat(v4) : isBlockDomNode3(e2) && function(e3) {
    if (null == e3.nextSibling || null == e3.previousSibling) return false;
    return isInlineDomNode2(e3.nextSibling) && isInlineDomNode2(e3.previousSibling);
  }(e2) && (h4 = h4.concat($createLineBreakNode2())) : $isElementNode2(m4) && m4.append(...v4), h4;
}
function w2(e2, n2, t3) {
  const o2 = e2.style.textAlign, l2 = [];
  let r2 = [];
  for (let e3 = 0; e3 < n2.length; e3++) {
    const i2 = n2[e3];
    if ($isBlockElementNode2(i2)) o2 && !i2.getFormat() && i2.setFormat(o2), l2.push(i2);
    else if (r2.push(i2), e3 === n2.length - 1 || e3 < n2.length - 1 && $isBlockElementNode2(n2[e3 + 1])) {
      const e4 = t3();
      e4.setFormat(o2), e4.append(...r2), l2.push(e4), r2 = [];
    }
  }
  return l2;
}
var x2;
var init_LexicalHtml_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/html@0.32.1/node_modules/@lexical/html/LexicalHtml.prod.mjs"() {
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    x2 = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/html@0.32.1/node_modules/@lexical/html/LexicalHtml.node.mjs
var mod4, $generateHtmlFromNodes2, $generateNodesFromDOM2;
var init_LexicalHtml_node = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/html@0.32.1/node_modules/@lexical/html/LexicalHtml.node.mjs"() {
    mod4 = await (process.env.NODE_ENV !== "production" ? init_LexicalHtml_dev().then(() => LexicalHtml_dev_exports) : init_LexicalHtml_prod().then(() => LexicalHtml_prod_exports));
    $generateHtmlFromNodes2 = mod4.$generateHtmlFromNodes;
    $generateNodesFromDOM2 = mod4.$generateNodesFromDOM;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/link@0.32.1/node_modules/@lexical/link/LexicalLink.dev.mjs
var LexicalLink_dev_exports = {};
__export(LexicalLink_dev_exports, {
  $createAutoLinkNode: () => $createAutoLinkNode,
  $createLinkNode: () => $createLinkNode,
  $isAutoLinkNode: () => $isAutoLinkNode,
  $isLinkNode: () => $isLinkNode,
  $toggleLink: () => $toggleLink,
  AutoLinkNode: () => AutoLinkNode,
  LinkNode: () => LinkNode,
  TOGGLE_LINK_COMMAND: () => TOGGLE_LINK_COMMAND,
  formatUrl: () => formatUrl,
  toggleLink: () => toggleLink
});
function formatDevErrorMessage4(message) {
  throw new Error(message);
}
function $convertAnchorElement(domNode) {
  let node = null;
  if (isHTMLAnchorElement3(domNode)) {
    const content = domNode.textContent;
    if (content !== null && content !== "" || domNode.children.length > 0) {
      node = $createLinkNode(domNode.getAttribute("href") || "", {
        rel: domNode.getAttribute("rel"),
        target: domNode.getAttribute("target"),
        title: domNode.getAttribute("title")
      });
    }
  }
  return {
    node
  };
}
function $createLinkNode(url = "", attributes2) {
  return $applyNodeReplacement2(new LinkNode(url, attributes2));
}
function $isLinkNode(node) {
  return node instanceof LinkNode;
}
function $createAutoLinkNode(url = "", attributes2) {
  return $applyNodeReplacement2(new AutoLinkNode(url, attributes2));
}
function $isAutoLinkNode(node) {
  return node instanceof AutoLinkNode;
}
function $getPointNode(point, offset) {
  if (point.type === "element") {
    const node = point.getNode();
    if (!$isElementNode2(node)) {
      formatDevErrorMessage4(`$getPointNode: element point is not an ElementNode`);
    }
    const childNode = node.getChildren()[point.offset + offset];
    return childNode || null;
  }
  return null;
}
function $withSelectedNodes($fn) {
  const initialSelection = $getSelection2();
  if (!$isRangeSelection2(initialSelection)) {
    return $fn();
  }
  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);
  const isBackwards = normalized.isBackward();
  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);
  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);
  const rval = $fn();
  if (anchorNode || focusNode) {
    const updatedSelection = $getSelection2();
    if ($isRangeSelection2(updatedSelection)) {
      const finalSelection = updatedSelection.clone();
      if (anchorNode) {
        const anchorParent = anchorNode.getParent();
        if (anchorParent) {
          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), "element");
        }
      }
      if (focusNode) {
        const focusParent = focusNode.getParent();
        if (focusParent) {
          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), "element");
        }
      }
      $setSelection2($normalizeSelection__EXPERIMENTAL(finalSelection));
    }
  }
  return rval;
}
function $toggleLink(url, attributes2 = {}) {
  const {
    target,
    title
  } = attributes2;
  const rel = attributes2.rel === void 0 ? "noreferrer" : attributes2.rel;
  const selection = $getSelection2();
  if (selection === null || !$isRangeSelection2(selection) && !$isNodeSelection2(selection)) {
    return;
  }
  if ($isNodeSelection2(selection)) {
    const nodes2 = selection.getNodes();
    if (nodes2.length === 0) {
      return;
    }
    nodes2.forEach((node) => {
      if (url === null) {
        const linkParent = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
        if (linkParent) {
          linkParent.insertBefore(node);
          if (linkParent.getChildren().length === 0) {
            linkParent.remove();
          }
        }
      } else {
        const existingLink = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
        if (existingLink) {
          existingLink.setURL(url);
          if (target !== void 0) {
            existingLink.setTarget(target);
          }
          if (rel !== void 0) {
            existingLink.setRel(rel);
          }
        } else {
          const linkNode = $createLinkNode(url, {
            rel,
            target
          });
          node.insertBefore(linkNode);
          linkNode.append(node);
        }
      }
    });
    return;
  }
  const nodes = selection.extract();
  if (url === null) {
    nodes.forEach((node) => {
      const parentLink = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
      if (parentLink) {
        const children = parentLink.getChildren();
        for (let i2 = 0; i2 < children.length; i2++) {
          parentLink.insertBefore(children[i2]);
        }
        parentLink.remove();
      }
    });
    return;
  }
  const updatedNodes = /* @__PURE__ */ new Set();
  const updateLinkNode = (linkNode) => {
    if (updatedNodes.has(linkNode.getKey())) {
      return;
    }
    updatedNodes.add(linkNode.getKey());
    linkNode.setURL(url);
    if (target !== void 0) {
      linkNode.setTarget(target);
    }
    if (rel !== void 0) {
      linkNode.setRel(rel);
    }
    if (title !== void 0) {
      linkNode.setTitle(title);
    }
  };
  if (nodes.length === 1) {
    const firstNode = nodes[0];
    const linkNode = $getAncestor3(firstNode, $isLinkNode);
    if (linkNode !== null) {
      return updateLinkNode(linkNode);
    }
  }
  $withSelectedNodes(() => {
    let linkNode = null;
    for (const node of nodes) {
      if (!node.isAttached()) {
        continue;
      }
      const parentLinkNode = $getAncestor3(node, $isLinkNode);
      if (parentLinkNode) {
        updateLinkNode(parentLinkNode);
        continue;
      }
      if ($isElementNode2(node)) {
        if (!node.isInline()) {
          continue;
        }
        if ($isLinkNode(node)) {
          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {
            updateLinkNode(node);
            linkNode = node;
            continue;
          }
          for (const child of node.getChildren()) {
            node.insertBefore(child);
          }
          node.remove();
          continue;
        }
      }
      const prevLinkNode = node.getPreviousSibling();
      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {
        prevLinkNode.append(node);
        continue;
      }
      linkNode = $createLinkNode(url, {
        rel,
        target,
        title
      });
      node.insertAfter(linkNode);
      linkNode.append(node);
    }
  });
}
function $getAncestor3(node, predicate) {
  let parent = node;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
function formatUrl(url) {
  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {
    return url;
  } else if (url.match(/^[/#.]/)) {
    return url;
  } else if (url.includes("@")) {
    return `mailto:${url}`;
  } else if (PHONE_NUMBER_REGEX.test(url)) {
    return `tel:${url}`;
  }
  return `https://${url}`;
}
var SUPPORTED_URL_PROTOCOLS, LinkNode, AutoLinkNode, TOGGLE_LINK_COMMAND, toggleLink, PHONE_NUMBER_REGEX;
var init_LexicalLink_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/link@0.32.1/node_modules/@lexical/link/LexicalLink.dev.mjs"() {
    await init_LexicalUtils_node();
    await init_Lexical_node();
    SUPPORTED_URL_PROTOCOLS = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
    LinkNode = class _LinkNode extends ElementNode2 {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "link";
      }
      static clone(node) {
        return new _LinkNode(node.__url, {
          rel: node.__rel,
          target: node.__target,
          title: node.__title
        }, node.__key);
      }
      constructor(url = "", attributes2 = {}, key2) {
        super(key2);
        const {
          target = null,
          rel = null,
          title = null
        } = attributes2;
        this.__url = url;
        this.__target = target;
        this.__rel = rel;
        this.__title = title;
      }
      createDOM(config) {
        const element = document.createElement("a");
        this.updateLinkDOM(null, element, config);
        addClassNamesToElement2(element, config.theme.link);
        return element;
      }
      updateLinkDOM(prevNode, anchor, config) {
        if (isHTMLAnchorElement3(anchor)) {
          if (!prevNode || prevNode.__url !== this.__url) {
            anchor.href = this.sanitizeUrl(this.__url);
          }
          for (const attr of ["target", "rel", "title"]) {
            const key2 = `__${attr}`;
            const value = this[key2];
            if (!prevNode || prevNode[key2] !== value) {
              if (value) {
                anchor[attr] = value;
              } else {
                anchor.removeAttribute(attr);
              }
            }
          }
        }
      }
      updateDOM(prevNode, anchor, config) {
        this.updateLinkDOM(prevNode, anchor, config);
        return false;
      }
      static importDOM() {
        return {
          a: (node) => ({
            conversion: $convertAnchorElement,
            priority: 1
          })
        };
      }
      static importJSON(serializedNode) {
        return $createLinkNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);
      }
      sanitizeUrl(url) {
        url = formatUrl(url);
        try {
          const parsedUrl = new URL(formatUrl(url));
          if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {
            return "about:blank";
          }
        } catch (_unused) {
          return url;
        }
        return url;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          rel: this.getRel(),
          target: this.getTarget(),
          title: this.getTitle(),
          url: this.getURL()
        };
      }
      getURL() {
        return this.getLatest().__url;
      }
      setURL(url) {
        const writable = this.getWritable();
        writable.__url = url;
        return writable;
      }
      getTarget() {
        return this.getLatest().__target;
      }
      setTarget(target) {
        const writable = this.getWritable();
        writable.__target = target;
        return writable;
      }
      getRel() {
        return this.getLatest().__rel;
      }
      setRel(rel) {
        const writable = this.getWritable();
        writable.__rel = rel;
        return writable;
      }
      getTitle() {
        return this.getLatest().__title;
      }
      setTitle(title) {
        const writable = this.getWritable();
        writable.__title = title;
        return writable;
      }
      insertNewAfter(_5, restoreSelection = true) {
        const linkNode = $createLinkNode(this.__url, {
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        this.insertAfter(linkNode, restoreSelection);
        return linkNode;
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
      canBeEmpty() {
        return false;
      }
      isInline() {
        return true;
      }
      extractWithChild(child, selection, destination) {
        if (!$isRangeSelection2(selection)) {
          return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
      }
      isEmailURI() {
        return this.__url.startsWith("mailto:");
      }
      isWebSiteURI() {
        return this.__url.startsWith("https://") || this.__url.startsWith("http://");
      }
    };
    AutoLinkNode = class _AutoLinkNode extends LinkNode {
      /** @internal */
      /** Indicates whether the autolink was ever unlinked. **/
      constructor(url = "", attributes2 = {}, key2) {
        super(url, attributes2, key2);
        this.__isUnlinked = attributes2.isUnlinked !== void 0 && attributes2.isUnlinked !== null ? attributes2.isUnlinked : false;
      }
      static getType() {
        return "autolink";
      }
      static clone(node) {
        return new _AutoLinkNode(node.__url, {
          isUnlinked: node.__isUnlinked,
          rel: node.__rel,
          target: node.__target,
          title: node.__title
        }, node.__key);
      }
      getIsUnlinked() {
        return this.__isUnlinked;
      }
      setIsUnlinked(value) {
        const self = this.getWritable();
        self.__isUnlinked = value;
        return self;
      }
      createDOM(config) {
        if (this.__isUnlinked) {
          return document.createElement("span");
        } else {
          return super.createDOM(config);
        }
      }
      updateDOM(prevNode, anchor, config) {
        return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;
      }
      static importJSON(serializedNode) {
        return $createAutoLinkNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);
      }
      static importDOM() {
        return null;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          isUnlinked: this.__isUnlinked
        };
      }
      insertNewAfter(selection, restoreSelection = true) {
        const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
        if ($isElementNode2(element)) {
          const linkNode = $createAutoLinkNode(this.__url, {
            isUnlinked: this.__isUnlinked,
            rel: this.__rel,
            target: this.__target,
            title: this.__title
          });
          element.append(linkNode);
          return linkNode;
        }
        return null;
      }
    };
    TOGGLE_LINK_COMMAND = createCommand2("TOGGLE_LINK_COMMAND");
    toggleLink = $toggleLink;
    PHONE_NUMBER_REGEX = /^\+?[0-9\s()-]{5,}$/;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/link@0.32.1/node_modules/@lexical/link/LexicalLink.prod.mjs
var LexicalLink_prod_exports = {};
__export(LexicalLink_prod_exports, {
  $createAutoLinkNode: () => U4,
  $createLinkNode: () => d2,
  $isAutoLinkNode: () => O4,
  $isLinkNode: () => p2,
  $toggleLink: () => v2,
  AutoLinkNode: () => m3,
  LinkNode: () => g3,
  TOGGLE_LINK_COMMAND: () => k4,
  formatUrl: () => S2,
  toggleLink: () => T3
});
function f2(t3) {
  let r2 = null;
  if (isHTMLAnchorElement3(t3)) {
    const e2 = t3.textContent;
    (null !== e2 && "" !== e2 || t3.children.length > 0) && (r2 = d2(t3.getAttribute("href") || "", { rel: t3.getAttribute("rel"), target: t3.getAttribute("target"), title: t3.getAttribute("title") }));
  }
  return { node: r2 };
}
function d2(t3 = "", e2) {
  return $applyNodeReplacement2(new g3(t3, e2));
}
function p2(t3) {
  return t3 instanceof g3;
}
function U4(t3 = "", e2) {
  return $applyNodeReplacement2(new m3(t3, e2));
}
function O4(t3) {
  return t3 instanceof m3;
}
function N3(t3, e2) {
  if ("element" === t3.type) {
    const r2 = t3.getNode();
    $isElementNode2(r2) || function(t4, ...e3) {
      const r3 = new URL("https://lexical.dev/docs/error"), n2 = new URLSearchParams();
      n2.append("code", t4);
      for (const t5 of e3) n2.append("v", t5);
      throw r3.search = n2.toString(), Error(`Minified Lexical error #${t4}; visit ${r3.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    }(252);
    return r2.getChildren()[t3.offset + e2] || null;
  }
  return null;
}
function v2(t3, e2 = {}) {
  const { target: n2, title: i2 } = e2, l2 = void 0 === e2.rel ? "noreferrer" : e2.rel, h4 = $getSelection2();
  if (null === h4 || !$isRangeSelection2(h4) && !$isNodeSelection2(h4)) return;
  if ($isNodeSelection2(h4)) {
    const e3 = h4.getNodes();
    if (0 === e3.length) return;
    return void e3.forEach((e4) => {
      if (null === t3) {
        const t4 = $findMatchingParent3(e4, (t5) => !O4(t5) && p2(t5));
        t4 && (t4.insertBefore(e4), 0 === t4.getChildren().length && t4.remove());
      } else {
        const i3 = $findMatchingParent3(e4, (t4) => !O4(t4) && p2(t4));
        if (i3) i3.setURL(t3), void 0 !== n2 && i3.setTarget(n2), void 0 !== l2 && i3.setRel(l2);
        else {
          const r2 = d2(t3, { rel: l2, target: n2 });
          e4.insertBefore(r2), r2.append(e4);
        }
      }
    });
  }
  const g4 = h4.extract();
  if (null === t3) return void g4.forEach((t4) => {
    const e3 = $findMatchingParent3(t4, (t5) => !O4(t5) && p2(t5));
    if (e3) {
      const t5 = e3.getChildren();
      for (let r2 = 0; r2 < t5.length; r2++) e3.insertBefore(t5[r2]);
      e3.remove();
    }
  });
  const f3 = /* @__PURE__ */ new Set(), m4 = (e3) => {
    f3.has(e3.getKey()) || (f3.add(e3.getKey()), e3.setURL(t3), void 0 !== n2 && e3.setTarget(n2), void 0 !== l2 && e3.setRel(l2), void 0 !== i2 && e3.setTitle(i2));
  };
  if (1 === g4.length) {
    const t4 = x3(g4[0], p2);
    if (null !== t4) return m4(t4);
  }
  !function(t4) {
    const e3 = $getSelection2();
    if (!$isRangeSelection2(e3)) return t4();
    const r2 = $normalizeSelection__EXPERIMENTAL(e3), n3 = r2.isBackward(), i3 = N3(r2.anchor, n3 ? -1 : 0), l3 = N3(r2.focus, n3 ? 0 : -1), o2 = t4();
    if (i3 || l3) {
      const t5 = $getSelection2();
      if ($isRangeSelection2(t5)) {
        const e4 = t5.clone();
        if (i3) {
          const t6 = i3.getParent();
          t6 && e4.anchor.set(t6.getKey(), i3.getIndexWithinParent() + (n3 ? 1 : 0), "element");
        }
        if (l3) {
          const t6 = l3.getParent();
          t6 && e4.focus.set(t6.getKey(), l3.getIndexWithinParent() + (n3 ? 0 : 1), "element");
        }
        $setSelection2($normalizeSelection__EXPERIMENTAL(e4));
      }
    }
  }(() => {
    let e3 = null;
    for (const r2 of g4) {
      if (!r2.isAttached()) continue;
      const s2 = x3(r2, p2);
      if (s2) {
        m4(s2);
        continue;
      }
      if ($isElementNode2(r2)) {
        if (!r2.isInline()) continue;
        if (p2(r2)) {
          if (!(O4(r2) || null !== e3 && e3.getParentOrThrow().isParentOf(r2))) {
            m4(r2), e3 = r2;
            continue;
          }
          for (const t4 of r2.getChildren()) r2.insertBefore(t4);
          r2.remove();
          continue;
        }
      }
      const u2 = r2.getPreviousSibling();
      p2(u2) && u2.is(e3) ? u2.append(r2) : (e3 = d2(t3, { rel: l2, target: n2, title: i2 }), r2.insertAfter(e3), e3.append(r2));
    }
  });
}
function x3(t3, e2) {
  let r2 = t3;
  for (; null !== r2 && null !== r2.getParent() && !e2(r2); ) r2 = r2.getParentOrThrow();
  return e2(r2) ? r2 : null;
}
function S2(t3) {
  return t3.match(/^[a-z][a-z0-9+.-]*:/i) || t3.match(/^[/#.]/) ? t3 : t3.includes("@") ? `mailto:${t3}` : L3.test(t3) ? `tel:${t3}` : `https://${t3}`;
}
var h3, g3, m3, k4, T3, L3;
var init_LexicalLink_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/link@0.32.1/node_modules/@lexical/link/LexicalLink.prod.mjs"() {
    await init_LexicalUtils_node();
    await init_Lexical_node();
    h3 = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
    g3 = class _g extends ElementNode2 {
      static getType() {
        return "link";
      }
      static clone(t3) {
        return new _g(t3.__url, { rel: t3.__rel, target: t3.__target, title: t3.__title }, t3.__key);
      }
      constructor(t3 = "", e2 = {}, r2) {
        super(r2);
        const { target: n2 = null, rel: i2 = null, title: s2 = null } = e2;
        this.__url = t3, this.__target = n2, this.__rel = i2, this.__title = s2;
      }
      createDOM(e2) {
        const r2 = document.createElement("a");
        return this.updateLinkDOM(null, r2, e2), addClassNamesToElement2(r2, e2.theme.link), r2;
      }
      updateLinkDOM(t3, r2, n2) {
        if (isHTMLAnchorElement3(r2)) {
          t3 && t3.__url === this.__url || (r2.href = this.sanitizeUrl(this.__url));
          for (const e2 of ["target", "rel", "title"]) {
            const n3 = `__${e2}`, i2 = this[n3];
            t3 && t3[n3] === i2 || (i2 ? r2[e2] = i2 : r2.removeAttribute(e2));
          }
        }
      }
      updateDOM(t3, e2, r2) {
        return this.updateLinkDOM(t3, e2, r2), false;
      }
      static importDOM() {
        return { a: (t3) => ({ conversion: f2, priority: 1 }) };
      }
      static importJSON(t3) {
        return d2().updateFromJSON(t3);
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setURL(t3.url).setRel(t3.rel || null).setTarget(t3.target || null).setTitle(t3.title || null);
      }
      sanitizeUrl(t3) {
        t3 = S2(t3);
        try {
          const e2 = new URL(S2(t3));
          if (!h3.has(e2.protocol)) return "about:blank";
        } catch (e2) {
          return t3;
        }
        return t3;
      }
      exportJSON() {
        return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), url: this.getURL() };
      }
      getURL() {
        return this.getLatest().__url;
      }
      setURL(t3) {
        const e2 = this.getWritable();
        return e2.__url = t3, e2;
      }
      getTarget() {
        return this.getLatest().__target;
      }
      setTarget(t3) {
        const e2 = this.getWritable();
        return e2.__target = t3, e2;
      }
      getRel() {
        return this.getLatest().__rel;
      }
      setRel(t3) {
        const e2 = this.getWritable();
        return e2.__rel = t3, e2;
      }
      getTitle() {
        return this.getLatest().__title;
      }
      setTitle(t3) {
        const e2 = this.getWritable();
        return e2.__title = t3, e2;
      }
      insertNewAfter(t3, e2 = true) {
        const r2 = d2(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
        return this.insertAfter(r2, e2), r2;
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
      canBeEmpty() {
        return false;
      }
      isInline() {
        return true;
      }
      extractWithChild(t3, e2, r2) {
        if (!$isRangeSelection2(e2)) return false;
        const n2 = e2.anchor.getNode(), i2 = e2.focus.getNode();
        return this.isParentOf(n2) && this.isParentOf(i2) && e2.getTextContent().length > 0;
      }
      isEmailURI() {
        return this.__url.startsWith("mailto:");
      }
      isWebSiteURI() {
        return this.__url.startsWith("https://") || this.__url.startsWith("http://");
      }
    };
    m3 = class _m extends g3 {
      constructor(t3 = "", e2 = {}, r2) {
        super(t3, e2, r2), this.__isUnlinked = void 0 !== e2.isUnlinked && null !== e2.isUnlinked && e2.isUnlinked;
      }
      static getType() {
        return "autolink";
      }
      static clone(t3) {
        return new _m(t3.__url, { isUnlinked: t3.__isUnlinked, rel: t3.__rel, target: t3.__target, title: t3.__title }, t3.__key);
      }
      getIsUnlinked() {
        return this.__isUnlinked;
      }
      setIsUnlinked(t3) {
        const e2 = this.getWritable();
        return e2.__isUnlinked = t3, e2;
      }
      createDOM(t3) {
        return this.__isUnlinked ? document.createElement("span") : super.createDOM(t3);
      }
      updateDOM(t3, e2, r2) {
        return super.updateDOM(t3, e2, r2) || t3.__isUnlinked !== this.__isUnlinked;
      }
      static importJSON(t3) {
        return U4().updateFromJSON(t3);
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setIsUnlinked(t3.isUnlinked || false);
      }
      static importDOM() {
        return null;
      }
      exportJSON() {
        return { ...super.exportJSON(), isUnlinked: this.__isUnlinked };
      }
      insertNewAfter(t3, e2 = true) {
        const r2 = this.getParentOrThrow().insertNewAfter(t3, e2);
        if ($isElementNode2(r2)) {
          const t4 = U4(this.__url, { isUnlinked: this.__isUnlinked, rel: this.__rel, target: this.__target, title: this.__title });
          return r2.append(t4), t4;
        }
        return null;
      }
    };
    k4 = createCommand2("TOGGLE_LINK_COMMAND");
    T3 = v2;
    L3 = /^\+?[0-9\s()-]{5,}$/;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/list@0.32.1/node_modules/@lexical/list/LexicalList.dev.mjs
var LexicalList_dev_exports = {};
__export(LexicalList_dev_exports, {
  $createListItemNode: () => $createListItemNode,
  $createListNode: () => $createListNode,
  $getListDepth: () => $getListDepth,
  $handleListInsertParagraph: () => $handleListInsertParagraph,
  $insertList: () => $insertList,
  $isListItemNode: () => $isListItemNode,
  $isListNode: () => $isListNode,
  $removeList: () => $removeList,
  INSERT_CHECK_LIST_COMMAND: () => INSERT_CHECK_LIST_COMMAND,
  INSERT_ORDERED_LIST_COMMAND: () => INSERT_ORDERED_LIST_COMMAND,
  INSERT_UNORDERED_LIST_COMMAND: () => INSERT_UNORDERED_LIST_COMMAND,
  ListItemNode: () => ListItemNode,
  ListNode: () => ListNode,
  REMOVE_LIST_COMMAND: () => REMOVE_LIST_COMMAND,
  insertList: () => insertList,
  registerCheckList: () => registerCheckList,
  registerList: () => registerList,
  registerListStrictIndentTransform: () => registerListStrictIndentTransform,
  removeList: () => removeList
});
function formatDevErrorMessage5(message) {
  throw new Error(message);
}
function $getListDepth(listNode) {
  let depth = 1;
  let parent = listNode.getParent();
  while (parent != null) {
    if ($isListItemNode(parent)) {
      const parentList = parent.getParent();
      if ($isListNode(parentList)) {
        depth++;
        parent = parentList.getParent();
        continue;
      }
      {
        formatDevErrorMessage5(`A ListItemNode must have a ListNode for a parent.`);
      }
    }
    return depth;
  }
  return depth;
}
function $getTopListNode(listItem) {
  let list = listItem.getParent();
  if (!$isListNode(list)) {
    {
      formatDevErrorMessage5(`A ListItemNode must have a ListNode for a parent.`);
    }
  }
  let parent = list;
  while (parent !== null) {
    parent = parent.getParent();
    if ($isListNode(parent)) {
      list = parent;
    }
  }
  return list;
}
function $getAllListItems(node) {
  let listItemNodes = [];
  const listChildren = node.getChildren().filter($isListItemNode);
  for (let i2 = 0; i2 < listChildren.length; i2++) {
    const listItemNode = listChildren[i2];
    const firstChild = listItemNode.getFirstChild();
    if ($isListNode(firstChild)) {
      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
    } else {
      listItemNodes.push(listItemNode);
    }
  }
  return listItemNodes;
}
function isNestedListNode(node) {
  return $isListItemNode(node) && $isListNode(node.getFirstChild());
}
function $removeHighestEmptyListParent(sublist) {
  let emptyListPtr = sublist;
  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
    const parent = emptyListPtr.getParent();
    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {
      break;
    }
    emptyListPtr = parent;
  }
  emptyListPtr.remove();
}
function $wrapInListItem(node) {
  const listItemWrapper = $createListItemNode();
  return listItemWrapper.append(node);
}
function $isSelectingEmptyListItem(anchorNode, nodes) {
  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
}
function $insertList(listType) {
  const selection = $getSelection2();
  if (selection !== null) {
    let nodes = selection.getNodes();
    if ($isRangeSelection2(selection)) {
      const anchorAndFocus = selection.getStartEndPoints();
      if (!(anchorAndFocus !== null)) {
        formatDevErrorMessage5(`insertList: anchor should be defined`);
      }
      const [anchor] = anchorAndFocus;
      const anchorNode = anchor.getNode();
      const anchorNodeParent = anchorNode.getParent();
      if ($isRootOrShadowRoot2(anchorNode)) {
        const firstChild = anchorNode.getFirstChild();
        if (firstChild) {
          nodes = firstChild.selectStart().getNodes();
        } else {
          const paragraph = $createParagraphNode2();
          anchorNode.append(paragraph);
          nodes = paragraph.select().getNodes();
        }
      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {
        const list = $createListNode(listType);
        if ($isRootOrShadowRoot2(anchorNodeParent)) {
          anchorNode.replace(list);
          const listItem = $createListItemNode();
          if ($isElementNode2(anchorNode)) {
            listItem.setFormat(anchorNode.getFormatType());
            listItem.setIndent(anchorNode.getIndent());
          }
          list.append(listItem);
        } else if ($isListItemNode(anchorNode)) {
          const parent = anchorNode.getParentOrThrow();
          append3(list, parent.getChildren());
          parent.replace(list);
        }
        return;
      }
    }
    const handled = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isElementNode2(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {
        $createListOrMerge(node, listType);
        continue;
      }
      let parent = $isLeafNode2(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;
      while (parent != null) {
        const parentKey = parent.getKey();
        if ($isListNode(parent)) {
          if (!handled.has(parentKey)) {
            const newListNode = $createListNode(listType);
            append3(newListNode, parent.getChildren());
            parent.replace(newListNode);
            handled.add(parentKey);
          }
          break;
        } else {
          const nextParent = parent.getParent();
          if ($isRootOrShadowRoot2(nextParent) && !handled.has(parentKey)) {
            handled.add(parentKey);
            $createListOrMerge(parent, listType);
            break;
          }
          parent = nextParent;
        }
      }
    }
  }
}
function append3(node, nodesToAppend) {
  node.splice(node.getChildrenSize(), 0, nodesToAppend);
}
function $createListOrMerge(node, listType) {
  if ($isListNode(node)) {
    return node;
  }
  const previousSibling2 = node.getPreviousSibling();
  const nextSibling2 = node.getNextSibling();
  const listItem = $createListItemNode();
  append3(listItem, node.getChildren());
  let targetList;
  if ($isListNode(previousSibling2) && listType === previousSibling2.getListType()) {
    previousSibling2.append(listItem);
    if ($isListNode(nextSibling2) && listType === nextSibling2.getListType()) {
      append3(previousSibling2, nextSibling2.getChildren());
      nextSibling2.remove();
    }
    targetList = previousSibling2;
  } else if ($isListNode(nextSibling2) && listType === nextSibling2.getListType()) {
    nextSibling2.getFirstChildOrThrow().insertBefore(listItem);
    targetList = nextSibling2;
  } else {
    const list = $createListNode(listType);
    list.append(listItem);
    node.replace(list);
    targetList = list;
  }
  listItem.setFormat(node.getFormatType());
  listItem.setIndent(node.getIndent());
  node.remove();
  return targetList;
}
function mergeLists(list1, list2) {
  const listItem1 = list1.getLastChild();
  const listItem2 = list2.getFirstChild();
  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
    listItem2.remove();
  }
  const toMerge = list2.getChildren();
  if (toMerge.length > 0) {
    list1.append(...toMerge);
  }
  list2.remove();
}
function $removeList() {
  const selection = $getSelection2();
  if ($isRangeSelection2(selection)) {
    const listNodes = /* @__PURE__ */ new Set();
    const nodes = selection.getNodes();
    const anchorNode = selection.anchor.getNode();
    if ($isSelectingEmptyListItem(anchorNode, nodes)) {
      listNodes.add($getTopListNode(anchorNode));
    } else {
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if ($isLeafNode2(node)) {
          const listItemNode = $getNearestNodeOfType2(node, ListItemNode);
          if (listItemNode != null) {
            listNodes.add($getTopListNode(listItemNode));
          }
        }
      }
    }
    for (const listNode of listNodes) {
      let insertionPoint = listNode;
      const listItems = $getAllListItems(listNode);
      for (const listItemNode of listItems) {
        const paragraph = $createParagraphNode2().setTextStyle(selection.style).setTextFormat(selection.format);
        append3(paragraph, listItemNode.getChildren());
        insertionPoint.insertAfter(paragraph);
        insertionPoint = paragraph;
        if (listItemNode.__key === selection.anchor.key) {
          $setPointFromCaret2(selection.anchor, $normalizeCaret2($getChildCaret2(paragraph, "next")));
        }
        if (listItemNode.__key === selection.focus.key) {
          $setPointFromCaret2(selection.focus, $normalizeCaret2($getChildCaret2(paragraph, "next")));
        }
        listItemNode.remove();
      }
      listNode.remove();
    }
  }
}
function updateChildrenListItemValue(list) {
  const isNotChecklist = list.getListType() !== "check";
  let value = list.getStart();
  for (const child of list.getChildren()) {
    if ($isListItemNode(child)) {
      if (child.getValue() !== value) {
        child.setValue(value);
      }
      if (isNotChecklist && child.getLatest().__checked != null) {
        child.setChecked(void 0);
      }
      if (!$isListNode(child.getFirstChild())) {
        value++;
      }
    }
  }
}
function mergeNextSiblingListIfSameType(list) {
  const nextSibling2 = list.getNextSibling();
  if ($isListNode(nextSibling2) && list.getListType() === nextSibling2.getListType()) {
    mergeLists(list, nextSibling2);
  }
}
function $handleIndent(listItemNode) {
  const removed = /* @__PURE__ */ new Set();
  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
    return;
  }
  const parent = listItemNode.getParent();
  const nextSibling2 = listItemNode.getNextSibling();
  const previousSibling2 = listItemNode.getPreviousSibling();
  if (isNestedListNode(nextSibling2) && isNestedListNode(previousSibling2)) {
    const innerList = previousSibling2.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
      const nextInnerList = nextSibling2.getFirstChild();
      if ($isListNode(nextInnerList)) {
        const children = nextInnerList.getChildren();
        append3(innerList, children);
        nextSibling2.remove();
        removed.add(nextSibling2.getKey());
      }
    }
  } else if (isNestedListNode(nextSibling2)) {
    const innerList = nextSibling2.getFirstChild();
    if ($isListNode(innerList)) {
      const firstChild = innerList.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(listItemNode);
      }
    }
  } else if (isNestedListNode(previousSibling2)) {
    const innerList = previousSibling2.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
    }
  } else {
    if ($isListNode(parent)) {
      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());
      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());
      newListItem.append(newList);
      newList.append(listItemNode);
      if (previousSibling2) {
        previousSibling2.insertAfter(newListItem);
      } else if (nextSibling2) {
        nextSibling2.insertBefore(newListItem);
      } else {
        parent.append(newListItem);
      }
    }
  }
}
function $handleOutdent(listItemNode) {
  if (isNestedListNode(listItemNode)) {
    return;
  }
  const parentList = listItemNode.getParent();
  const grandparentListItem = parentList ? parentList.getParent() : void 0;
  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
    const firstChild = parentList ? parentList.getFirstChild() : void 0;
    const lastChild = parentList ? parentList.getLastChild() : void 0;
    if (listItemNode.is(firstChild)) {
      grandparentListItem.insertBefore(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else if (listItemNode.is(lastChild)) {
      grandparentListItem.insertAfter(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else {
      const listType = parentList.getListType();
      const previousSiblingsListItem = $createListItemNode();
      const previousSiblingsList = $createListNode(listType);
      previousSiblingsListItem.append(previousSiblingsList);
      listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
      const nextSiblingsListItem = $createListItemNode();
      const nextSiblingsList = $createListNode(listType);
      nextSiblingsListItem.append(nextSiblingsList);
      append3(nextSiblingsList, listItemNode.getNextSiblings());
      grandparentListItem.insertBefore(previousSiblingsListItem);
      grandparentListItem.insertAfter(nextSiblingsListItem);
      grandparentListItem.replace(listItemNode);
    }
  }
}
function $handleListInsertParagraph() {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection) || !selection.isCollapsed()) {
    return false;
  }
  const anchor = selection.anchor.getNode();
  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {
    return false;
  }
  const topListNode = $getTopListNode(anchor);
  const parent = anchor.getParent();
  if (!$isListNode(parent)) {
    formatDevErrorMessage5(`A ListItemNode must have a ListNode for a parent.`);
  }
  const grandparent = parent.getParent();
  let replacementNode;
  if ($isRootOrShadowRoot2(grandparent)) {
    replacementNode = $createParagraphNode2();
    topListNode.insertAfter(replacementNode);
  } else if ($isListItemNode(grandparent)) {
    replacementNode = $createListItemNode();
    grandparent.insertAfter(replacementNode);
  } else {
    return false;
  }
  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();
  const nextSiblings = anchor.getNextSiblings();
  if (nextSiblings.length > 0) {
    const newList = $createListNode(parent.getListType());
    if ($isListItemNode(replacementNode)) {
      const newListItem = $createListItemNode();
      newListItem.append(newList);
      replacementNode.insertAfter(newListItem);
    } else {
      replacementNode.insertAfter(newList);
    }
    newList.append(...nextSiblings);
  }
  $removeHighestEmptyListParent(anchor);
  return true;
}
function normalizeClassNames3(...classNames2) {
  const rval = [];
  for (const className of classNames2) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
function applyMarkerStyles(dom2, node, prevNode) {
  const styles = getStyleObjectFromCSS2(node.__textStyle);
  for (const k5 in styles) {
    dom2.style.setProperty(`--listitem-marker-${k5}`, styles[k5]);
  }
  if (prevNode) {
    for (const k5 in getStyleObjectFromCSS2(prevNode.__textStyle)) {
      if (!(k5 in styles)) {
        dom2.style.removeProperty(`--listitem-marker-${k5}`);
      }
    }
  }
}
function $setListItemThemeClassNames(dom2, editorThemeClasses, node) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  const listItemClassName = listTheme ? listTheme.listitem : void 0;
  let nestedListItemClassName;
  if (listTheme && listTheme.nested) {
    nestedListItemClassName = listTheme.nested.listitem;
  }
  if (listItemClassName !== void 0) {
    classesToAdd.push(...normalizeClassNames3(listItemClassName));
  }
  if (listTheme) {
    const parentNode = node.getParent();
    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
    const checked = node.getChecked();
    if (!isCheckList || checked) {
      classesToRemove.push(listTheme.listitemUnchecked);
    }
    if (!isCheckList || !checked) {
      classesToRemove.push(listTheme.listitemChecked);
    }
    if (isCheckList) {
      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
    }
  }
  if (nestedListItemClassName !== void 0) {
    const nestedListItemClasses = normalizeClassNames3(nestedListItemClassName);
    if (node.getChildren().some((child) => $isListNode(child))) {
      classesToAdd.push(...nestedListItemClasses);
    } else {
      classesToRemove.push(...nestedListItemClasses);
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement2(dom2, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement2(dom2, ...classesToAdd);
  }
}
function updateListItemChecked(dom2, listItemNode, prevListItemNode, listNode) {
  if ($isListNode(listItemNode.getFirstChild())) {
    dom2.removeAttribute("role");
    dom2.removeAttribute("tabIndex");
    dom2.removeAttribute("aria-checked");
  } else {
    dom2.setAttribute("role", "checkbox");
    dom2.setAttribute("tabIndex", "-1");
    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
      dom2.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
    }
  }
}
function $convertListItemElement(domNode) {
  const isGitHubCheckList = domNode.classList.contains("task-list-item");
  if (isGitHubCheckList) {
    for (const child of domNode.children) {
      if (child.tagName === "INPUT") {
        return $convertCheckboxInput(child);
      }
    }
  }
  const ariaCheckedAttr = domNode.getAttribute("aria-checked");
  const checked = ariaCheckedAttr === "true" ? true : ariaCheckedAttr === "false" ? false : void 0;
  return {
    node: $createListItemNode(checked)
  };
}
function $convertCheckboxInput(domNode) {
  const isCheckboxInput = domNode.getAttribute("type") === "checkbox";
  if (!isCheckboxInput) {
    return {
      node: null
    };
  }
  const checked = domNode.hasAttribute("checked");
  return {
    node: $createListItemNode(checked)
  };
}
function $createListItemNode(checked) {
  return $applyNodeReplacement2(new ListItemNode(void 0, checked));
}
function $isListItemNode(node) {
  return node instanceof ListItemNode;
}
function $setListThemeClassNames(dom2, editorThemeClasses, node) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  if (listTheme !== void 0) {
    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
    const listDepth = $getListDepth(node) - 1;
    const normalizedListDepth = listDepth % listLevelsClassNames.length;
    const listLevelClassName = listLevelsClassNames[normalizedListDepth];
    const listClassName = listTheme[node.__tag];
    let nestedListClassName;
    const nestedListTheme = listTheme.nested;
    const checklistClassName = listTheme.checklist;
    if (nestedListTheme !== void 0 && nestedListTheme.list) {
      nestedListClassName = nestedListTheme.list;
    }
    if (listClassName !== void 0) {
      classesToAdd.push(listClassName);
    }
    if (checklistClassName !== void 0 && node.__listType === "check") {
      classesToAdd.push(checklistClassName);
    }
    if (listLevelClassName !== void 0) {
      classesToAdd.push(...normalizeClassNames3(listLevelClassName));
      for (let i2 = 0; i2 < listLevelsClassNames.length; i2++) {
        if (i2 !== normalizedListDepth) {
          classesToRemove.push(node.__tag + i2);
        }
      }
    }
    if (nestedListClassName !== void 0) {
      const nestedListItemClasses = normalizeClassNames3(nestedListClassName);
      if (listDepth > 1) {
        classesToAdd.push(...nestedListItemClasses);
      } else {
        classesToRemove.push(...nestedListItemClasses);
      }
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement2(dom2, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement2(dom2, ...classesToAdd);
  }
}
function $normalizeChildren(nodes) {
  const normalizedListItems = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if ($isListItemNode(node)) {
      normalizedListItems.push(node);
      const children = node.getChildren();
      if (children.length > 1) {
        children.forEach((child) => {
          if ($isListNode(child)) {
            normalizedListItems.push($wrapInListItem(child));
          }
        });
      }
    } else {
      normalizedListItems.push($wrapInListItem(node));
    }
  }
  return normalizedListItems;
}
function isDomChecklist(domNode) {
  if (domNode.getAttribute("__lexicallisttype") === "check" || // is github checklist
  domNode.classList.contains("contains-task-list")) {
    return true;
  }
  for (const child of domNode.childNodes) {
    if (isHTMLElement3(child) && child.hasAttribute("aria-checked")) {
      return true;
    }
  }
  return false;
}
function $convertListNode(domNode) {
  const nodeName = domNode.nodeName.toLowerCase();
  let node = null;
  if (nodeName === "ol") {
    const start = domNode.start;
    node = $createListNode("number", start);
  } else if (nodeName === "ul") {
    if (isDomChecklist(domNode)) {
      node = $createListNode("check");
    } else {
      node = $createListNode("bullet");
    }
  }
  return {
    after: $normalizeChildren,
    node
  };
}
function $createListNode(listType = "number", start = 1) {
  return $applyNodeReplacement2(new ListNode(listType, start));
}
function $isListNode(node) {
  return node instanceof ListNode;
}
function registerCheckList(editor) {
  return mergeRegister2(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {
    $insertList("check");
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
    return handleArrowUpOrDown(event, editor, false);
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
    return handleArrowUpOrDown(event, editor, true);
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ESCAPE_COMMAND2, () => {
    const activeItem = getActiveCheckListItem();
    if (activeItem != null) {
      const rootElement = editor.getRootElement();
      if (rootElement != null) {
        rootElement.focus();
      }
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_SPACE_COMMAND2, (event) => {
    const activeItem = getActiveCheckListItem();
    if (activeItem != null && editor.isEditable()) {
      editor.update(() => {
        const listItemNode = $getNearestNodeFromDOMNode2(activeItem);
        if ($isListItemNode(listItemNode)) {
          event.preventDefault();
          listItemNode.toggleChecked();
        }
      });
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (event) => {
    return editor.getEditorState().read(() => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection) && selection.isCollapsed()) {
        const {
          anchor
        } = selection;
        const isElement = anchor.type === "element";
        if (isElement || anchor.offset === 0) {
          const anchorNode = anchor.getNode();
          const elementNode = $findMatchingParent3(anchorNode, (node) => $isElementNode2(node) && !node.isInline());
          if ($isListItemNode(elementNode)) {
            const parent = elementNode.getParent();
            if ($isListNode(parent) && parent.getListType() === "check" && (isElement || elementNode.getFirstDescendant() === anchorNode)) {
              const domNode = editor.getElementByKey(elementNode.__key);
              if (domNode != null && document.activeElement !== domNode) {
                domNode.focus();
                event.preventDefault();
                return true;
              }
            }
          }
        }
      }
      return false;
    });
  }, COMMAND_PRIORITY_LOW2), editor.registerRootListener((rootElement, prevElement) => {
    if (rootElement !== null) {
      rootElement.addEventListener("click", handleClick);
      rootElement.addEventListener("pointerdown", handlePointerDown);
    }
    if (prevElement !== null) {
      prevElement.removeEventListener("click", handleClick);
      prevElement.removeEventListener("pointerdown", handlePointerDown);
    }
  }));
}
function handleCheckItemEvent(event, callback) {
  const target = event.target;
  if (!isHTMLElement3(target)) {
    return;
  }
  const firstChild = target.firstChild;
  if (isHTMLElement3(firstChild) && (firstChild.tagName === "UL" || firstChild.tagName === "OL")) {
    return;
  }
  const parentNode = target.parentNode;
  if (!parentNode || parentNode.__lexicalListType !== "check") {
    return;
  }
  const rect = target.getBoundingClientRect();
  const pageX = event.pageX / calculateZoomLevel2(target);
  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, "::before") : {
    width: "0px"
  };
  const beforeWidthInPixels = parseFloat(beforeStyles.width);
  if (target.dir === "rtl" ? pageX < rect.right && pageX > rect.right - beforeWidthInPixels : pageX > rect.left && pageX < rect.left + beforeWidthInPixels) {
    callback();
  }
}
function handleClick(event) {
  handleCheckItemEvent(event, () => {
    if (isHTMLElement3(event.target)) {
      const domNode = event.target;
      const editor = getNearestEditorFromDOMNode2(domNode);
      if (editor != null && editor.isEditable()) {
        editor.update(() => {
          const node = $getNearestNodeFromDOMNode2(domNode);
          if ($isListItemNode(node)) {
            domNode.focus();
            node.toggleChecked();
          }
        });
      }
    }
  });
}
function handlePointerDown(event) {
  handleCheckItemEvent(event, () => {
    event.preventDefault();
  });
}
function getActiveCheckListItem() {
  const activeElement = document.activeElement;
  return isHTMLElement3(activeElement) && activeElement.tagName === "LI" && activeElement.parentNode != null && // @ts-ignore internal field
  activeElement.parentNode.__lexicalListType === "check" ? activeElement : null;
}
function findCheckListItemSibling(node, backward) {
  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
  let parent = node;
  while (sibling == null && $isListItemNode(parent)) {
    parent = parent.getParentOrThrow().getParent();
    if (parent != null) {
      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
    }
  }
  while ($isListItemNode(sibling)) {
    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();
    if (!$isListNode(firstChild)) {
      return sibling;
    }
    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();
  }
  return null;
}
function handleArrowUpOrDown(event, editor, backward) {
  const activeItem = getActiveCheckListItem();
  if (activeItem != null) {
    editor.update(() => {
      const listItem = $getNearestNodeFromDOMNode2(activeItem);
      if (!$isListItemNode(listItem)) {
        return;
      }
      const nextListItem = findCheckListItemSibling(listItem, backward);
      if (nextListItem != null) {
        nextListItem.selectStart();
        const dom2 = editor.getElementByKey(nextListItem.__key);
        if (dom2 != null) {
          event.preventDefault();
          setTimeout(() => {
            dom2.focus();
          }, 0);
        }
      }
    });
  }
  return false;
}
function registerList(editor) {
  const removeListener = mergeRegister2(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {
    $insertList("number");
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {
    $insertList("bullet");
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(REMOVE_LIST_COMMAND, () => {
    $removeList();
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW2), editor.registerNodeTransform(ListItemNode, (node) => {
    const firstChild = node.getFirstChild();
    if (firstChild) {
      if ($isTextNode2(firstChild)) {
        const style = firstChild.getStyle();
        const format = firstChild.getFormat();
        if (node.getTextStyle() !== style) {
          node.setTextStyle(style);
        }
        if (node.getTextFormat() !== format) {
          node.setTextFormat(format);
        }
      }
    } else {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {
        node.setTextStyle(selection.style).setTextFormat(selection.format);
      }
    }
  }), editor.registerNodeTransform(TextNode2, (node) => {
    const listItemParentNode = node.getParent();
    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {
      const style = node.getStyle();
      const format = node.getFormat();
      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {
        listItemParentNode.setTextStyle(style).setTextFormat(format);
      }
    }
  }));
  return removeListener;
}
function registerListStrictIndentTransform(editor) {
  const $formatListIndentStrict = (listItemNode) => {
    const listNode = listItemNode.getParent();
    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {
      return;
    }
    const startingListItemNode = $findMatchingParent3(listItemNode, (node) => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));
    if (startingListItemNode === null && listItemNode.getIndent() > 0) {
      listItemNode.setIndent(0);
    } else if ($isListItemNode(startingListItemNode)) {
      const prevListItemNode = startingListItemNode.getPreviousSibling();
      if ($isListItemNode(prevListItemNode)) {
        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);
        const endListNode = endListItemNode.getParent();
        if ($isListNode(endListNode)) {
          const prevDepth = $getListDepth(endListNode);
          const depth = $getListDepth(listNode);
          if (prevDepth + 1 < depth) {
            listItemNode.setIndent(prevDepth);
          }
        }
      }
    }
  };
  const $processListWithStrictIndent = (listNode) => {
    const queue = [listNode];
    while (queue.length > 0) {
      const node = queue.shift();
      if (!$isListNode(node)) {
        continue;
      }
      for (const child of node.getChildren()) {
        if ($isListItemNode(child)) {
          $formatListIndentStrict(child);
          const firstChild = child.getFirstChild();
          if ($isListNode(firstChild)) {
            queue.push(firstChild);
          }
        }
      }
    }
  };
  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);
}
function $findChildrenEndListItemNode(listItemNode) {
  let current = listItemNode;
  let firstChild = current.getFirstChild();
  while ($isListNode(firstChild)) {
    const lastChild = firstChild.getLastChild();
    if ($isListItemNode(lastChild)) {
      current = lastChild;
      firstChild = current.getFirstChild();
    } else {
      break;
    }
  }
  return current;
}
function insertList(editor, listType) {
  editor.update(() => $insertList(listType));
}
function removeList(editor) {
  editor.update(() => $removeList());
}
var ListItemNode, ListNode, TAG_TO_LIST_TYPE, INSERT_CHECK_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, REMOVE_LIST_COMMAND;
var init_LexicalList_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/list@0.32.1/node_modules/@lexical/list/LexicalList.dev.mjs"() {
    await init_LexicalUtils_node();
    await init_Lexical_node();
    await init_LexicalSelection_node();
    ListItemNode = class _ListItemNode extends ElementNode2 {
      /** @internal */
      /** @internal */
      static getType() {
        return "listitem";
      }
      static clone(node) {
        return new _ListItemNode(node.__value, node.__checked, node.__key);
      }
      constructor(value, checked, key2) {
        super(key2);
        this.__value = value === void 0 ? 1 : value;
        this.__checked = checked;
      }
      createDOM(config) {
        const element = document.createElement("li");
        this.updateListItemDOM(null, element, config);
        return element;
      }
      updateListItemDOM(prevNode, dom2, config) {
        const parent = this.getParent();
        if ($isListNode(parent) && parent.getListType() === "check") {
          updateListItemChecked(dom2, this, prevNode);
        }
        dom2.value = this.__value;
        $setListItemThemeClassNames(dom2, config.theme, this);
        const prevStyle = prevNode ? prevNode.__style : "";
        const nextStyle = this.__style;
        if (prevStyle !== nextStyle) {
          if (nextStyle === "") {
            dom2.removeAttribute("style");
          } else {
            dom2.style.cssText = nextStyle;
          }
        }
        applyMarkerStyles(dom2, this, prevNode);
      }
      updateDOM(prevNode, dom2, config) {
        const element = dom2;
        this.updateListItemDOM(prevNode, element, config);
        return false;
      }
      static transform() {
        return (node) => {
          if (!$isListItemNode(node)) {
            formatDevErrorMessage5(`node is not a ListItemNode`);
          }
          if (node.__checked == null) {
            return;
          }
          const parent = node.getParent();
          if ($isListNode(parent)) {
            if (parent.getListType() !== "check" && node.getChecked() != null) {
              node.setChecked(void 0);
            }
          }
        };
      }
      static importDOM() {
        return {
          li: () => ({
            conversion: $convertListItemElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        return $createListItemNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);
      }
      exportDOM(editor) {
        const element = this.createDOM(editor._config);
        const formatType = this.getFormatType();
        if (formatType) {
          element.style.textAlign = formatType;
        }
        const direction = this.getDirection();
        if (direction) {
          element.dir = direction;
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          checked: this.getChecked(),
          value: this.getValue()
        };
      }
      append(...nodes) {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if ($isElementNode2(node) && this.canMergeWith(node)) {
            const children = node.getChildren();
            this.append(...children);
            node.remove();
          } else {
            super.append(node);
          }
        }
        return this;
      }
      replace(replaceWithNode, includeChildren) {
        if ($isListItemNode(replaceWithNode)) {
          return super.replace(replaceWithNode);
        }
        this.setIndent(0);
        const list = this.getParentOrThrow();
        if (!$isListNode(list)) {
          return replaceWithNode;
        }
        if (list.__first === this.getKey()) {
          list.insertBefore(replaceWithNode);
        } else if (list.__last === this.getKey()) {
          list.insertAfter(replaceWithNode);
        } else {
          const newList = $createListNode(list.getListType());
          let nextSibling2 = this.getNextSibling();
          while (nextSibling2) {
            const nodeToAppend = nextSibling2;
            nextSibling2 = nextSibling2.getNextSibling();
            newList.append(nodeToAppend);
          }
          list.insertAfter(replaceWithNode);
          replaceWithNode.insertAfter(newList);
        }
        if (includeChildren) {
          if (!$isElementNode2(replaceWithNode)) {
            formatDevErrorMessage5(`includeChildren should only be true for ElementNodes`);
          }
          this.getChildren().forEach((child) => {
            replaceWithNode.append(child);
          });
        }
        this.remove();
        if (list.getChildrenSize() === 0) {
          list.remove();
        }
        return replaceWithNode;
      }
      insertAfter(node, restoreSelection = true) {
        const listNode = this.getParentOrThrow();
        if (!$isListNode(listNode)) {
          {
            formatDevErrorMessage5(`insertAfter: list node is not parent of list item node`);
          }
        }
        if ($isListItemNode(node)) {
          return super.insertAfter(node, restoreSelection);
        }
        const siblings = this.getNextSiblings();
        listNode.insertAfter(node, restoreSelection);
        if (siblings.length !== 0) {
          const newListNode = $createListNode(listNode.getListType());
          siblings.forEach((sibling) => newListNode.append(sibling));
          node.insertAfter(newListNode, restoreSelection);
        }
        return node;
      }
      remove(preserveEmptyParent) {
        const prevSibling = this.getPreviousSibling();
        const nextSibling2 = this.getNextSibling();
        super.remove(preserveEmptyParent);
        if (prevSibling && nextSibling2 && isNestedListNode(prevSibling) && isNestedListNode(nextSibling2)) {
          mergeLists(prevSibling.getFirstChild(), nextSibling2.getFirstChild());
          nextSibling2.remove();
        }
      }
      insertNewAfter(_5, restoreSelection = true) {
        const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : void 0);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart(selection) {
        const paragraph = $createParagraphNode2();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        const listNode = this.getParentOrThrow();
        const listNodeParent = listNode.getParentOrThrow();
        const isIndented = $isListItemNode(listNodeParent);
        if (listNode.getChildrenSize() === 1) {
          if (isIndented) {
            listNode.remove();
            listNodeParent.select();
          } else {
            listNode.insertBefore(paragraph);
            listNode.remove();
            const anchor = selection.anchor;
            const focus = selection.focus;
            const key2 = paragraph.getKey();
            if (anchor.type === "element" && anchor.getNode().is(this)) {
              anchor.set(key2, anchor.offset, "element");
            }
            if (focus.type === "element" && focus.getNode().is(this)) {
              focus.set(key2, focus.offset, "element");
            }
          }
        } else {
          listNode.insertBefore(paragraph);
          this.remove();
        }
        return true;
      }
      getValue() {
        const self = this.getLatest();
        return self.__value;
      }
      setValue(value) {
        const self = this.getWritable();
        self.__value = value;
        return self;
      }
      getChecked() {
        const self = this.getLatest();
        let listType;
        const parent = this.getParent();
        if ($isListNode(parent)) {
          listType = parent.getListType();
        }
        return listType === "check" ? Boolean(self.__checked) : void 0;
      }
      setChecked(checked) {
        const self = this.getWritable();
        self.__checked = checked;
        return self;
      }
      toggleChecked() {
        const self = this.getWritable();
        return self.setChecked(!self.__checked);
      }
      getIndent() {
        const parent = this.getParent();
        if (parent === null || !this.isAttached()) {
          return this.getLatest().__indent;
        }
        let listNodeParent = parent.getParentOrThrow();
        let indentLevel = 0;
        while ($isListItemNode(listNodeParent)) {
          listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
          indentLevel++;
        }
        return indentLevel;
      }
      setIndent(indent) {
        if (!(typeof indent === "number")) {
          formatDevErrorMessage5(`Invalid indent value.`);
        }
        indent = Math.floor(indent);
        if (!(indent >= 0)) {
          formatDevErrorMessage5(`Indent value must be non-negative.`);
        }
        let currentIndent = this.getIndent();
        while (currentIndent !== indent) {
          if (currentIndent < indent) {
            $handleIndent(this);
            currentIndent++;
          } else {
            $handleOutdent(this);
            currentIndent--;
          }
        }
        return this;
      }
      /** @deprecated @internal */
      canInsertAfter(node) {
        return $isListItemNode(node);
      }
      /** @deprecated @internal */
      canReplaceWith(replacement) {
        return $isListItemNode(replacement);
      }
      canMergeWith(node) {
        return $isListItemNode(node) || $isParagraphNode2(node);
      }
      extractWithChild(child, selection) {
        if (!$isRangeSelection2(selection)) {
          return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
      }
      isParentRequired() {
        return true;
      }
      createParentElementNode() {
        return $createListNode("bullet");
      }
      canMergeWhenEmpty() {
        return true;
      }
    };
    ListNode = class _ListNode extends ElementNode2 {
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "list";
      }
      static clone(node) {
        const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];
        return new _ListNode(listType, node.__start, node.__key);
      }
      constructor(listType = "number", start = 1, key2) {
        super(key2);
        const _listType = TAG_TO_LIST_TYPE[listType] || listType;
        this.__listType = _listType;
        this.__tag = _listType === "number" ? "ol" : "ul";
        this.__start = start;
      }
      getTag() {
        return this.__tag;
      }
      setListType(type) {
        const writable = this.getWritable();
        writable.__listType = type;
        writable.__tag = type === "number" ? "ol" : "ul";
        return writable;
      }
      getListType() {
        return this.__listType;
      }
      getStart() {
        return this.__start;
      }
      setStart(start) {
        const self = this.getWritable();
        self.__start = start;
        return self;
      }
      // View
      createDOM(config, _editor) {
        const tag = this.__tag;
        const dom2 = document.createElement(tag);
        if (this.__start !== 1) {
          dom2.setAttribute("start", String(this.__start));
        }
        dom2.__lexicalListType = this.__listType;
        $setListThemeClassNames(dom2, config.theme, this);
        return dom2;
      }
      updateDOM(prevNode, dom2, config) {
        if (prevNode.__tag !== this.__tag) {
          return true;
        }
        $setListThemeClassNames(dom2, config.theme, this);
        return false;
      }
      static transform() {
        return (node) => {
          if (!$isListNode(node)) {
            formatDevErrorMessage5(`node is not a ListNode`);
          }
          mergeNextSiblingListIfSameType(node);
          updateChildrenListItemValue(node);
        };
      }
      static importDOM() {
        return {
          ol: () => ({
            conversion: $convertListNode,
            priority: 0
          }),
          ul: () => ({
            conversion: $convertListNode,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        return $createListNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);
      }
      exportDOM(editor) {
        const element = this.createDOM(editor._config, editor);
        if (isHTMLElement3(element)) {
          if (this.__start !== 1) {
            element.setAttribute("start", String(this.__start));
          }
          if (this.__listType === "check") {
            element.setAttribute("__lexicalListType", "check");
          }
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          listType: this.getListType(),
          start: this.getStart(),
          tag: this.getTag()
        };
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
      splice(start, deleteCount, nodesToInsert) {
        let listItemNodesToInsert = nodesToInsert;
        for (let i2 = 0; i2 < nodesToInsert.length; i2++) {
          const node = nodesToInsert[i2];
          if (!$isListItemNode(node)) {
            if (listItemNodesToInsert === nodesToInsert) {
              listItemNodesToInsert = [...nodesToInsert];
            }
            listItemNodesToInsert[i2] = $createListItemNode().append($isElementNode2(node) && !($isListNode(node) || node.isInline()) ? $createTextNode2(node.getTextContent()) : node);
          }
        }
        return super.splice(start, deleteCount, listItemNodesToInsert);
      }
      extractWithChild(child) {
        return $isListItemNode(child);
      }
    };
    TAG_TO_LIST_TYPE = {
      ol: "number",
      ul: "bullet"
    };
    INSERT_CHECK_LIST_COMMAND = createCommand2("INSERT_CHECK_LIST_COMMAND");
    INSERT_UNORDERED_LIST_COMMAND = createCommand2("INSERT_UNORDERED_LIST_COMMAND");
    INSERT_ORDERED_LIST_COMMAND = createCommand2("INSERT_ORDERED_LIST_COMMAND");
    REMOVE_LIST_COMMAND = createCommand2("REMOVE_LIST_COMMAND");
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/list@0.32.1/node_modules/@lexical/list/LexicalList.prod.mjs
var LexicalList_prod_exports = {};
__export(LexicalList_prod_exports, {
  $createListItemNode: () => Y4,
  $createListNode: () => st3,
  $getListDepth: () => I4,
  $handleListInsertParagraph: () => H4,
  $insertList: () => W4,
  $isListItemNode: () => Z4,
  $isListNode: () => ot3,
  $removeList: () => z4,
  INSERT_CHECK_LIST_COMMAND: () => lt3,
  INSERT_ORDERED_LIST_COMMAND: () => pt3,
  INSERT_UNORDERED_LIST_COMMAND: () => ft3,
  ListItemNode: () => j4,
  ListNode: () => tt3,
  REMOVE_LIST_COMMAND: () => mt3,
  insertList: () => Ct3,
  registerCheckList: () => ct3,
  registerList: () => _t3,
  registerListStrictIndentTransform: () => yt3,
  removeList: () => Tt3
});
function w3(t3, ...e2) {
  const n2 = new URL("https://lexical.dev/docs/error"), r2 = new URLSearchParams();
  r2.append("code", t3);
  for (const t4 of e2) r2.append("v", t4);
  throw n2.search = r2.toString(), Error(`Minified Lexical error #${t3}; visit ${n2.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function I4(t3) {
  let e2 = 1, n2 = t3.getParent();
  for (; null != n2; ) {
    if (Z4(n2)) {
      const t4 = n2.getParent();
      if (ot3(t4)) {
        e2++, n2 = t4.getParent();
        continue;
      }
      w3(40);
    }
    return e2;
  }
  return e2;
}
function D4(t3) {
  let e2 = t3.getParent();
  ot3(e2) || w3(40);
  let n2 = e2;
  for (; null !== n2; ) n2 = n2.getParent(), ot3(n2) && (e2 = n2);
  return e2;
}
function M4(t3) {
  let e2 = [];
  const n2 = t3.getChildren().filter(Z4);
  for (let t4 = 0; t4 < n2.length; t4++) {
    const r2 = n2[t4], i2 = r2.getFirstChild();
    ot3(i2) ? e2 = e2.concat(M4(i2)) : e2.push(r2);
  }
  return e2;
}
function R4(t3) {
  return Z4(t3) && ot3(t3.getFirstChild());
}
function J4(t3) {
  return Y4().append(t3);
}
function B4(t3, e2) {
  return Z4(t3) && (0 === e2.length || 1 === e2.length && t3.is(e2[0]) && 0 === t3.getChildrenSize());
}
function W4(t3) {
  const e2 = $getSelection2();
  if (null !== e2) {
    let n2 = e2.getNodes();
    if ($isRangeSelection2(e2)) {
      const r3 = e2.getStartEndPoints();
      null === r3 && w3(143);
      const [i2] = r3, s2 = i2.getNode(), o2 = s2.getParent();
      if ($isRootOrShadowRoot2(s2)) {
        const t4 = s2.getFirstChild();
        if (t4) n2 = t4.selectStart().getNodes();
        else {
          const t5 = $createParagraphNode2();
          s2.append(t5), n2 = t5.select().getNodes();
        }
      } else if (B4(s2, n2)) {
        const e3 = st3(t3);
        if ($isRootOrShadowRoot2(o2)) {
          s2.replace(e3);
          const t4 = Y4();
          $isElementNode2(s2) && (t4.setFormat(s2.getFormatType()), t4.setIndent(s2.getIndent())), e3.append(t4);
        } else if (Z4(s2)) {
          const t4 = s2.getParentOrThrow();
          K4(e3, t4.getChildren()), t4.replace(e3);
        }
        return;
      }
    }
    const r2 = /* @__PURE__ */ new Set();
    for (let e3 = 0; e3 < n2.length; e3++) {
      const i2 = n2[e3];
      if ($isElementNode2(i2) && i2.isEmpty() && !Z4(i2) && !r2.has(i2.getKey())) {
        U5(i2, t3);
        continue;
      }
      let s2 = $isLeafNode2(i2) ? i2.getParent() : Z4(i2) && i2.isEmpty() ? i2 : null;
      for (; null != s2; ) {
        const e4 = s2.getKey();
        if (ot3(s2)) {
          if (!r2.has(e4)) {
            const n3 = st3(t3);
            K4(n3, s2.getChildren()), s2.replace(n3), r2.add(e4);
          }
          break;
        }
        {
          const n3 = s2.getParent();
          if ($isRootOrShadowRoot2(n3) && !r2.has(e4)) {
            r2.add(e4), U5(s2, t3);
            break;
          }
          s2 = n3;
        }
      }
    }
  }
}
function K4(t3, e2) {
  t3.splice(t3.getChildrenSize(), 0, e2);
}
function U5(t3, e2) {
  if (ot3(t3)) return t3;
  const n2 = t3.getPreviousSibling(), r2 = t3.getNextSibling(), i2 = Y4();
  let s2;
  if (K4(i2, t3.getChildren()), ot3(n2) && e2 === n2.getListType()) n2.append(i2), ot3(r2) && e2 === r2.getListType() && (K4(n2, r2.getChildren()), r2.remove()), s2 = n2;
  else if (ot3(r2) && e2 === r2.getListType()) r2.getFirstChildOrThrow().insertBefore(i2), s2 = r2;
  else {
    const n3 = st3(e2);
    n3.append(i2), t3.replace(n3), s2 = n3;
  }
  return i2.setFormat(t3.getFormatType()), i2.setIndent(t3.getIndent()), t3.remove(), s2;
}
function V4(t3, e2) {
  const n2 = t3.getLastChild(), r2 = e2.getFirstChild();
  n2 && r2 && R4(n2) && R4(r2) && (V4(n2.getFirstChild(), r2.getFirstChild()), r2.remove());
  const i2 = e2.getChildren();
  i2.length > 0 && t3.append(...i2), e2.remove();
}
function z4() {
  const e2 = $getSelection2();
  if ($isRangeSelection2(e2)) {
    const n2 = /* @__PURE__ */ new Set(), r2 = e2.getNodes(), i2 = e2.anchor.getNode();
    if (B4(i2, r2)) n2.add(D4(i2));
    else for (let e3 = 0; e3 < r2.length; e3++) {
      const i3 = r2[e3];
      if ($isLeafNode2(i3)) {
        const e4 = $getNearestNodeOfType2(i3, j4);
        null != e4 && n2.add(D4(e4));
      }
    }
    for (const t3 of n2) {
      let n3 = t3;
      const r3 = M4(t3);
      for (const t4 of r3) {
        const r4 = $createParagraphNode2().setTextStyle(e2.style).setTextFormat(e2.format);
        K4(r4, t4.getChildren()), n3.insertAfter(r4), n3 = r4, t4.__key === e2.anchor.key && $setPointFromCaret2(e2.anchor, $normalizeCaret2($getChildCaret2(r4, "next"))), t4.__key === e2.focus.key && $setPointFromCaret2(e2.focus, $normalizeCaret2($getChildCaret2(r4, "next"))), t4.remove();
      }
      t3.remove();
    }
  }
}
function $4(t3) {
  const e2 = /* @__PURE__ */ new Set();
  if (R4(t3) || e2.has(t3.getKey())) return;
  const n2 = t3.getParent(), r2 = t3.getNextSibling(), i2 = t3.getPreviousSibling();
  if (R4(r2) && R4(i2)) {
    const n3 = i2.getFirstChild();
    if (ot3(n3)) {
      n3.append(t3);
      const i3 = r2.getFirstChild();
      if (ot3(i3)) {
        K4(n3, i3.getChildren()), r2.remove(), e2.add(r2.getKey());
      }
    }
  } else if (R4(r2)) {
    const e3 = r2.getFirstChild();
    if (ot3(e3)) {
      const n3 = e3.getFirstChild();
      null !== n3 && n3.insertBefore(t3);
    }
  } else if (R4(i2)) {
    const e3 = i2.getFirstChild();
    ot3(e3) && e3.append(t3);
  } else if (ot3(n2)) {
    const e3 = Y4().setTextFormat(t3.getTextFormat()).setTextStyle(t3.getTextStyle()), s2 = st3(n2.getListType()).setTextFormat(n2.getTextFormat()).setTextStyle(n2.getTextStyle());
    e3.append(s2), s2.append(t3), i2 ? i2.insertAfter(e3) : r2 ? r2.insertBefore(e3) : n2.append(e3);
  }
}
function q4(t3) {
  if (R4(t3)) return;
  const e2 = t3.getParent(), n2 = e2 ? e2.getParent() : void 0;
  if (ot3(n2 ? n2.getParent() : void 0) && Z4(n2) && ot3(e2)) {
    const r2 = e2 ? e2.getFirstChild() : void 0, i2 = e2 ? e2.getLastChild() : void 0;
    if (t3.is(r2)) n2.insertBefore(t3), e2.isEmpty() && n2.remove();
    else if (t3.is(i2)) n2.insertAfter(t3), e2.isEmpty() && n2.remove();
    else {
      const r3 = e2.getListType(), i3 = Y4(), s2 = st3(r3);
      i3.append(s2), t3.getPreviousSiblings().forEach((t4) => s2.append(t4));
      const o2 = Y4(), l2 = st3(r3);
      o2.append(l2), K4(l2, t3.getNextSiblings()), n2.insertBefore(i3), n2.insertAfter(o2), n2.replace(t3);
    }
  }
}
function H4() {
  const t3 = $getSelection2();
  if (!$isRangeSelection2(t3) || !t3.isCollapsed()) return false;
  const e2 = t3.anchor.getNode();
  if (!Z4(e2) || 0 !== e2.getChildrenSize()) return false;
  const n2 = D4(e2), r2 = e2.getParent();
  ot3(r2) || w3(40);
  const i2 = r2.getParent();
  let s2;
  if ($isRootOrShadowRoot2(i2)) s2 = $createParagraphNode2(), n2.insertAfter(s2);
  else {
    if (!Z4(i2)) return false;
    s2 = Y4(), i2.insertAfter(s2);
  }
  s2.setTextStyle(t3.style).setTextFormat(t3.format).select();
  const o2 = e2.getNextSiblings();
  if (o2.length > 0) {
    const t4 = st3(r2.getListType());
    if (Z4(s2)) {
      const e3 = Y4();
      e3.append(t4), s2.insertAfter(e3);
    } else s2.insertAfter(t4);
    t4.append(...o2);
  }
  return function(t4) {
    let e3 = t4;
    for (; null == e3.getNextSibling() && null == e3.getPreviousSibling(); ) {
      const t5 = e3.getParent();
      if (null == t5 || !Z4(t5) && !ot3(t5)) break;
      e3 = t5;
    }
    e3.remove();
  }(e2), true;
}
function X4(...t3) {
  const e2 = [];
  for (const n2 of t3) if (n2 && "string" == typeof n2) for (const [t4] of n2.matchAll(/\S+/g)) e2.push(t4);
  return e2;
}
function G4(t3) {
  if (t3.classList.contains("task-list-item")) {
    for (const e3 of t3.children) if ("INPUT" === e3.tagName) return Q4(e3);
  }
  const e2 = t3.getAttribute("aria-checked");
  return { node: Y4("true" === e2 || "false" !== e2 && void 0) };
}
function Q4(t3) {
  if (!("checkbox" === t3.getAttribute("type"))) return { node: null };
  return { node: Y4(t3.hasAttribute("checked")) };
}
function Y4(t3) {
  return $applyNodeReplacement2(new j4(void 0, t3));
}
function Z4(t3) {
  return t3 instanceof j4;
}
function et3(t3, r2, i2) {
  const s2 = [], o2 = [], l2 = r2.list;
  if (void 0 !== l2) {
    const t4 = l2[`${i2.__tag}Depth`] || [], e2 = I4(i2) - 1, n2 = e2 % t4.length, r3 = t4[n2], c2 = l2[i2.__tag];
    let a2;
    const u2 = l2.nested, g4 = l2.checklist;
    if (void 0 !== u2 && u2.list && (a2 = u2.list), void 0 !== c2 && s2.push(c2), void 0 !== g4 && "check" === i2.__listType && s2.push(g4), void 0 !== r3) {
      s2.push(...X4(r3));
      for (let e3 = 0; e3 < t4.length; e3++) e3 !== n2 && o2.push(i2.__tag + e3);
    }
    if (void 0 !== a2) {
      const t5 = X4(a2);
      e2 > 1 ? s2.push(...t5) : o2.push(...t5);
    }
  }
  o2.length > 0 && removeClassNamesFromElement2(t3, ...o2), s2.length > 0 && addClassNamesToElement2(t3, ...s2);
}
function nt3(t3) {
  const e2 = [];
  for (let n2 = 0; n2 < t3.length; n2++) {
    const r2 = t3[n2];
    if (Z4(r2)) {
      e2.push(r2);
      const t4 = r2.getChildren();
      t4.length > 1 && t4.forEach((t5) => {
        ot3(t5) && e2.push(J4(t5));
      });
    } else e2.push(J4(r2));
  }
  return e2;
}
function rt3(t3) {
  const e2 = t3.nodeName.toLowerCase();
  let n2 = null;
  if ("ol" === e2) {
    n2 = st3("number", t3.start);
  } else "ul" === e2 && (n2 = function(t4) {
    if ("check" === t4.getAttribute("__lexicallisttype") || t4.classList.contains("contains-task-list")) return true;
    for (const e3 of t4.childNodes) if (isHTMLElement3(e3) && e3.hasAttribute("aria-checked")) return true;
    return false;
  }(t3) ? st3("check") : st3("bullet"));
  return { after: nt3, node: n2 };
}
function st3(t3 = "number", e2 = 1) {
  return $applyNodeReplacement2(new tt3(t3, e2));
}
function ot3(t3) {
  return t3 instanceof tt3;
}
function ct3(t3) {
  return mergeRegister2(t3.registerCommand(lt3, () => (W4("check"), true), COMMAND_PRIORITY_LOW2), t3.registerCommand(KEY_ARROW_DOWN_COMMAND2, (e2) => dt3(e2, t3, false), COMMAND_PRIORITY_LOW2), t3.registerCommand(KEY_ARROW_UP_COMMAND2, (e2) => dt3(e2, t3, true), COMMAND_PRIORITY_LOW2), t3.registerCommand(KEY_ESCAPE_COMMAND2, () => {
    if (null != ht3()) {
      const e2 = t3.getRootElement();
      return null != e2 && e2.focus(), true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW2), t3.registerCommand(KEY_SPACE_COMMAND2, (e2) => {
    const n2 = ht3();
    return !(null == n2 || !t3.isEditable()) && (t3.update(() => {
      const t4 = $getNearestNodeFromDOMNode2(n2);
      Z4(t4) && (e2.preventDefault(), t4.toggleChecked());
    }), true);
  }, COMMAND_PRIORITY_LOW2), t3.registerCommand(KEY_ARROW_LEFT_COMMAND2, (e2) => t3.getEditorState().read(() => {
    const n2 = $getSelection2();
    if ($isRangeSelection2(n2) && n2.isCollapsed()) {
      const { anchor: r2 } = n2, i2 = "element" === r2.type;
      if (i2 || 0 === r2.offset) {
        const n3 = r2.getNode(), o2 = $findMatchingParent3(n3, (t4) => $isElementNode2(t4) && !t4.isInline());
        if (Z4(o2)) {
          const r3 = o2.getParent();
          if (ot3(r3) && "check" === r3.getListType() && (i2 || o2.getFirstDescendant() === n3)) {
            const n4 = t3.getElementByKey(o2.__key);
            if (null != n4 && document.activeElement !== n4) return n4.focus(), e2.preventDefault(), true;
          }
        }
      }
    }
    return false;
  }), COMMAND_PRIORITY_LOW2), t3.registerRootListener((t4, e2) => {
    null !== t4 && (t4.addEventListener("click", ut3), t4.addEventListener("pointerdown", gt3)), null !== e2 && (e2.removeEventListener("click", ut3), e2.removeEventListener("pointerdown", gt3));
  }));
}
function at3(t3, e2) {
  const n2 = t3.target;
  if (!isHTMLElement3(n2)) return;
  const i2 = n2.firstChild;
  if (isHTMLElement3(i2) && ("UL" === i2.tagName || "OL" === i2.tagName)) return;
  const s2 = n2.parentNode;
  if (!s2 || "check" !== s2.__lexicalListType) return;
  const l2 = n2.getBoundingClientRect(), c2 = t3.pageX / calculateZoomLevel2(n2), a2 = window.getComputedStyle ? window.getComputedStyle(n2, "::before") : { width: "0px" }, u2 = parseFloat(a2.width);
  ("rtl" === n2.dir ? c2 < l2.right && c2 > l2.right - u2 : c2 > l2.left && c2 < l2.left + u2) && e2();
}
function ut3(t3) {
  at3(t3, () => {
    if (isHTMLElement3(t3.target)) {
      const e2 = t3.target, n2 = getNearestEditorFromDOMNode2(e2);
      null != n2 && n2.isEditable() && n2.update(() => {
        const t4 = $getNearestNodeFromDOMNode2(e2);
        Z4(t4) && (e2.focus(), t4.toggleChecked());
      });
    }
  });
}
function gt3(t3) {
  at3(t3, () => {
    t3.preventDefault();
  });
}
function ht3() {
  const t3 = document.activeElement;
  return isHTMLElement3(t3) && "LI" === t3.tagName && null != t3.parentNode && "check" === t3.parentNode.__lexicalListType ? t3 : null;
}
function dt3(t3, e2, n2) {
  const r2 = ht3();
  return null != r2 && e2.update(() => {
    const i2 = $getNearestNodeFromDOMNode2(r2);
    if (!Z4(i2)) return;
    const s2 = function(t4, e3) {
      let n3 = e3 ? t4.getPreviousSibling() : t4.getNextSibling(), r3 = t4;
      for (; null == n3 && Z4(r3); ) r3 = r3.getParentOrThrow().getParent(), null != r3 && (n3 = e3 ? r3.getPreviousSibling() : r3.getNextSibling());
      for (; Z4(n3); ) {
        const t5 = e3 ? n3.getLastChild() : n3.getFirstChild();
        if (!ot3(t5)) return n3;
        n3 = e3 ? t5.getLastChild() : t5.getFirstChild();
      }
      return null;
    }(i2, n2);
    if (null != s2) {
      s2.selectStart();
      const n3 = e2.getElementByKey(s2.__key);
      null != n3 && (t3.preventDefault(), setTimeout(() => {
        n3.focus();
      }, 0));
    }
  }), false;
}
function _t3(t3) {
  return mergeRegister2(t3.registerCommand(pt3, () => (W4("number"), true), COMMAND_PRIORITY_LOW2), t3.registerCommand(ft3, () => (W4("bullet"), true), COMMAND_PRIORITY_LOW2), t3.registerCommand(mt3, () => (z4(), true), COMMAND_PRIORITY_LOW2), t3.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => H4(), COMMAND_PRIORITY_LOW2), t3.registerNodeTransform(j4, (t4) => {
    const e2 = t4.getFirstChild();
    if (e2) {
      if ($isTextNode2(e2)) {
        const n2 = e2.getStyle(), r2 = e2.getFormat();
        t4.getTextStyle() !== n2 && t4.setTextStyle(n2), t4.getTextFormat() !== r2 && t4.setTextFormat(r2);
      }
    } else {
      const e3 = $getSelection2();
      $isRangeSelection2(e3) && (e3.style !== t4.getTextStyle() || e3.format !== t4.getTextFormat()) && e3.isCollapsed() && t4.is(e3.anchor.getNode()) && t4.setTextStyle(e3.style).setTextFormat(e3.format);
    }
  }), t3.registerNodeTransform(TextNode2, (t4) => {
    const e2 = t4.getParent();
    if (Z4(e2) && t4.is(e2.getFirstChild())) {
      const n2 = t4.getStyle(), r2 = t4.getFormat();
      n2 === e2.getTextStyle() && r2 === e2.getTextFormat() || e2.setTextStyle(n2).setTextFormat(r2);
    }
  }));
}
function yt3(t3) {
  const e2 = (t4) => {
    const e3 = t4.getParent();
    if (ot3(t4.getFirstChild()) || !ot3(e3)) return;
    const n2 = $findMatchingParent3(t4, (t5) => Z4(t5) && ot3(t5.getParent()) && Z4(t5.getPreviousSibling()));
    if (null === n2 && t4.getIndent() > 0) t4.setIndent(0);
    else if (Z4(n2)) {
      const r2 = n2.getPreviousSibling();
      if (Z4(r2)) {
        const n3 = function(t5) {
          let e4 = t5, n4 = e4.getFirstChild();
          for (; ot3(n4); ) {
            const t6 = n4.getLastChild();
            if (!Z4(t6)) break;
            e4 = t6, n4 = e4.getFirstChild();
          }
          return e4;
        }(r2), i2 = n3.getParent();
        if (ot3(i2)) {
          const n4 = I4(i2);
          n4 + 1 < I4(e3) && t4.setIndent(n4);
        }
      }
    }
  };
  return t3.registerNodeTransform(tt3, (t4) => {
    const n2 = [t4];
    for (; n2.length > 0; ) {
      const t5 = n2.shift();
      if (ot3(t5)) {
        for (const r2 of t5.getChildren()) if (Z4(r2)) {
          e2(r2);
          const t6 = r2.getFirstChild();
          ot3(t6) && n2.push(t6);
        }
      }
    }
  });
}
function Ct3(t3, e2) {
  t3.update(() => W4(e2));
}
function Tt3(t3) {
  t3.update(() => z4());
}
var j4, tt3, it3, lt3, ft3, pt3, mt3;
var init_LexicalList_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/list@0.32.1/node_modules/@lexical/list/LexicalList.prod.mjs"() {
    await init_LexicalUtils_node();
    await init_Lexical_node();
    await init_LexicalSelection_node();
    j4 = class _j extends ElementNode2 {
      static getType() {
        return "listitem";
      }
      static clone(t3) {
        return new _j(t3.__value, t3.__checked, t3.__key);
      }
      constructor(t3, e2, n2) {
        super(n2), this.__value = void 0 === t3 ? 1 : t3, this.__checked = e2;
      }
      createDOM(t3) {
        const e2 = document.createElement("li");
        return this.updateListItemDOM(null, e2, t3), e2;
      }
      updateListItemDOM(t3, r2, i2) {
        const s2 = this.getParent();
        ot3(s2) && "check" === s2.getListType() && function(t4, e2, n2, r3) {
          ot3(e2.getFirstChild()) ? (t4.removeAttribute("role"), t4.removeAttribute("tabIndex"), t4.removeAttribute("aria-checked")) : (t4.setAttribute("role", "checkbox"), t4.setAttribute("tabIndex", "-1"), n2 && e2.__checked === n2.__checked || t4.setAttribute("aria-checked", e2.getChecked() ? "true" : "false"));
        }(r2, this, t3), r2.value = this.__value, function(t4, r3, i3) {
          const s3 = [], o3 = [], l3 = r3.list, c2 = l3 ? l3.listitem : void 0;
          let a2;
          l3 && l3.nested && (a2 = l3.nested.listitem);
          void 0 !== c2 && s3.push(...X4(c2));
          if (l3) {
            const t5 = i3.getParent(), e2 = ot3(t5) && "check" === t5.getListType(), n2 = i3.getChecked();
            e2 && !n2 || o3.push(l3.listitemUnchecked), e2 && n2 || o3.push(l3.listitemChecked), e2 && s3.push(n2 ? l3.listitemChecked : l3.listitemUnchecked);
          }
          if (void 0 !== a2) {
            const t5 = X4(a2);
            i3.getChildren().some((t6) => ot3(t6)) ? s3.push(...t5) : o3.push(...t5);
          }
          o3.length > 0 && removeClassNamesFromElement2(t4, ...o3);
          s3.length > 0 && addClassNamesToElement2(t4, ...s3);
        }(r2, i2.theme, this);
        const o2 = t3 ? t3.__style : "", l2 = this.__style;
        o2 !== l2 && ("" === l2 ? r2.removeAttribute("style") : r2.style.cssText = l2), function(t4, e2, n2) {
          const r3 = getStyleObjectFromCSS2(e2.__textStyle);
          for (const e3 in r3) t4.style.setProperty(`--listitem-marker-${e3}`, r3[e3]);
          if (n2) for (const e3 in getStyleObjectFromCSS2(n2.__textStyle)) e3 in r3 || t4.style.removeProperty(`--listitem-marker-${e3}`);
        }(r2, this, t3);
      }
      updateDOM(t3, e2, n2) {
        const r2 = e2;
        return this.updateListItemDOM(t3, r2, n2), false;
      }
      static transform() {
        return (t3) => {
          if (Z4(t3) || w3(144), null == t3.__checked) return;
          const e2 = t3.getParent();
          ot3(e2) && "check" !== e2.getListType() && null != t3.getChecked() && t3.setChecked(void 0);
        };
      }
      static importDOM() {
        return { li: () => ({ conversion: G4, priority: 0 }) };
      }
      static importJSON(t3) {
        return Y4().updateFromJSON(t3);
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setValue(t3.value).setChecked(t3.checked);
      }
      exportDOM(t3) {
        const e2 = this.createDOM(t3._config), n2 = this.getFormatType();
        n2 && (e2.style.textAlign = n2);
        const r2 = this.getDirection();
        return r2 && (e2.dir = r2), { element: e2 };
      }
      exportJSON() {
        return { ...super.exportJSON(), checked: this.getChecked(), value: this.getValue() };
      }
      append(...t3) {
        for (let e2 = 0; e2 < t3.length; e2++) {
          const n2 = t3[e2];
          if ($isElementNode2(n2) && this.canMergeWith(n2)) {
            const t4 = n2.getChildren();
            this.append(...t4), n2.remove();
          } else super.append(n2);
        }
        return this;
      }
      replace(t3, e2) {
        if (Z4(t3)) return super.replace(t3);
        this.setIndent(0);
        const n2 = this.getParentOrThrow();
        if (!ot3(n2)) return t3;
        if (n2.__first === this.getKey()) n2.insertBefore(t3);
        else if (n2.__last === this.getKey()) n2.insertAfter(t3);
        else {
          const e3 = st3(n2.getListType());
          let r2 = this.getNextSibling();
          for (; r2; ) {
            const t4 = r2;
            r2 = r2.getNextSibling(), e3.append(t4);
          }
          n2.insertAfter(t3), t3.insertAfter(e3);
        }
        return e2 && ($isElementNode2(t3) || w3(139), this.getChildren().forEach((e3) => {
          t3.append(e3);
        })), this.remove(), 0 === n2.getChildrenSize() && n2.remove(), t3;
      }
      insertAfter(t3, e2 = true) {
        const n2 = this.getParentOrThrow();
        if (ot3(n2) || w3(39), Z4(t3)) return super.insertAfter(t3, e2);
        const r2 = this.getNextSiblings();
        if (n2.insertAfter(t3, e2), 0 !== r2.length) {
          const i2 = st3(n2.getListType());
          r2.forEach((t4) => i2.append(t4)), t3.insertAfter(i2, e2);
        }
        return t3;
      }
      remove(t3) {
        const e2 = this.getPreviousSibling(), n2 = this.getNextSibling();
        super.remove(t3), e2 && n2 && R4(e2) && R4(n2) && (V4(e2.getFirstChild(), n2.getFirstChild()), n2.remove());
      }
      insertNewAfter(t3, e2 = true) {
        const n2 = Y4().updateFromJSON(this.exportJSON()).setChecked(!this.getChecked() && void 0);
        return this.insertAfter(n2, e2), n2;
      }
      collapseAtStart(t3) {
        const e2 = $createParagraphNode2();
        this.getChildren().forEach((t4) => e2.append(t4));
        const n2 = this.getParentOrThrow(), r2 = n2.getParentOrThrow(), i2 = Z4(r2);
        if (1 === n2.getChildrenSize()) if (i2) n2.remove(), r2.select();
        else {
          n2.insertBefore(e2), n2.remove();
          const r3 = t3.anchor, i3 = t3.focus, s2 = e2.getKey();
          "element" === r3.type && r3.getNode().is(this) && r3.set(s2, r3.offset, "element"), "element" === i3.type && i3.getNode().is(this) && i3.set(s2, i3.offset, "element");
        }
        else n2.insertBefore(e2), this.remove();
        return true;
      }
      getValue() {
        return this.getLatest().__value;
      }
      setValue(t3) {
        const e2 = this.getWritable();
        return e2.__value = t3, e2;
      }
      getChecked() {
        const t3 = this.getLatest();
        let e2;
        const n2 = this.getParent();
        return ot3(n2) && (e2 = n2.getListType()), "check" === e2 ? Boolean(t3.__checked) : void 0;
      }
      setChecked(t3) {
        const e2 = this.getWritable();
        return e2.__checked = t3, e2;
      }
      toggleChecked() {
        const t3 = this.getWritable();
        return t3.setChecked(!t3.__checked);
      }
      getIndent() {
        const t3 = this.getParent();
        if (null === t3 || !this.isAttached()) return this.getLatest().__indent;
        let e2 = t3.getParentOrThrow(), n2 = 0;
        for (; Z4(e2); ) e2 = e2.getParentOrThrow().getParentOrThrow(), n2++;
        return n2;
      }
      setIndent(t3) {
        "number" != typeof t3 && w3(117), (t3 = Math.floor(t3)) >= 0 || w3(199);
        let e2 = this.getIndent();
        for (; e2 !== t3; ) e2 < t3 ? ($4(this), e2++) : (q4(this), e2--);
        return this;
      }
      canInsertAfter(t3) {
        return Z4(t3);
      }
      canReplaceWith(t3) {
        return Z4(t3);
      }
      canMergeWith(t3) {
        return Z4(t3) || $isParagraphNode2(t3);
      }
      extractWithChild(t3, e2) {
        if (!$isRangeSelection2(e2)) return false;
        const n2 = e2.anchor.getNode(), r2 = e2.focus.getNode();
        return this.isParentOf(n2) && this.isParentOf(r2) && this.getTextContent().length === e2.getTextContent().length;
      }
      isParentRequired() {
        return true;
      }
      createParentElementNode() {
        return st3("bullet");
      }
      canMergeWhenEmpty() {
        return true;
      }
    };
    tt3 = class _tt extends ElementNode2 {
      static getType() {
        return "list";
      }
      static clone(t3) {
        const e2 = t3.__listType || it3[t3.__tag];
        return new _tt(e2, t3.__start, t3.__key);
      }
      constructor(t3 = "number", e2 = 1, n2) {
        super(n2);
        const r2 = it3[t3] || t3;
        this.__listType = r2, this.__tag = "number" === r2 ? "ol" : "ul", this.__start = e2;
      }
      getTag() {
        return this.__tag;
      }
      setListType(t3) {
        const e2 = this.getWritable();
        return e2.__listType = t3, e2.__tag = "number" === t3 ? "ol" : "ul", e2;
      }
      getListType() {
        return this.__listType;
      }
      getStart() {
        return this.__start;
      }
      setStart(t3) {
        const e2 = this.getWritable();
        return e2.__start = t3, e2;
      }
      createDOM(t3, e2) {
        const n2 = this.__tag, r2 = document.createElement(n2);
        return 1 !== this.__start && r2.setAttribute("start", String(this.__start)), r2.__lexicalListType = this.__listType, et3(r2, t3.theme, this), r2;
      }
      updateDOM(t3, e2, n2) {
        return t3.__tag !== this.__tag || (et3(e2, n2.theme, this), false);
      }
      static transform() {
        return (t3) => {
          ot3(t3) || w3(163), function(t4) {
            const e2 = t4.getNextSibling();
            ot3(e2) && t4.getListType() === e2.getListType() && V4(t4, e2);
          }(t3), function(t4) {
            const e2 = "check" !== t4.getListType();
            let n2 = t4.getStart();
            for (const r2 of t4.getChildren()) Z4(r2) && (r2.getValue() !== n2 && r2.setValue(n2), e2 && null != r2.getLatest().__checked && r2.setChecked(void 0), ot3(r2.getFirstChild()) || n2++);
          }(t3);
        };
      }
      static importDOM() {
        return { ol: () => ({ conversion: rt3, priority: 0 }), ul: () => ({ conversion: rt3, priority: 0 }) };
      }
      static importJSON(t3) {
        return st3().updateFromJSON(t3);
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setListType(t3.listType).setStart(t3.start);
      }
      exportDOM(t3) {
        const e2 = this.createDOM(t3._config, t3);
        return isHTMLElement3(e2) && (1 !== this.__start && e2.setAttribute("start", String(this.__start)), "check" === this.__listType && e2.setAttribute("__lexicalListType", "check")), { element: e2 };
      }
      exportJSON() {
        return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag() };
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
      splice(t3, e2, n2) {
        let r2 = n2;
        for (let t4 = 0; t4 < n2.length; t4++) {
          const e3 = n2[t4];
          Z4(e3) || (r2 === n2 && (r2 = [...n2]), r2[t4] = Y4().append(!$isElementNode2(e3) || ot3(e3) || e3.isInline() ? e3 : $createTextNode2(e3.getTextContent())));
        }
        return super.splice(t3, e2, r2);
      }
      extractWithChild(t3) {
        return Z4(t3);
      }
    };
    it3 = { ol: "number", ul: "bullet" };
    lt3 = createCommand2("INSERT_CHECK_LIST_COMMAND");
    ft3 = createCommand2("INSERT_UNORDERED_LIST_COMMAND");
    pt3 = createCommand2("INSERT_ORDERED_LIST_COMMAND");
    mt3 = createCommand2("REMOVE_LIST_COMMAND");
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/clipboard@0.32.1/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
var LexicalClipboard_dev_exports = {};
__export(LexicalClipboard_dev_exports, {
  $generateJSONFromSelectedNodes: () => $generateJSONFromSelectedNodes,
  $generateNodesFromSerializedNodes: () => $generateNodesFromSerializedNodes,
  $getClipboardDataFromSelection: () => $getClipboardDataFromSelection,
  $getHtmlContent: () => $getHtmlContent,
  $getLexicalContent: () => $getLexicalContent,
  $insertDataTransferForPlainText: () => $insertDataTransferForPlainText,
  $insertDataTransferForRichText: () => $insertDataTransferForRichText,
  $insertGeneratedNodes: () => $insertGeneratedNodes,
  copyToClipboard: () => copyToClipboard,
  setLexicalClipboardDataTransfer: () => setLexicalClipboardDataTransfer
});
function formatDevErrorMessage6(message) {
  throw new Error(message);
}
function $getHtmlContent(editor, selection = $getSelection2()) {
  if (selection == null) {
    {
      formatDevErrorMessage6(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return "";
  }
  return $generateHtmlFromNodes2(editor, selection);
}
function $getLexicalContent(editor, selection = $getSelection2()) {
  if (selection == null) {
    {
      formatDevErrorMessage6(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return null;
  }
  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
}
function $insertDataTransferForPlainText(dataTransfer, selection) {
  const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text != null) {
    selection.insertRawText(text);
  }
}
function $insertDataTransferForRichText(dataTransfer, selection, editor) {
  const lexicalString = dataTransfer.getData("application/x-lexical-editor");
  if (lexicalString) {
    try {
      const payload = JSON.parse(lexicalString);
      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
        const nodes = $generateNodesFromSerializedNodes(payload.nodes);
        return $insertGeneratedNodes(editor, nodes, selection);
      }
    } catch (_unused) {
    }
  }
  const htmlString = dataTransfer.getData("text/html");
  const plainString = dataTransfer.getData("text/plain");
  if (htmlString && plainString !== htmlString) {
    try {
      const parser = new DOMParser();
      const dom2 = parser.parseFromString(trustHTML(htmlString), "text/html");
      const nodes = $generateNodesFromDOM2(editor, dom2);
      return $insertGeneratedNodes(editor, nodes, selection);
    } catch (_unused2) {
    }
  }
  const text = plainString || dataTransfer.getData("text/uri-list");
  if (text != null) {
    if ($isRangeSelection2(selection)) {
      const parts = text.split(/(\r?\n|\t)/);
      if (parts[parts.length - 1] === "") {
        parts.pop();
      }
      for (let i2 = 0; i2 < parts.length; i2++) {
        const currentSelection = $getSelection2();
        if ($isRangeSelection2(currentSelection)) {
          const part = parts[i2];
          if (part === "\n" || part === "\r\n") {
            currentSelection.insertParagraph();
          } else if (part === "	") {
            currentSelection.insertNodes([$createTabNode2()]);
          } else {
            currentSelection.insertText(part);
          }
        }
      }
    } else {
      selection.insertRawText(text);
    }
  }
}
function trustHTML(html) {
  if (window.trustedTypes && window.trustedTypes.createPolicy) {
    const policy = window.trustedTypes.createPolicy("lexical", {
      createHTML: (input) => input
    });
    return policy.createHTML(html);
  }
  return html;
}
function $insertGeneratedNodes(editor, nodes, selection) {
  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, {
    nodes,
    selection
  })) {
    selection.insertNodes(nodes);
  }
  return;
}
function exportNodeToJSON2(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      formatDevErrorMessage6(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    }
  }
  if ($isElementNode2(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        formatDevErrorMessage6(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
  }
  return serializedNode;
}
function $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null) {
    let clone = $cloneWithProperties2(currentNode);
    clone = $isTextNode2(clone) && selection !== null ? $sliceSelectedTextNodeContent2(selection, clone) : clone;
    target = clone;
  }
  const children = $isElementNode2(target) ? target.getChildren() : [];
  const serializedNode = exportNodeToJSON2(target);
  if ($isTextNode2(target)) {
    const text = target.__text;
    if (text.length > 0) {
      serializedNode.text = text;
    } else {
      shouldInclude = false;
    }
  }
  for (let i2 = 0; i2 < children.length; i2++) {
    const childNode = children[i2];
    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);
    if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "clone")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    targetArray.push(serializedNode);
  } else if (Array.isArray(serializedNode.children)) {
    for (let i2 = 0; i2 < serializedNode.children.length; i2++) {
      const serializedChildNode = serializedNode.children[i2];
      targetArray.push(serializedChildNode);
    }
  }
  return shouldInclude;
}
function $generateJSONFromSelectedNodes(editor, selection) {
  const nodes = [];
  const root = $getRoot2();
  const topLevelChildren = root.getChildren();
  for (let i2 = 0; i2 < topLevelChildren.length; i2++) {
    const topLevelNode = topLevelChildren[i2];
    $appendNodesToJSON(editor, selection, topLevelNode, nodes);
  }
  return {
    namespace: editor._config.namespace,
    nodes
  };
}
function $generateNodesFromSerializedNodes(serializedNodes) {
  const nodes = [];
  for (let i2 = 0; i2 < serializedNodes.length; i2++) {
    const serializedNode = serializedNodes[i2];
    const node = $parseSerializedNode2(serializedNode);
    if ($isTextNode2(node)) {
      $addNodeStyle2(node);
    }
    nodes.push(node);
  }
  return nodes;
}
async function copyToClipboard(editor, event, data) {
  if (clipboardEventTimeout !== null) {
    return false;
  }
  if (event !== null) {
    return new Promise((resolve, reject) => {
      editor.update(() => {
        resolve($copyToClipboardEvent(editor, event, data));
      });
    });
  }
  const rootElement = editor.getRootElement();
  const editorWindow = editor._window || window;
  const windowDocument = window.document;
  const domSelection = getDOMSelection2(editorWindow);
  if (rootElement === null || domSelection === null) {
    return false;
  }
  const element = windowDocument.createElement("span");
  element.style.cssText = "position: fixed; top: -1000px;";
  element.append(windowDocument.createTextNode("#"));
  rootElement.append(element);
  const range = new Range();
  range.setStart(element, 0);
  range.setEnd(element, 1);
  domSelection.removeAllRanges();
  domSelection.addRange(range);
  return new Promise((resolve, reject) => {
    const removeListener = editor.registerCommand(COPY_COMMAND2, (secondEvent) => {
      if (objectKlassEquals2(secondEvent, ClipboardEvent)) {
        removeListener();
        if (clipboardEventTimeout !== null) {
          window.clearTimeout(clipboardEventTimeout);
          clipboardEventTimeout = null;
        }
        resolve($copyToClipboardEvent(editor, secondEvent, data));
      }
      return true;
    }, COMMAND_PRIORITY_CRITICAL2);
    clipboardEventTimeout = window.setTimeout(() => {
      removeListener();
      clipboardEventTimeout = null;
      resolve(false);
    }, EVENT_LATENCY);
    windowDocument.execCommand("copy");
    element.remove();
  });
}
function $copyToClipboardEvent(editor, event, data) {
  if (data === void 0) {
    const domSelection = getDOMSelection2(editor._window);
    if (!domSelection) {
      return false;
    }
    const anchorDOM = domSelection.anchorNode;
    const focusDOM = domSelection.focusNode;
    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor2(editor, anchorDOM, focusDOM)) {
      return false;
    }
    const selection = $getSelection2();
    if (selection === null) {
      return false;
    }
    data = $getClipboardDataFromSelection(selection);
  }
  event.preventDefault();
  const clipboardData = event.clipboardData;
  if (clipboardData === null) {
    return false;
  }
  setLexicalClipboardDataTransfer(clipboardData, data);
  return true;
}
function $getClipboardDataFromSelection(selection = $getSelection2()) {
  const clipboardData = {
    "text/plain": selection ? selection.getTextContent() : ""
  };
  if (selection) {
    const editor = $getEditor2();
    for (const [mimeType, $editorFn] of clipboardDataFunctions) {
      const v4 = $editorFn(editor, selection);
      if (v4 !== null) {
        clipboardData[mimeType] = v4;
      }
    }
  }
  return clipboardData;
}
function setLexicalClipboardDataTransfer(clipboardData, data) {
  for (const k5 in data) {
    const v4 = data[k5];
    if (v4 !== void 0) {
      clipboardData.setData(k5, v4);
    }
  }
}
var EVENT_LATENCY, clipboardEventTimeout, clipboardDataFunctions;
var init_LexicalClipboard_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/clipboard@0.32.1/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"() {
    await init_LexicalHtml_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    EVENT_LATENCY = 50;
    clipboardEventTimeout = null;
    clipboardDataFunctions = [["text/html", $getHtmlContent], ["application/x-lexical-editor", $getLexicalContent]];
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/clipboard@0.32.1/node_modules/@lexical/clipboard/LexicalClipboard.prod.mjs
var LexicalClipboard_prod_exports = {};
__export(LexicalClipboard_prod_exports, {
  $generateJSONFromSelectedNodes: () => R5,
  $generateNodesFromSerializedNodes: () => A3,
  $getClipboardDataFromSelection: () => M5,
  $getHtmlContent: () => T4,
  $getLexicalContent: () => v3,
  $insertDataTransferForPlainText: () => C3,
  $insertDataTransferForRichText: () => D5,
  $insertGeneratedNodes: () => N4,
  copyToClipboard: () => _4,
  setLexicalClipboardDataTransfer: () => O5
});
function y3(t3, ...e2) {
  const n2 = new URL("https://lexical.dev/docs/error"), o2 = new URLSearchParams();
  o2.append("code", t3);
  for (const t4 of e2) o2.append("v", t4);
  throw n2.search = o2.toString(), Error(`Minified Lexical error #${t3}; visit ${n2.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function T4(e2, n2 = $getSelection2()) {
  return null == n2 && y3(166), $isRangeSelection2(n2) && n2.isCollapsed() || 0 === n2.getNodes().length ? "" : $generateHtmlFromNodes2(e2, n2);
}
function v3(t3, e2 = $getSelection2()) {
  return null == e2 && y3(166), $isRangeSelection2(e2) && e2.isCollapsed() || 0 === e2.getNodes().length ? null : JSON.stringify(R5(t3, e2));
}
function C3(t3, e2) {
  const n2 = t3.getData("text/plain") || t3.getData("text/uri-list");
  null != n2 && e2.insertRawText(n2);
}
function D5(t3, n2, o2) {
  const r2 = t3.getData("application/x-lexical-editor");
  if (r2) try {
    const t4 = JSON.parse(r2);
    if (t4.namespace === o2._config.namespace && Array.isArray(t4.nodes)) {
      return N4(o2, A3(t4.nodes), n2);
    }
  } catch (t4) {
  }
  const c2 = t3.getData("text/html"), a2 = t3.getData("text/plain");
  if (c2 && a2 !== c2) try {
    const t4 = new DOMParser().parseFromString(function(t5) {
      if (window.trustedTypes && window.trustedTypes.createPolicy) {
        return window.trustedTypes.createPolicy("lexical", { createHTML: (t6) => t6 }).createHTML(t5);
      }
      return t5;
    }(c2), "text/html");
    return N4(o2, $generateNodesFromDOM2(o2, t4), n2);
  } catch (t4) {
  }
  const u2 = a2 || t3.getData("text/uri-list");
  if (null != u2) if ($isRangeSelection2(n2)) {
    const t4 = u2.split(/(\r?\n|\t)/);
    "" === t4[t4.length - 1] && t4.pop();
    for (let e2 = 0; e2 < t4.length; e2++) {
      const n3 = $getSelection2();
      if ($isRangeSelection2(n3)) {
        const o3 = t4[e2];
        "\n" === o3 || "\r\n" === o3 ? n3.insertParagraph() : "	" === o3 ? n3.insertNodes([$createTabNode2()]) : n3.insertText(o3);
      }
    }
  } else n2.insertRawText(u2);
}
function N4(t3, e2, n2) {
  t3.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, { nodes: e2, selection: n2 }) || n2.insertNodes(e2);
}
function S3(t3, e2, n2, r2 = []) {
  let i2 = null === e2 || n2.isSelected(e2);
  const l2 = $isElementNode2(n2) && n2.excludeFromCopy("html");
  let s2 = n2;
  if (null !== e2) {
    let t4 = $cloneWithProperties2(n2);
    t4 = $isTextNode2(t4) && null !== e2 ? $sliceSelectedTextNodeContent2(e2, t4) : t4, s2 = t4;
  }
  const c2 = $isElementNode2(s2) ? s2.getChildren() : [], a2 = function(t4) {
    const e3 = t4.exportJSON(), n3 = t4.constructor;
    if (e3.type !== n3.getType() && y3(58, n3.name), $isElementNode2(t4)) {
      const t5 = e3.children;
      Array.isArray(t5) || y3(59, n3.name);
    }
    return e3;
  }(s2);
  if ($isTextNode2(s2)) {
    const t4 = s2.__text;
    t4.length > 0 ? a2.text = t4 : i2 = false;
  }
  for (let o2 = 0; o2 < c2.length; o2++) {
    const r3 = c2[o2], l3 = S3(t3, e2, r3, a2.children);
    !i2 && $isElementNode2(n2) && l3 && n2.extractWithChild(r3, e2, "clone") && (i2 = true);
  }
  if (i2 && !l2) r2.push(a2);
  else if (Array.isArray(a2.children)) for (let t4 = 0; t4 < a2.children.length; t4++) {
    const e3 = a2.children[t4];
    r2.push(e3);
  }
  return i2;
}
function R5(t3, e2) {
  const n2 = [], o2 = $getRoot2().getChildren();
  for (let r2 = 0; r2 < o2.length; r2++) {
    S3(t3, e2, o2[r2], n2);
  }
  return { namespace: t3._config.namespace, nodes: n2 };
}
function A3(t3) {
  const e2 = [];
  for (let o2 = 0; o2 < t3.length; o2++) {
    const r2 = t3[o2], i2 = $parseSerializedNode2(r2);
    $isTextNode2(i2) && $addNodeStyle2(i2), e2.push(i2);
  }
  return e2;
}
async function _4(t3, e2, n2) {
  if (null !== P4) return false;
  if (null !== e2) return new Promise((o3, r2) => {
    t3.update(() => {
      o3(E3(t3, e2, n2));
    });
  });
  const o2 = t3.getRootElement(), i2 = t3._window || window, l2 = window.document, s2 = getDOMSelection2(i2);
  if (null === o2 || null === s2) return false;
  const c2 = l2.createElement("span");
  c2.style.cssText = "position: fixed; top: -1000px;", c2.append(l2.createTextNode("#")), o2.append(c2);
  const a2 = new Range();
  return a2.setStart(c2, 0), a2.setEnd(c2, 1), s2.removeAllRanges(), s2.addRange(a2), new Promise((e3, o3) => {
    const i3 = t3.registerCommand(COPY_COMMAND2, (o4) => (objectKlassEquals2(o4, ClipboardEvent) && (i3(), null !== P4 && (window.clearTimeout(P4), P4 = null), e3(E3(t3, o4, n2))), true), COMMAND_PRIORITY_CRITICAL2);
    P4 = window.setTimeout(() => {
      i3(), P4 = null, e3(false);
    }, 50), l2.execCommand("copy"), c2.remove();
  });
}
function E3(t3, e2, n2) {
  if (void 0 === n2) {
    const e3 = getDOMSelection2(t3._window);
    if (!e3) return false;
    const o3 = e3.anchorNode, r2 = e3.focusNode;
    if (null !== o3 && null !== r2 && !isSelectionWithinEditor2(t3, o3, r2)) return false;
    const i2 = $getSelection2();
    if (null === i2) return false;
    n2 = M5(i2);
  }
  e2.preventDefault();
  const o2 = e2.clipboardData;
  return null !== o2 && (O5(o2, n2), true);
}
function M5(t3 = $getSelection2()) {
  const e2 = { "text/plain": t3 ? t3.getTextContent() : "" };
  if (t3) {
    const n2 = $getEditor2();
    for (const [o2, r2] of L4) {
      const i2 = r2(n2, t3);
      null !== i2 && (e2[o2] = i2);
    }
  }
  return e2;
}
function O5(t3, e2) {
  for (const n2 in e2) {
    const o2 = e2[n2];
    void 0 !== o2 && t3.setData(n2, o2);
  }
}
var P4, L4;
var init_LexicalClipboard_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/clipboard@0.32.1/node_modules/@lexical/clipboard/LexicalClipboard.prod.mjs"() {
    await init_LexicalHtml_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    P4 = null;
    L4 = [["text/html", T4], ["application/x-lexical-editor", v3]];
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/clipboard@0.32.1/node_modules/@lexical/clipboard/LexicalClipboard.node.mjs
var mod7, $generateJSONFromSelectedNodes2, $generateNodesFromSerializedNodes2, $getClipboardDataFromSelection2, $getHtmlContent2, $getLexicalContent2, $insertDataTransferForPlainText2, $insertDataTransferForRichText2, $insertGeneratedNodes2, copyToClipboard2, setLexicalClipboardDataTransfer2;
var init_LexicalClipboard_node = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/clipboard@0.32.1/node_modules/@lexical/clipboard/LexicalClipboard.node.mjs"() {
    mod7 = await (process.env.NODE_ENV !== "production" ? init_LexicalClipboard_dev().then(() => LexicalClipboard_dev_exports) : init_LexicalClipboard_prod().then(() => LexicalClipboard_prod_exports));
    $generateJSONFromSelectedNodes2 = mod7.$generateJSONFromSelectedNodes;
    $generateNodesFromSerializedNodes2 = mod7.$generateNodesFromSerializedNodes;
    $getClipboardDataFromSelection2 = mod7.$getClipboardDataFromSelection;
    $getHtmlContent2 = mod7.$getHtmlContent;
    $getLexicalContent2 = mod7.$getLexicalContent;
    $insertDataTransferForPlainText2 = mod7.$insertDataTransferForPlainText;
    $insertDataTransferForRichText2 = mod7.$insertDataTransferForRichText;
    $insertGeneratedNodes2 = mod7.$insertGeneratedNodes;
    copyToClipboard2 = mod7.copyToClipboard;
    setLexicalClipboardDataTransfer2 = mod7.setLexicalClipboardDataTransfer;
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/rich-text@0.32.1/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs
var LexicalRichText_dev_exports = {};
__export(LexicalRichText_dev_exports, {
  $createHeadingNode: () => $createHeadingNode,
  $createQuoteNode: () => $createQuoteNode,
  $isHeadingNode: () => $isHeadingNode,
  $isQuoteNode: () => $isQuoteNode,
  DRAG_DROP_PASTE: () => DRAG_DROP_PASTE,
  HeadingNode: () => HeadingNode,
  QuoteNode: () => QuoteNode,
  eventFiles: () => eventFiles,
  registerRichText: () => registerRichText
});
function caretFromPoint(x4, y4) {
  if (typeof document.caretRangeFromPoint !== "undefined") {
    const range = document.caretRangeFromPoint(x4, y4);
    if (range === null) {
      return null;
    }
    return {
      node: range.startContainer,
      offset: range.startOffset
    };
  } else if (document.caretPositionFromPoint !== "undefined") {
    const range = document.caretPositionFromPoint(x4, y4);
    if (range === null) {
      return null;
    }
    return {
      node: range.offsetNode,
      offset: range.offset
    };
  } else {
    return null;
  }
}
function $createQuoteNode() {
  return $applyNodeReplacement2(new QuoteNode());
}
function $isQuoteNode(node) {
  return node instanceof QuoteNode;
}
function isGoogleDocsTitle(domNode) {
  if (domNode.nodeName.toLowerCase() === "span") {
    return domNode.style.fontSize === "26pt";
  }
  return false;
}
function $convertHeadingElement(element) {
  const nodeName = element.nodeName.toLowerCase();
  let node = null;
  if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
    node = $createHeadingNode(nodeName);
    if (element.style !== null) {
      setNodeIndentFromDOM2(element, node);
      node.setFormat(element.style.textAlign);
    }
  }
  return {
    node
  };
}
function $convertBlockquoteElement(element) {
  const node = $createQuoteNode();
  if (element.style !== null) {
    node.setFormat(element.style.textAlign);
    setNodeIndentFromDOM2(element, node);
  }
  return {
    node
  };
}
function $createHeadingNode(headingTag = "h1") {
  return $applyNodeReplacement2(new HeadingNode(headingTag));
}
function $isHeadingNode(node) {
  return node instanceof HeadingNode;
}
function onPasteForRichText(event, editor) {
  event.preventDefault();
  editor.update(() => {
    const selection = $getSelection2();
    const clipboardData = objectKlassEquals2(event, InputEvent) || objectKlassEquals2(event, KeyboardEvent) ? null : event.clipboardData;
    if (clipboardData != null && selection !== null) {
      $insertDataTransferForRichText2(clipboardData, selection, editor);
    }
  }, {
    tag: PASTE_TAG2
  });
}
async function onCutForRichText(event, editor) {
  await copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null);
  editor.update(() => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      selection.removeText();
    } else if ($isNodeSelection2(selection)) {
      selection.getNodes().forEach((node) => node.remove());
    }
  });
}
function eventFiles(event) {
  let dataTransfer = null;
  if (objectKlassEquals2(event, DragEvent)) {
    dataTransfer = event.dataTransfer;
  } else if (objectKlassEquals2(event, ClipboardEvent)) {
    dataTransfer = event.clipboardData;
  }
  if (dataTransfer === null) {
    return [false, [], false];
  }
  const types = dataTransfer.types;
  const hasFiles = types.includes("Files");
  const hasContent = types.includes("text/html") || types.includes("text/plain");
  return [hasFiles, Array.from(dataTransfer.files), hasContent];
}
function $handleIndentAndOutdent(indentOrOutdent) {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection)) {
    return false;
  }
  const alreadyHandled = /* @__PURE__ */ new Set();
  const nodes = selection.getNodes();
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    const key2 = node.getKey();
    if (alreadyHandled.has(key2)) {
      continue;
    }
    const parentBlock = $findMatchingParent3(node, (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline());
    if (parentBlock === null) {
      continue;
    }
    const parentKey = parentBlock.getKey();
    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
      alreadyHandled.add(parentKey);
      indentOrOutdent(parentBlock);
    }
  }
  return alreadyHandled.size > 0;
}
function $isTargetWithinDecorator(target) {
  const node = $getNearestNodeFromDOMNode2(target);
  return $isDecoratorNode2(node);
}
function $isSelectionAtEndOfRoot(selection) {
  const focus = selection.focus;
  return focus.key === "root" && focus.offset === $getRoot2().getChildrenSize();
}
function $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {
  if (!selection.isCollapsed()) {
    return false;
  }
  const {
    anchor
  } = selection;
  if (anchor.offset !== 0) {
    return false;
  }
  const anchorNode = anchor.getNode();
  if ($isRootNode2(anchorNode)) {
    return false;
  }
  const element = $getNearestBlockElementAncestorOrThrow2(anchorNode);
  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));
}
function $resetCapitalization(selection) {
  for (const format of ["lowercase", "uppercase", "capitalize"]) {
    if (selection.hasFormat(format)) {
      selection.toggleFormat(format);
    }
  }
}
function registerRichText(editor) {
  const removeListener = mergeRegister2(editor.registerCommand(CLICK_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      selection.clear();
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_CHARACTER_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      selection.deleteCharacter(isBackward);
      return true;
    } else if ($isNodeSelection2(selection)) {
      selection.deleteNodes();
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_WORD_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteWord(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_LINE_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteLine(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (eventOrText) => {
    const selection = $getSelection2();
    if (typeof eventOrText === "string") {
      if (selection !== null) {
        selection.insertText(eventOrText);
      }
    } else {
      if (selection === null) {
        return false;
      }
      const dataTransfer = eventOrText.dataTransfer;
      if (dataTransfer != null) {
        $insertDataTransferForRichText2(dataTransfer, selection, editor);
      } else if ($isRangeSelection2(selection)) {
        const data = eventOrText.data;
        if (data) {
          selection.insertText(data);
        }
        return true;
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REMOVE_TEXT_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.removeText();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(FORMAT_TEXT_COMMAND2, (format) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.formatText(format);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(FORMAT_ELEMENT_COMMAND2, (format) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) && !$isNodeSelection2(selection)) {
      return false;
    }
    const nodes = selection.getNodes();
    for (const node of nodes) {
      const element = $findMatchingParent3(node, (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline());
      if (element !== null) {
        element.setFormat(format);
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_LINE_BREAK_COMMAND2, (selectStart) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.insertLineBreak(selectStart);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.insertParagraph();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_TAB_COMMAND2, () => {
    $insertNodes2([$createTabNode2()]);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INDENT_CONTENT_COMMAND2, () => {
    return $handleIndentAndOutdent((block) => {
      const indent = block.getIndent();
      block.setIndent(indent + 1);
    });
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(OUTDENT_CONTENT_COMMAND2, () => {
    return $handleIndentAndOutdent((block) => {
      const indent = block.getIndent();
      if (indent > 0) {
        block.setIndent(Math.max(0, indent - 1));
      }
    });
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        nodes[0].selectPrevious();
        return true;
      }
    } else if ($isRangeSelection2(selection)) {
      const possibleNode = $getAdjacentNode2(selection.focus, true);
      if (!event.shiftKey && $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
        possibleNode.selectPrevious();
        event.preventDefault();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        nodes[0].selectNext(0, 0);
        return true;
      }
    } else if ($isRangeSelection2(selection)) {
      if ($isSelectionAtEndOfRoot(selection)) {
        event.preventDefault();
        return true;
      }
      const possibleNode = $getAdjacentNode2(selection.focus, false);
      if (!event.shiftKey && $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
        possibleNode.selectNext();
        event.preventDefault();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        nodes[0].selectPrevious();
        return true;
      }
    }
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    if ($shouldOverrideDefaultCharacterSelection2(selection, true)) {
      const isHoldingShift = event.shiftKey;
      event.preventDefault();
      $moveCharacter2(selection, isHoldingShift, true);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        nodes[0].selectNext(0, 0);
        return true;
      }
    }
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection2(selection, false)) {
      event.preventDefault();
      $moveCharacter2(selection, isHoldingShift, false);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_BACKSPACE_COMMAND2, (event) => {
    if ($isTargetWithinDecorator(event.target)) {
      return false;
    }
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {
        event.preventDefault();
        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND2, void 0);
      }
      if (IS_IOS4 && navigator.language === "ko-KR") {
        return false;
      }
    } else if (!$isNodeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, true);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_DELETE_COMMAND2, (event) => {
    if ($isTargetWithinDecorator(event.target)) {
      return false;
    }
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isNodeSelection2(selection))) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, false);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ENTER_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    $resetCapitalization(selection);
    if (event !== null) {
      if ((IS_IOS4 || IS_SAFARI4 || IS_APPLE_WEBKIT4) && CAN_USE_BEFORE_INPUT4) {
        return false;
      }
      event.preventDefault();
      if (event.shiftKey) {
        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
      }
    }
    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ESCAPE_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    editor.blur();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DROP_COMMAND2, (event) => {
    const [, files] = eventFiles(event);
    if (files.length > 0) {
      const x4 = event.clientX;
      const y4 = event.clientY;
      const eventRange = caretFromPoint(x4, y4);
      if (eventRange !== null) {
        const {
          offset: domOffset,
          node: domNode
        } = eventRange;
        const node = $getNearestNodeFromDOMNode2(domNode);
        if (node !== null) {
          const selection2 = $createRangeSelection2();
          if ($isTextNode2(node)) {
            selection2.anchor.set(node.getKey(), domOffset, "text");
            selection2.focus.set(node.getKey(), domOffset, "text");
          } else {
            const parentKey = node.getParentOrThrow().getKey();
            const offset = node.getIndexWithinParent() + 1;
            selection2.anchor.set(parentKey, offset, "element");
            selection2.focus.set(parentKey, offset, "element");
          }
          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection2);
          $setSelection2(normalizedSelection);
        }
        editor.dispatchCommand(DRAG_DROP_PASTE, files);
      }
      event.preventDefault();
      return true;
    }
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGSTART_COMMAND2, (event) => {
    const [isFileTransfer] = eventFiles(event);
    const selection = $getSelection2();
    if (isFileTransfer && !$isRangeSelection2(selection)) {
      return false;
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGOVER_COMMAND2, (event) => {
    const [isFileTransfer] = eventFiles(event);
    const selection = $getSelection2();
    if (isFileTransfer && !$isRangeSelection2(selection)) {
      return false;
    }
    const x4 = event.clientX;
    const y4 = event.clientY;
    const eventRange = caretFromPoint(x4, y4);
    if (eventRange !== null) {
      const node = $getNearestNodeFromDOMNode2(eventRange.node);
      if ($isDecoratorNode2(node)) {
        event.preventDefault();
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECT_ALL_COMMAND2, () => {
    $selectAll2();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(COPY_COMMAND2, (event) => {
    copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CUT_COMMAND2, (event) => {
    onCutForRichText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(PASTE_COMMAND2, (event) => {
    const [, files, hasTextContent] = eventFiles(event);
    if (files.length > 0 && !hasTextContent) {
      editor.dispatchCommand(DRAG_DROP_PASTE, files);
      return true;
    }
    if (isDOMNode2(event.target) && isSelectionCapturedInDecoratorInput2(event.target)) {
      return false;
    }
    const selection = $getSelection2();
    if (selection !== null) {
      onPasteForRichText(event, editor);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_SPACE_COMMAND2, (_5) => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      $resetCapitalization(selection);
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_TAB_COMMAND2, (_5) => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      $resetCapitalization(selection);
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2));
  return removeListener;
}
var CAN_USE_DOM4, documentMode3, CAN_USE_BEFORE_INPUT4, IS_SAFARI4, IS_IOS4, IS_CHROME4, IS_APPLE_WEBKIT4, DRAG_DROP_PASTE, QuoteNode, HeadingNode;
var init_LexicalRichText_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/rich-text@0.32.1/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs"() {
    await init_LexicalClipboard_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    CAN_USE_DOM4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode3 = CAN_USE_DOM4 && "documentMode" in document ? document.documentMode : null;
    CAN_USE_BEFORE_INPUT4 = CAN_USE_DOM4 && "InputEvent" in window && !documentMode3 ? "getTargetRanges" in new window.InputEvent("input") : false;
    IS_SAFARI4 = CAN_USE_DOM4 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    IS_IOS4 = CAN_USE_DOM4 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_CHROME4 = CAN_USE_DOM4 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    IS_APPLE_WEBKIT4 = CAN_USE_DOM4 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME4;
    DRAG_DROP_PASTE = createCommand2("DRAG_DROP_PASTE_FILE");
    QuoteNode = class _QuoteNode extends ElementNode2 {
      static getType() {
        return "quote";
      }
      static clone(node) {
        return new _QuoteNode(node.__key);
      }
      // View
      createDOM(config) {
        const element = document.createElement("blockquote");
        addClassNamesToElement2(element, config.theme.quote);
        return element;
      }
      updateDOM(prevNode, dom2) {
        return false;
      }
      static importDOM() {
        return {
          blockquote: (node) => ({
            conversion: $convertBlockquoteElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (isHTMLElement3(element)) {
          if (this.isEmpty()) {
            element.append(document.createElement("br"));
          }
          const formatType = this.getFormatType();
          if (formatType) {
            element.style.textAlign = formatType;
          }
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        return $createQuoteNode().updateFromJSON(serializedNode);
      }
      // Mutation
      insertNewAfter(_5, restoreSelection) {
        const newBlock = $createParagraphNode2();
        const direction = this.getDirection();
        newBlock.setDirection(direction);
        this.insertAfter(newBlock, restoreSelection);
        return newBlock;
      }
      collapseAtStart() {
        const paragraph = $createParagraphNode2();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        this.replace(paragraph);
        return true;
      }
      canMergeWhenEmpty() {
        return true;
      }
    };
    HeadingNode = class _HeadingNode extends ElementNode2 {
      /** @internal */
      static getType() {
        return "heading";
      }
      static clone(node) {
        return new _HeadingNode(node.__tag, node.__key);
      }
      constructor(tag, key2) {
        super(key2);
        this.__tag = tag;
      }
      getTag() {
        return this.__tag;
      }
      setTag(tag) {
        const self = this.getWritable();
        this.__tag = tag;
        return self;
      }
      // View
      createDOM(config) {
        const tag = this.__tag;
        const element = document.createElement(tag);
        const theme = config.theme;
        const classNames2 = theme.heading;
        if (classNames2 !== void 0) {
          const className = classNames2[tag];
          addClassNamesToElement2(element, className);
        }
        return element;
      }
      updateDOM(prevNode, dom2, config) {
        return prevNode.__tag !== this.__tag;
      }
      static importDOM() {
        return {
          h1: (node) => ({
            conversion: $convertHeadingElement,
            priority: 0
          }),
          h2: (node) => ({
            conversion: $convertHeadingElement,
            priority: 0
          }),
          h3: (node) => ({
            conversion: $convertHeadingElement,
            priority: 0
          }),
          h4: (node) => ({
            conversion: $convertHeadingElement,
            priority: 0
          }),
          h5: (node) => ({
            conversion: $convertHeadingElement,
            priority: 0
          }),
          h6: (node) => ({
            conversion: $convertHeadingElement,
            priority: 0
          }),
          p: (node) => {
            const paragraph = node;
            const firstChild = paragraph.firstChild;
            if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
              return {
                conversion: () => ({
                  node: null
                }),
                priority: 3
              };
            }
            return null;
          },
          span: (node) => {
            if (isGoogleDocsTitle(node)) {
              return {
                conversion: (domNode) => {
                  return {
                    node: $createHeadingNode("h1")
                  };
                },
                priority: 3
              };
            }
            return null;
          }
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (isHTMLElement3(element)) {
          if (this.isEmpty()) {
            element.append(document.createElement("br"));
          }
          const formatType = this.getFormatType();
          if (formatType) {
            element.style.textAlign = formatType;
          }
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          tag: this.getTag()
        };
      }
      // Mutation
      insertNewAfter(selection, restoreSelection = true) {
        const anchorOffet = selection ? selection.anchor.offset : 0;
        const lastDesc = this.getLastDescendant();
        const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();
        const newElement = isAtEnd || !selection ? $createParagraphNode2() : $createHeadingNode(this.getTag());
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        if (anchorOffet === 0 && !this.isEmpty() && selection) {
          const paragraph = $createParagraphNode2();
          paragraph.select();
          this.replace(paragraph, true);
        }
        return newElement;
      }
      collapseAtStart() {
        const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode2();
        const children = this.getChildren();
        children.forEach((child) => newElement.append(child));
        this.replace(newElement);
        return true;
      }
      extractWithChild() {
        return true;
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/rich-text@0.32.1/node_modules/@lexical/rich-text/LexicalRichText.prod.mjs
var LexicalRichText_prod_exports = {};
__export(LexicalRichText_prod_exports, {
  $createHeadingNode: () => _t4,
  $createQuoteNode: () => xt3,
  $isHeadingNode: () => At3,
  $isQuoteNode: () => wt3,
  DRAG_DROP_PASTE: () => yt4,
  HeadingNode: () => Nt3,
  QuoteNode: () => Dt3,
  eventFiles: () => Ft2,
  registerRichText: () => Mt3
});
function dt4(t3, e2) {
  if (void 0 !== document.caretRangeFromPoint) {
    const n2 = document.caretRangeFromPoint(t3, e2);
    return null === n2 ? null : { node: n2.startContainer, offset: n2.startOffset };
  }
  if ("undefined" !== document.caretPositionFromPoint) {
    const n2 = document.caretPositionFromPoint(t3, e2);
    return null === n2 ? null : { node: n2.offsetNode, offset: n2.offset };
  }
  return null;
}
function xt3() {
  return $applyNodeReplacement2(new Dt3());
}
function wt3(t3) {
  return t3 instanceof Dt3;
}
function Et3(t3) {
  return "span" === t3.nodeName.toLowerCase() && "26pt" === t3.style.fontSize;
}
function Ot3(t3) {
  const e2 = t3.nodeName.toLowerCase();
  let n2 = null;
  return "h1" !== e2 && "h2" !== e2 && "h3" !== e2 && "h4" !== e2 && "h5" !== e2 && "h6" !== e2 || (n2 = _t4(e2), null !== t3.style && (setNodeIndentFromDOM2(t3, n2), n2.setFormat(t3.style.textAlign))), { node: n2 };
}
function Tt4(t3) {
  const e2 = xt3();
  return null !== t3.style && (e2.setFormat(t3.style.textAlign), setNodeIndentFromDOM2(t3, e2)), { node: e2 };
}
function _t4(t3 = "h1") {
  return $applyNodeReplacement2(new Nt3(t3));
}
function At3(t3) {
  return t3 instanceof Nt3;
}
function Ft2(t3) {
  let e2 = null;
  if (objectKlassEquals2(t3, DragEvent) ? e2 = t3.dataTransfer : objectKlassEquals2(t3, ClipboardEvent) && (e2 = t3.clipboardData), null === e2) return [false, [], false];
  const n2 = e2.types, r2 = n2.includes("Files"), o2 = n2.includes("text/html") || n2.includes("text/plain");
  return [r2, Array.from(e2.files), o2];
}
function St3(t3) {
  const e2 = $getSelection2();
  if (!$isRangeSelection2(e2)) return false;
  const n2 = /* @__PURE__ */ new Set(), r2 = e2.getNodes();
  for (let e3 = 0; e3 < r2.length; e3++) {
    const o2 = r2[e3], i2 = o2.getKey();
    if (n2.has(i2)) continue;
    const s2 = $findMatchingParent3(o2, (t4) => $isElementNode2(t4) && !t4.isInline());
    if (null === s2) continue;
    const a2 = s2.getKey();
    s2.canIndent() && !n2.has(a2) && (n2.add(a2), t3(s2));
  }
  return n2.size > 0;
}
function It2(t3) {
  const e2 = $getNearestNodeFromDOMNode2(t3);
  return $isDecoratorNode2(e2);
}
function Pt3(t3) {
  for (const e2 of ["lowercase", "uppercase", "capitalize"]) t3.hasFormat(e2) && t3.toggleFormat(e2);
}
function Mt3(o2) {
  return mergeRegister2(o2.registerCommand(CLICK_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return !!$isNodeSelection2(e2) && (e2.clear(), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(DELETE_CHARACTER_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return $isRangeSelection2(e2) ? (e2.deleteCharacter(t3), true) : !!$isNodeSelection2(e2) && (e2.deleteNodes(), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(DELETE_WORD_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return !!$isRangeSelection2(e2) && (e2.deleteWord(t3), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(DELETE_LINE_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return !!$isRangeSelection2(e2) && (e2.deleteLine(t3), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (e2) => {
    const n2 = $getSelection2();
    if ("string" == typeof e2) null !== n2 && n2.insertText(e2);
    else {
      if (null === n2) return false;
      const r2 = e2.dataTransfer;
      if (null != r2) $insertDataTransferForRichText2(r2, n2, o2);
      else if ($isRangeSelection2(n2)) {
        const t3 = e2.data;
        return t3 && n2.insertText(t3), true;
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(REMOVE_TEXT_COMMAND2, () => {
    const t3 = $getSelection2();
    return !!$isRangeSelection2(t3) && (t3.removeText(), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(FORMAT_TEXT_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return !!$isRangeSelection2(e2) && (e2.formatText(t3), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(FORMAT_ELEMENT_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    if (!$isRangeSelection2(e2) && !$isNodeSelection2(e2)) return false;
    const n2 = e2.getNodes();
    for (const e3 of n2) {
      const n3 = $findMatchingParent3(e3, (t4) => $isElementNode2(t4) && !t4.isInline());
      null !== n3 && n3.setFormat(t3);
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(INSERT_LINE_BREAK_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return !!$isRangeSelection2(e2) && (e2.insertLineBreak(t3), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const t3 = $getSelection2();
    return !!$isRangeSelection2(t3) && (t3.insertParagraph(), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(INSERT_TAB_COMMAND2, () => ($insertNodes2([$createTabNode2()]), true), COMMAND_PRIORITY_EDITOR2), o2.registerCommand(INDENT_CONTENT_COMMAND2, () => St3((t3) => {
    const e2 = t3.getIndent();
    t3.setIndent(e2 + 1);
  }), COMMAND_PRIORITY_EDITOR2), o2.registerCommand(OUTDENT_CONTENT_COMMAND2, () => St3((t3) => {
    const e2 = t3.getIndent();
    e2 > 0 && t3.setIndent(Math.max(0, e2 - 1));
  }), COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_ARROW_UP_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    if ($isNodeSelection2(e2)) {
      const t4 = e2.getNodes();
      if (t4.length > 0) return t4[0].selectPrevious(), true;
    } else if ($isRangeSelection2(e2)) {
      const n2 = $getAdjacentNode2(e2.focus, true);
      if (!t3.shiftKey && $isDecoratorNode2(n2) && !n2.isIsolated() && !n2.isInline()) return n2.selectPrevious(), t3.preventDefault(), true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_ARROW_DOWN_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    if ($isNodeSelection2(e2)) {
      const t4 = e2.getNodes();
      if (t4.length > 0) return t4[0].selectNext(0, 0), true;
    } else if ($isRangeSelection2(e2)) {
      if (function(t4) {
        const e3 = t4.focus;
        return "root" === e3.key && e3.offset === $getRoot2().getChildrenSize();
      }(e2)) return t3.preventDefault(), true;
      const n2 = $getAdjacentNode2(e2.focus, false);
      if (!t3.shiftKey && $isDecoratorNode2(n2) && !n2.isIsolated() && !n2.isInline()) return n2.selectNext(), t3.preventDefault(), true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_ARROW_LEFT_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    if ($isNodeSelection2(e2)) {
      const n2 = e2.getNodes();
      if (n2.length > 0) return t3.preventDefault(), n2[0].selectPrevious(), true;
    }
    if (!$isRangeSelection2(e2)) return false;
    if ($shouldOverrideDefaultCharacterSelection2(e2, true)) {
      const n2 = t3.shiftKey;
      return t3.preventDefault(), $moveCharacter2(e2, n2, true), true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    if ($isNodeSelection2(e2)) {
      const n2 = e2.getNodes();
      if (n2.length > 0) return t3.preventDefault(), n2[0].selectNext(0, 0), true;
    }
    if (!$isRangeSelection2(e2)) return false;
    const o3 = t3.shiftKey;
    return !!$shouldOverrideDefaultCharacterSelection2(e2, false) && (t3.preventDefault(), $moveCharacter2(e2, o3, false), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_BACKSPACE_COMMAND2, (t3) => {
    if (It2(t3.target)) return false;
    const e2 = $getSelection2();
    if ($isRangeSelection2(e2)) {
      if (function(t4) {
        if (!t4.isCollapsed()) return false;
        const { anchor: e3 } = t4;
        if (0 !== e3.offset) return false;
        const n2 = e3.getNode();
        if ($isRootNode2(n2)) return false;
        const r2 = $getNearestBlockElementAncestorOrThrow2(n2);
        return r2.getIndent() > 0 && (r2.is(n2) || n2.is(r2.getFirstDescendant()));
      }(e2)) return t3.preventDefault(), o2.dispatchCommand(OUTDENT_CONTENT_COMMAND2, void 0);
      if (ht4 && "ko-KR" === navigator.language) return false;
    } else if (!$isNodeSelection2(e2)) return false;
    return t3.preventDefault(), o2.dispatchCommand(DELETE_CHARACTER_COMMAND2, true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_DELETE_COMMAND2, (t3) => {
    if (It2(t3.target)) return false;
    const e2 = $getSelection2();
    return !(!$isRangeSelection2(e2) && !$isNodeSelection2(e2)) && (t3.preventDefault(), o2.dispatchCommand(DELETE_CHARACTER_COMMAND2, false));
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_ENTER_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    if (!$isRangeSelection2(e2)) return false;
    if (Pt3(e2), null !== t3) {
      if ((ht4 || pt4 || vt3) && gt4) return false;
      if (t3.preventDefault(), t3.shiftKey) return o2.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
    }
    return o2.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_ESCAPE_COMMAND2, () => {
    const t3 = $getSelection2();
    return !!$isRangeSelection2(t3) && (o2.blur(), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(DROP_COMMAND2, (t3) => {
    const [, e2] = Ft2(t3);
    if (e2.length > 0) {
      const n3 = dt4(t3.clientX, t3.clientY);
      if (null !== n3) {
        const { offset: t4, node: r2 } = n3, i2 = $getNearestNodeFromDOMNode2(r2);
        if (null !== i2) {
          const e3 = $createRangeSelection2();
          if ($isTextNode2(i2)) e3.anchor.set(i2.getKey(), t4, "text"), e3.focus.set(i2.getKey(), t4, "text");
          else {
            const t5 = i2.getParentOrThrow().getKey(), n5 = i2.getIndexWithinParent() + 1;
            e3.anchor.set(t5, n5, "element"), e3.focus.set(t5, n5, "element");
          }
          const n4 = $normalizeSelection__EXPERIMENTAL(e3);
          $setSelection2(n4);
        }
        o2.dispatchCommand(yt4, e2);
      }
      return t3.preventDefault(), true;
    }
    const n2 = $getSelection2();
    return !!$isRangeSelection2(n2);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(DRAGSTART_COMMAND2, (t3) => {
    const [e2] = Ft2(t3), n2 = $getSelection2();
    return !(e2 && !$isRangeSelection2(n2));
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(DRAGOVER_COMMAND2, (t3) => {
    const [e2] = Ft2(t3), n2 = $getSelection2();
    if (e2 && !$isRangeSelection2(n2)) return false;
    const r2 = dt4(t3.clientX, t3.clientY);
    if (null !== r2) {
      const e3 = $getNearestNodeFromDOMNode2(r2.node);
      $isDecoratorNode2(e3) && t3.preventDefault();
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(SELECT_ALL_COMMAND2, () => ($selectAll2(), true), COMMAND_PRIORITY_EDITOR2), o2.registerCommand(COPY_COMMAND2, (t3) => (copyToClipboard2(o2, objectKlassEquals2(t3, ClipboardEvent) ? t3 : null), true), COMMAND_PRIORITY_EDITOR2), o2.registerCommand(CUT_COMMAND2, (t3) => (async function(t4, n2) {
    await copyToClipboard2(n2, objectKlassEquals2(t4, ClipboardEvent) ? t4 : null), n2.update(() => {
      const t5 = $getSelection2();
      $isRangeSelection2(t5) ? t5.removeText() : $isNodeSelection2(t5) && t5.getNodes().forEach((t6) => t6.remove());
    });
  }(t3, o2), true), COMMAND_PRIORITY_EDITOR2), o2.registerCommand(PASTE_COMMAND2, (e2) => {
    const [, n2, r2] = Ft2(e2);
    if (n2.length > 0 && !r2) return o2.dispatchCommand(yt4, n2), true;
    if (isDOMNode2(e2.target) && isSelectionCapturedInDecoratorInput2(e2.target)) return false;
    return null !== $getSelection2() && (function(e3, n3) {
      e3.preventDefault(), n3.update(() => {
        const r3 = $getSelection2(), o3 = objectKlassEquals2(e3, InputEvent) || objectKlassEquals2(e3, KeyboardEvent) ? null : e3.clipboardData;
        null != o3 && null !== r3 && $insertDataTransferForRichText2(o3, r3, n3);
      }, { tag: PASTE_TAG2 });
    }(e2, o2), true);
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_SPACE_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return $isRangeSelection2(e2) && Pt3(e2), false;
  }, COMMAND_PRIORITY_EDITOR2), o2.registerCommand(KEY_TAB_COMMAND2, (t3) => {
    const e2 = $getSelection2();
    return $isRangeSelection2(e2) && Pt3(e2), false;
  }, COMMAND_PRIORITY_EDITOR2));
}
var mt4, ft4, gt4, pt4, ht4, Ct4, vt3, yt4, Dt3, Nt3;
var init_LexicalRichText_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/rich-text@0.32.1/node_modules/@lexical/rich-text/LexicalRichText.prod.mjs"() {
    await init_LexicalClipboard_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    mt4 = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    ft4 = mt4 && "documentMode" in document ? document.documentMode : null;
    gt4 = !(!mt4 || !("InputEvent" in window) || ft4) && "getTargetRanges" in new window.InputEvent("input");
    pt4 = mt4 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    ht4 = mt4 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    Ct4 = mt4 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    vt3 = mt4 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !Ct4;
    yt4 = createCommand2("DRAG_DROP_PASTE_FILE");
    Dt3 = class _Dt extends ElementNode2 {
      static getType() {
        return "quote";
      }
      static clone(t3) {
        return new _Dt(t3.__key);
      }
      createDOM(t3) {
        const e2 = document.createElement("blockquote");
        return addClassNamesToElement2(e2, t3.theme.quote), e2;
      }
      updateDOM(t3, e2) {
        return false;
      }
      static importDOM() {
        return { blockquote: (t3) => ({ conversion: Tt4, priority: 0 }) };
      }
      exportDOM(t3) {
        const { element: e2 } = super.exportDOM(t3);
        if (isHTMLElement3(e2)) {
          this.isEmpty() && e2.append(document.createElement("br"));
          const t4 = this.getFormatType();
          t4 && (e2.style.textAlign = t4);
          const n2 = this.getDirection();
          n2 && (e2.dir = n2);
        }
        return { element: e2 };
      }
      static importJSON(t3) {
        return xt3().updateFromJSON(t3);
      }
      insertNewAfter(t3, e2) {
        const n2 = $createParagraphNode2(), r2 = this.getDirection();
        return n2.setDirection(r2), this.insertAfter(n2, e2), n2;
      }
      collapseAtStart() {
        const t3 = $createParagraphNode2();
        return this.getChildren().forEach((e2) => t3.append(e2)), this.replace(t3), true;
      }
      canMergeWhenEmpty() {
        return true;
      }
    };
    Nt3 = class _Nt extends ElementNode2 {
      static getType() {
        return "heading";
      }
      static clone(t3) {
        return new _Nt(t3.__tag, t3.__key);
      }
      constructor(t3, e2) {
        super(e2), this.__tag = t3;
      }
      getTag() {
        return this.__tag;
      }
      setTag(t3) {
        const e2 = this.getWritable();
        return this.__tag = t3, e2;
      }
      createDOM(t3) {
        const e2 = this.__tag, n2 = document.createElement(e2), r2 = t3.theme.heading;
        if (void 0 !== r2) {
          const t4 = r2[e2];
          addClassNamesToElement2(n2, t4);
        }
        return n2;
      }
      updateDOM(t3, e2, n2) {
        return t3.__tag !== this.__tag;
      }
      static importDOM() {
        return { h1: (t3) => ({ conversion: Ot3, priority: 0 }), h2: (t3) => ({ conversion: Ot3, priority: 0 }), h3: (t3) => ({ conversion: Ot3, priority: 0 }), h4: (t3) => ({ conversion: Ot3, priority: 0 }), h5: (t3) => ({ conversion: Ot3, priority: 0 }), h6: (t3) => ({ conversion: Ot3, priority: 0 }), p: (t3) => {
          const e2 = t3.firstChild;
          return null !== e2 && Et3(e2) ? { conversion: () => ({ node: null }), priority: 3 } : null;
        }, span: (t3) => Et3(t3) ? { conversion: (t4) => ({ node: _t4("h1") }), priority: 3 } : null };
      }
      exportDOM(t3) {
        const { element: e2 } = super.exportDOM(t3);
        if (isHTMLElement3(e2)) {
          this.isEmpty() && e2.append(document.createElement("br"));
          const t4 = this.getFormatType();
          t4 && (e2.style.textAlign = t4);
          const n2 = this.getDirection();
          n2 && (e2.dir = n2);
        }
        return { element: e2 };
      }
      static importJSON(t3) {
        return _t4(t3.tag).updateFromJSON(t3);
      }
      updateFromJSON(t3) {
        return super.updateFromJSON(t3).setTag(t3.tag);
      }
      exportJSON() {
        return { ...super.exportJSON(), tag: this.getTag() };
      }
      insertNewAfter(t3, e2 = true) {
        const n2 = t3 ? t3.anchor.offset : 0, r2 = this.getLastDescendant(), o2 = !r2 || t3 && t3.anchor.key === r2.getKey() && n2 === r2.getTextContentSize() || !t3 ? $createParagraphNode2() : _t4(this.getTag()), i2 = this.getDirection();
        if (o2.setDirection(i2), this.insertAfter(o2, e2), 0 === n2 && !this.isEmpty() && t3) {
          const t4 = $createParagraphNode2();
          t4.select(), this.replace(t4, true);
        }
        return o2;
      }
      collapseAtStart() {
        const t3 = this.isEmpty() ? $createParagraphNode2() : _t4(this.getTag());
        return this.getChildren().forEach((e2) => t3.append(e2)), this.replace(t3), true;
      }
      extractWithChild() {
        return true;
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/table@0.32.1/node_modules/@lexical/table/LexicalTable.dev.mjs
var LexicalTable_dev_exports = {};
__export(LexicalTable_dev_exports, {
  $computeTableMap: () => $computeTableMap,
  $computeTableMapSkipCellCheck: () => $computeTableMapSkipCellCheck,
  $createTableCellNode: () => $createTableCellNode,
  $createTableNode: () => $createTableNode,
  $createTableNodeWithDimensions: () => $createTableNodeWithDimensions,
  $createTableRowNode: () => $createTableRowNode,
  $createTableSelection: () => $createTableSelection,
  $createTableSelectionFrom: () => $createTableSelectionFrom,
  $deleteTableColumn: () => $deleteTableColumn,
  $deleteTableColumnAtSelection: () => $deleteTableColumnAtSelection,
  $deleteTableColumn__EXPERIMENTAL: () => $deleteTableColumn__EXPERIMENTAL,
  $deleteTableRowAtSelection: () => $deleteTableRowAtSelection,
  $deleteTableRow__EXPERIMENTAL: () => $deleteTableRow__EXPERIMENTAL,
  $findCellNode: () => $findCellNode,
  $findTableNode: () => $findTableNode,
  $getElementForTableNode: () => $getElementForTableNode,
  $getNodeTriplet: () => $getNodeTriplet,
  $getTableAndElementByKey: () => $getTableAndElementByKey,
  $getTableCellNodeFromLexicalNode: () => $getTableCellNodeFromLexicalNode,
  $getTableCellNodeRect: () => $getTableCellNodeRect,
  $getTableColumnIndexFromTableCellNode: () => $getTableColumnIndexFromTableCellNode,
  $getTableNodeFromLexicalNodeOrThrow: () => $getTableNodeFromLexicalNodeOrThrow,
  $getTableRowIndexFromTableCellNode: () => $getTableRowIndexFromTableCellNode,
  $getTableRowNodeFromTableCellNodeOrThrow: () => $getTableRowNodeFromTableCellNodeOrThrow,
  $insertTableColumn: () => $insertTableColumn,
  $insertTableColumnAtSelection: () => $insertTableColumnAtSelection,
  $insertTableColumn__EXPERIMENTAL: () => $insertTableColumn__EXPERIMENTAL,
  $insertTableRow: () => $insertTableRow,
  $insertTableRowAtSelection: () => $insertTableRowAtSelection,
  $insertTableRow__EXPERIMENTAL: () => $insertTableRow__EXPERIMENTAL,
  $isScrollableTablesActive: () => $isScrollableTablesActive,
  $isTableCellNode: () => $isTableCellNode,
  $isTableNode: () => $isTableNode,
  $isTableRowNode: () => $isTableRowNode,
  $isTableSelection: () => $isTableSelection,
  $mergeCells: () => $mergeCells,
  $removeTableRowAtIndex: () => $removeTableRowAtIndex,
  $unmergeCell: () => $unmergeCell,
  INSERT_TABLE_COMMAND: () => INSERT_TABLE_COMMAND,
  TableCellHeaderStates: () => TableCellHeaderStates,
  TableCellNode: () => TableCellNode,
  TableNode: () => TableNode,
  TableObserver: () => TableObserver,
  TableRowNode: () => TableRowNode,
  applyTableHandlers: () => applyTableHandlers,
  getDOMCellFromTarget: () => getDOMCellFromTarget,
  getTableElement: () => getTableElement,
  getTableObserverFromTableElement: () => getTableObserverFromTableElement,
  registerTableCellUnmergeTransform: () => registerTableCellUnmergeTransform,
  registerTablePlugin: () => registerTablePlugin,
  registerTableSelectionObserver: () => registerTableSelectionObserver,
  setScrollableTablesActive: () => setScrollableTablesActive
});
function isValidVerticalAlign(verticalAlign) {
  return verticalAlign === "middle" || verticalAlign === "bottom";
}
function $convertTableCellNodeElement(domNode) {
  const domNode_ = domNode;
  const nodeName = domNode.nodeName.toLowerCase();
  let width = void 0;
  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {
    width = parseFloat(domNode_.style.width);
  }
  const tableCellNode = $createTableCellNode(nodeName === "th" ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);
  tableCellNode.__rowSpan = domNode_.rowSpan;
  const backgroundColor = domNode_.style.backgroundColor;
  if (backgroundColor !== "") {
    tableCellNode.__backgroundColor = backgroundColor;
  }
  const verticalAlign = domNode_.style.verticalAlign;
  if (isValidVerticalAlign(verticalAlign)) {
    tableCellNode.__verticalAlign = verticalAlign;
  }
  const style = domNode_.style;
  const textDecoration = (style && style.textDecoration || "").split(" ");
  const hasBoldFontWeight = style.fontWeight === "700" || style.fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  return {
    after: (childLexicalNodes) => {
      const result = [];
      let paragraphNode = null;
      const removeSingleLineBreakNode = () => {
        if (paragraphNode) {
          const firstChild = paragraphNode.getFirstChild();
          if ($isLineBreakNode2(firstChild) && paragraphNode.getChildrenSize() === 1) {
            firstChild.remove();
          }
        }
      };
      for (const child of childLexicalNodes) {
        if ($isInlineElementOrDecoratorNode2(child) || $isTextNode2(child) || $isLineBreakNode2(child)) {
          if ($isTextNode2(child)) {
            if (hasBoldFontWeight) {
              child.toggleFormat("bold");
            }
            if (hasLinethroughTextDecoration) {
              child.toggleFormat("strikethrough");
            }
            if (hasItalicFontStyle) {
              child.toggleFormat("italic");
            }
            if (hasUnderlineTextDecoration) {
              child.toggleFormat("underline");
            }
          }
          if (paragraphNode) {
            paragraphNode.append(child);
          } else {
            paragraphNode = $createParagraphNode2().append(child);
            result.push(paragraphNode);
          }
        } else {
          result.push(child);
          removeSingleLineBreakNode();
          paragraphNode = null;
        }
      }
      removeSingleLineBreakNode();
      if (result.length === 0) {
        result.push($createParagraphNode2());
      }
      return result;
    },
    node: tableCellNode
  };
}
function $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {
  return $applyNodeReplacement2(new TableCellNode(headerState, colSpan, width));
}
function $isTableCellNode(node) {
  return node instanceof TableCellNode;
}
function formatDevErrorMessage7(message) {
  throw new Error(message);
}
function $convertTableRowElement(domNode) {
  const domNode_ = domNode;
  let height = void 0;
  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {
    height = parseFloat(domNode_.style.height);
  }
  return {
    after: (children) => $descendantsMatching2(children, $isTableCellNode),
    node: $createTableRowNode(height)
  };
}
function $createTableRowNode(height) {
  return $applyNodeReplacement2(new TableRowNode(height));
}
function $isTableRowNode(node) {
  return node instanceof TableRowNode;
}
function $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {
  const tableNode = $createTableNode();
  for (let iRow = 0; iRow < rowCount; iRow++) {
    const tableRowNode = $createTableRowNode();
    for (let iColumn = 0; iColumn < columnCount; iColumn++) {
      let headerState = TableCellHeaderStates.NO_STATUS;
      if (typeof includeHeaders === "object") {
        if (iRow === 0 && includeHeaders.rows) {
          headerState |= TableCellHeaderStates.ROW;
        }
        if (iColumn === 0 && includeHeaders.columns) {
          headerState |= TableCellHeaderStates.COLUMN;
        }
      } else if (includeHeaders) {
        if (iRow === 0) {
          headerState |= TableCellHeaderStates.ROW;
        }
        if (iColumn === 0) {
          headerState |= TableCellHeaderStates.COLUMN;
        }
      }
      const tableCellNode = $createTableCellNode(headerState);
      const paragraphNode = $createParagraphNode2();
      paragraphNode.append($createTextNode2());
      tableCellNode.append(paragraphNode);
      tableRowNode.append(tableCellNode);
    }
    tableNode.append(tableRowNode);
  }
  return tableNode;
}
function $getTableCellNodeFromLexicalNode(startingNode) {
  const node = $findMatchingParent3(startingNode, (n2) => $isTableCellNode(n2));
  if ($isTableCellNode(node)) {
    return node;
  }
  return null;
}
function $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {
  const node = $findMatchingParent3(startingNode, (n2) => $isTableRowNode(n2));
  if ($isTableRowNode(node)) {
    return node;
  }
  throw new Error("Expected table cell to be inside of table row.");
}
function $getTableNodeFromLexicalNodeOrThrow(startingNode) {
  const node = $findMatchingParent3(startingNode, (n2) => $isTableNode(n2));
  if ($isTableNode(node)) {
    return node;
  }
  throw new Error("Expected table cell to be inside of table.");
}
function $getTableRowIndexFromTableCellNode(tableCellNode) {
  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);
  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);
  return tableNode.getChildren().findIndex((n2) => n2.is(tableRowNode));
}
function $getTableColumnIndexFromTableCellNode(tableCellNode) {
  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);
  return tableRowNode.getChildren().findIndex((n2) => n2.is(tableCellNode));
}
function $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {
  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);
  const {
    x: x4,
    y: y4
  } = tableNode.getCordsFromCellNode(tableCellNode, table);
  return {
    above: tableNode.getCellNodeFromCords(x4, y4 - 1, table),
    below: tableNode.getCellNodeFromCords(x4, y4 + 1, table),
    left: tableNode.getCellNodeFromCords(x4 - 1, y4, table),
    right: tableNode.getCellNodeFromCords(x4 + 1, y4, table)
  };
}
function $removeTableRowAtIndex(tableNode, indexToDelete) {
  const tableRows = tableNode.getChildren();
  if (indexToDelete >= tableRows.length || indexToDelete < 0) {
    throw new Error("Expected table cell to be inside of table row.");
  }
  const targetRowNode = tableRows[indexToDelete];
  targetRowNode.remove();
  return tableNode;
}
function $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {
  const tableRows = tableNode.getChildren();
  if (targetIndex >= tableRows.length || targetIndex < 0) {
    throw new Error("Table row target index out of range");
  }
  const targetRowNode = tableRows[targetIndex];
  if ($isTableRowNode(targetRowNode)) {
    for (let r2 = 0; r2 < rowCount; r2++) {
      const tableRowCells = targetRowNode.getChildren();
      const tableColumnCount = tableRowCells.length;
      const newTableRowNode = $createTableRowNode();
      for (let c2 = 0; c2 < tableColumnCount; c2++) {
        const tableCellFromTargetRow = tableRowCells[c2];
        if (!$isTableCellNode(tableCellFromTargetRow)) {
          formatDevErrorMessage7(`Expected table cell`);
        }
        const {
          above,
          below
        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);
        let headerState = TableCellHeaderStates.NO_STATUS;
        const width = above && above.getWidth() || below && below.getWidth() || void 0;
        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {
          headerState |= TableCellHeaderStates.COLUMN;
        }
        const tableCellNode = $createTableCellNode(headerState, 1, width);
        tableCellNode.append($createParagraphNode2());
        newTableRowNode.append(tableCellNode);
      }
      if (shouldInsertAfter) {
        targetRowNode.insertAfter(newTableRowNode);
      } else {
        targetRowNode.insertBefore(newTableRowNode);
      }
    }
  } else {
    throw new Error("Row before insertion index does not exist.");
  }
  return tableNode;
}
function $insertTableRowAtSelection(insertAfter = true) {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage7(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const focus = selection.focus.getNode();
  const [anchorCell] = $getNodeTriplet(anchor);
  const [focusCell, , grid] = $getNodeTriplet(focus);
  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);
  const {
    startRow: anchorStartRow
  } = anchorCellMap;
  const {
    startRow: focusStartRow
  } = focusCellMap;
  if (insertAfter) {
    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);
  } else {
    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);
  }
}
function $insertTableRowAtNode(cellNode, insertAfter = true) {
  const [, , grid] = $getNodeTriplet(cellNode);
  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);
  const columnCount = gridMap[0].length;
  const {
    startRow: cellStartRow
  } = cellMap;
  let insertedRow = null;
  if (insertAfter) {
    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;
    const insertAfterEndRowMap = gridMap[insertAfterEndRow];
    const newRow = $createTableRowNode();
    for (let i2 = 0; i2 < columnCount; i2++) {
      const {
        cell,
        startRow
      } = insertAfterEndRowMap[i2];
      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {
        const currentCell = insertAfterEndRowMap[i2].cell;
        const currentCellHeaderState = currentCell.__headerState;
        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);
        newRow.append($createTableCellNode(headerState).append($createParagraphNode2()));
      } else {
        cell.setRowSpan(cell.__rowSpan + 1);
      }
    }
    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);
    if (!$isTableRowNode(insertAfterEndRowNode)) {
      formatDevErrorMessage7(`insertAfterEndRow is not a TableRowNode`);
    }
    insertAfterEndRowNode.insertAfter(newRow);
    insertedRow = newRow;
  } else {
    const insertBeforeStartRow = cellStartRow;
    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];
    const newRow = $createTableRowNode();
    for (let i2 = 0; i2 < columnCount; i2++) {
      const {
        cell,
        startRow
      } = insertBeforeStartRowMap[i2];
      if (startRow === insertBeforeStartRow) {
        const currentCell = insertBeforeStartRowMap[i2].cell;
        const currentCellHeaderState = currentCell.__headerState;
        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);
        newRow.append($createTableCellNode(headerState).append($createParagraphNode2()));
      } else {
        cell.setRowSpan(cell.__rowSpan + 1);
      }
    }
    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);
    if (!$isTableRowNode(insertBeforeStartRowNode)) {
      formatDevErrorMessage7(`insertBeforeStartRow is not a TableRowNode`);
    }
    insertBeforeStartRowNode.insertBefore(newRow);
    insertedRow = newRow;
  }
  return insertedRow;
}
function $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {
  const tableRows = tableNode.getChildren();
  const tableCellsToBeInserted = [];
  for (let r2 = 0; r2 < tableRows.length; r2++) {
    const currentTableRowNode = tableRows[r2];
    if ($isTableRowNode(currentTableRowNode)) {
      for (let c2 = 0; c2 < columnCount; c2++) {
        const tableRowChildren = currentTableRowNode.getChildren();
        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {
          throw new Error("Table column target index out of range");
        }
        const targetCell = tableRowChildren[targetIndex];
        if (!$isTableCellNode(targetCell)) {
          formatDevErrorMessage7(`Expected table cell`);
        }
        const {
          left,
          right
        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);
        let headerState = TableCellHeaderStates.NO_STATUS;
        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {
          headerState |= TableCellHeaderStates.ROW;
        }
        const newTableCell = $createTableCellNode(headerState);
        newTableCell.append($createParagraphNode2());
        tableCellsToBeInserted.push({
          newTableCell,
          targetCell
        });
      }
    }
  }
  tableCellsToBeInserted.forEach(({
    newTableCell,
    targetCell
  }) => {
    if (shouldInsertAfter) {
      targetCell.insertAfter(newTableCell);
    } else {
      targetCell.insertBefore(newTableCell);
    }
  });
  return tableNode;
}
function $insertTableColumnAtSelection(insertAfter = true) {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage7(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const focus = selection.focus.getNode();
  const [anchorCell] = $getNodeTriplet(anchor);
  const [focusCell, , grid] = $getNodeTriplet(focus);
  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);
  const {
    startColumn: anchorStartColumn
  } = anchorCellMap;
  const {
    startColumn: focusStartColumn
  } = focusCellMap;
  if (insertAfter) {
    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);
  } else {
    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);
  }
}
function $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {
  const [, , grid] = $getNodeTriplet(cellNode);
  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);
  const rowCount = gridMap.length;
  const {
    startColumn
  } = cellMap;
  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;
  const gridFirstChild = grid.getFirstChild();
  if (!$isTableRowNode(gridFirstChild)) {
    formatDevErrorMessage7(`Expected firstTable child to be a row`);
  }
  let firstInsertedCell = null;
  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {
    const cell = $createTableCellNode(headerState).append($createParagraphNode2());
    if (firstInsertedCell === null) {
      firstInsertedCell = cell;
    }
    return cell;
  }
  let loopRow = gridFirstChild;
  rowLoop: for (let i2 = 0; i2 < rowCount; i2++) {
    if (i2 !== 0) {
      const currentRow = loopRow.getNextSibling();
      if (!$isTableRowNode(currentRow)) {
        formatDevErrorMessage7(`Expected row nextSibling to be a row`);
      }
      loopRow = currentRow;
    }
    const rowMap = gridMap[i2];
    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;
    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);
    if (insertAfterColumn < 0) {
      $insertFirst3(loopRow, $createTableCellNodeForInsertTableColumn(headerState));
      continue;
    }
    const {
      cell: currentCell,
      startColumn: currentStartColumn,
      startRow: currentStartRow
    } = rowMap[insertAfterColumn];
    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {
      let insertAfterCell = currentCell;
      let insertAfterCellRowStart = currentStartRow;
      let prevCellIndex = insertAfterColumn;
      while (insertAfterCellRowStart !== i2 && insertAfterCell.__rowSpan > 1) {
        prevCellIndex -= currentCell.__colSpan;
        if (prevCellIndex >= 0) {
          const {
            cell: cell_,
            startRow: startRow_
          } = rowMap[prevCellIndex];
          insertAfterCell = cell_;
          insertAfterCellRowStart = startRow_;
        } else {
          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));
          continue rowLoop;
        }
      }
      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));
    } else {
      currentCell.setColSpan(currentCell.__colSpan + 1);
    }
  }
  if (firstInsertedCell !== null && shouldSetSelection) {
    $moveSelectionToCell(firstInsertedCell);
  }
  const colWidths = grid.getColWidths();
  if (colWidths) {
    const newColWidths = [...colWidths];
    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;
    const newWidth = newColWidths[columnIndex];
    newColWidths.splice(columnIndex, 0, newWidth);
    grid.setColWidths(newColWidths);
  }
  return firstInsertedCell;
}
function $deleteTableColumn(tableNode, targetIndex) {
  const tableRows = tableNode.getChildren();
  for (let i2 = 0; i2 < tableRows.length; i2++) {
    const currentTableRowNode = tableRows[i2];
    if ($isTableRowNode(currentTableRowNode)) {
      const tableRowChildren = currentTableRowNode.getChildren();
      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {
        throw new Error("Table column target index out of range");
      }
      tableRowChildren[targetIndex].remove();
    }
  }
  return tableNode;
}
function $deleteTableRowAtSelection() {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage7(`Expected a RangeSelection or TableSelection`);
  }
  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];
  const [anchorCell, , grid] = $getNodeTriplet(anchor);
  const [focusCell] = $getNodeTriplet(focus);
  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);
  const {
    startRow: anchorStartRow
  } = anchorCellMap;
  const {
    startRow: focusStartRow
  } = focusCellMap;
  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;
  if (gridMap.length === focusEndRow - anchorStartRow + 1) {
    grid.remove();
    return;
  }
  const columnCount = gridMap[0].length;
  const nextRow = gridMap[focusEndRow + 1];
  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);
  for (let row = focusEndRow; row >= anchorStartRow; row--) {
    for (let column = columnCount - 1; column >= 0; column--) {
      const {
        cell,
        startRow: cellStartRow,
        startColumn: cellStartColumn
      } = gridMap[row][column];
      if (cellStartColumn !== column) {
        continue;
      }
      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {
        const intersectionStart = Math.max(cellStartRow, anchorStartRow);
        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);
        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;
        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);
      }
      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow && // Handle overflow only once
      row === focusEndRow) {
        if (!(nextRowNode !== null)) {
          formatDevErrorMessage7(`Expected nextRowNode not to be null`);
        }
        let insertAfterCell = null;
        for (let columnIndex = 0; columnIndex < column; columnIndex++) {
          const currentCellMap = nextRow[columnIndex];
          const currentCell = currentCellMap.cell;
          if (currentCellMap.startRow === row + 1) {
            insertAfterCell = currentCell;
          }
          if (currentCell.__colSpan > 1) {
            columnIndex += currentCell.__colSpan - 1;
          }
        }
        if (insertAfterCell === null) {
          $insertFirst3(nextRowNode, cell);
        } else {
          insertAfterCell.insertAfter(cell);
        }
      }
    }
    const rowNode = grid.getChildAtIndex(row);
    if (!$isTableRowNode(rowNode)) {
      formatDevErrorMessage7(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);
    }
    rowNode.remove();
  }
  if (nextRow !== void 0) {
    const {
      cell
    } = nextRow[0];
    $moveSelectionToCell(cell);
  } else {
    const previousRow = gridMap[anchorStartRow - 1];
    const {
      cell
    } = previousRow[0];
    $moveSelectionToCell(cell);
  }
}
function $deleteTableColumnAtSelection() {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage7(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const focus = selection.focus.getNode();
  const [anchorCell, , grid] = $getNodeTriplet(anchor);
  const [focusCell] = $getNodeTriplet(focus);
  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);
  const {
    startColumn: anchorStartColumn
  } = anchorCellMap;
  const {
    startRow: focusStartRow,
    startColumn: focusStartColumn
  } = focusCellMap;
  const startColumn = Math.min(anchorStartColumn, focusStartColumn);
  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);
  const selectedColumnCount = endColumn - startColumn + 1;
  const columnCount = gridMap[0].length;
  if (columnCount === endColumn - startColumn + 1) {
    grid.selectPrevious();
    grid.remove();
    return;
  }
  const rowCount = gridMap.length;
  for (let row = 0; row < rowCount; row++) {
    for (let column = startColumn; column <= endColumn; column++) {
      const {
        cell,
        startColumn: cellStartColumn
      } = gridMap[row][column];
      if (cellStartColumn < startColumn) {
        if (column === startColumn) {
          const overflowLeft = startColumn - cellStartColumn;
          cell.setColSpan(cell.__colSpan - // Possible overflow right too
          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));
        }
      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {
        if (column === endColumn) {
          const inSelectedArea = endColumn - cellStartColumn + 1;
          cell.setColSpan(cell.__colSpan - inSelectedArea);
        }
      } else {
        cell.remove();
      }
    }
  }
  const focusRowMap = gridMap[focusStartRow];
  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];
  if (nextColumn !== void 0) {
    const {
      cell
    } = nextColumn;
    $moveSelectionToCell(cell);
  } else {
    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];
    const {
      cell
    } = previousRow;
    $moveSelectionToCell(cell);
  }
  const colWidths = grid.getColWidths();
  if (colWidths) {
    const newColWidths = [...colWidths];
    newColWidths.splice(startColumn, selectedColumnCount);
    grid.setColWidths(newColWidths);
  }
}
function $moveSelectionToCell(cell) {
  const firstDescendant = cell.getFirstDescendant();
  if (firstDescendant == null) {
    cell.selectStart();
  } else {
    firstDescendant.getParentOrThrow().selectStart();
  }
}
function $insertFirst3(parent, node) {
  const firstChild = parent.getFirstChild();
  if (firstChild !== null) {
    firstChild.insertBefore(node);
  } else {
    parent.append(node);
  }
}
function $mergeCells(cellNodes) {
  if (cellNodes.length === 0) {
    return null;
  }
  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);
  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);
  let minRow = Infinity;
  let maxRow = -Infinity;
  let minCol = Infinity;
  let maxCol = -Infinity;
  const processedCells = /* @__PURE__ */ new Set();
  for (const row of gridMap) {
    for (const mapCell of row) {
      if (!mapCell || !mapCell.cell) {
        continue;
      }
      const cellKey = mapCell.cell.getKey();
      if (processedCells.has(cellKey)) {
        continue;
      }
      if (cellNodes.some((cell) => cell.is(mapCell.cell))) {
        processedCells.add(cellKey);
        const cellStartRow = mapCell.startRow;
        const cellStartCol = mapCell.startColumn;
        const cellRowSpan = mapCell.cell.__rowSpan || 1;
        const cellColSpan = mapCell.cell.__colSpan || 1;
        minRow = Math.min(minRow, cellStartRow);
        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);
        minCol = Math.min(minCol, cellStartCol);
        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);
      }
    }
  }
  if (minRow === Infinity || minCol === Infinity) {
    return null;
  }
  const totalRowSpan = maxRow - minRow + 1;
  const totalColSpan = maxCol - minCol + 1;
  const targetCellMap = gridMap[minRow][minCol];
  if (!targetCellMap.cell) {
    return null;
  }
  const targetCell = targetCellMap.cell;
  targetCell.setColSpan(totalColSpan);
  targetCell.setRowSpan(totalRowSpan);
  const seenCells = /* @__PURE__ */ new Set([targetCell.getKey()]);
  for (let row = minRow; row <= maxRow; row++) {
    for (let col = minCol; col <= maxCol; col++) {
      const mapCell = gridMap[row][col];
      if (!mapCell.cell) {
        continue;
      }
      const currentCell = mapCell.cell;
      const key2 = currentCell.getKey();
      if (!seenCells.has(key2)) {
        seenCells.add(key2);
        const isEmpty = $cellContainsEmptyParagraph(currentCell);
        if (!isEmpty) {
          targetCell.append(...currentCell.getChildren());
        }
        currentCell.remove();
      }
    }
  }
  if (targetCell.getChildrenSize() === 0) {
    targetCell.append($createParagraphNode2());
  }
  return targetCell;
}
function $cellContainsEmptyParagraph(cell) {
  if (cell.getChildrenSize() !== 1) {
    return false;
  }
  const firstChild = cell.getFirstChildOrThrow();
  if (!$isParagraphNode2(firstChild) || !firstChild.isEmpty()) {
    return false;
  }
  return true;
}
function $unmergeCell() {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage7(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const cellNode = $findMatchingParent3(anchor, $isTableCellNode);
  if (!$isTableCellNode(cellNode)) {
    formatDevErrorMessage7(`Expected to find a parent TableCellNode`);
  }
  return $unmergeCellNode(cellNode);
}
function $unmergeCellNode(cellNode) {
  const [cell, row, grid] = $getNodeTriplet(cellNode);
  const colSpan = cell.__colSpan;
  const rowSpan = cell.__rowSpan;
  if (colSpan === 1 && rowSpan === 1) {
    return;
  }
  const [map, cellMap] = $computeTableMap(grid, cell, cell);
  const {
    startColumn,
    startRow
  } = cellMap;
  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;
  const colStyles = Array.from({
    length: colSpan
  }, (_v, i2) => {
    let colStyle = baseColStyle;
    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {
      colStyle &= map[rowIdx][i2 + startColumn].cell.__headerState;
    }
    return colStyle;
  });
  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;
  const rowStyles = Array.from({
    length: rowSpan
  }, (_v, i2) => {
    let rowStyle = baseRowStyle;
    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {
      rowStyle &= map[i2 + startRow][colIdx].cell.__headerState;
    }
    return rowStyle;
  });
  if (colSpan > 1) {
    for (let i2 = 1; i2 < colSpan; i2++) {
      cell.insertAfter($createTableCellNode(colStyles[i2] | rowStyles[0]).append($createParagraphNode2()));
    }
    cell.setColSpan(1);
  }
  if (rowSpan > 1) {
    let currentRowNode;
    for (let i2 = 1; i2 < rowSpan; i2++) {
      const currentRow = startRow + i2;
      const currentRowMap = map[currentRow];
      currentRowNode = (currentRowNode || row).getNextSibling();
      if (!$isTableRowNode(currentRowNode)) {
        formatDevErrorMessage7(`Expected row next sibling to be a row`);
      }
      let insertAfterCell = null;
      for (let column = 0; column < startColumn; column++) {
        const currentCellMap = currentRowMap[column];
        const currentCell = currentCellMap.cell;
        if (currentCellMap.startRow === currentRow) {
          insertAfterCell = currentCell;
        }
        if (currentCell.__colSpan > 1) {
          column += currentCell.__colSpan - 1;
        }
      }
      if (insertAfterCell === null) {
        for (let j5 = colSpan - 1; j5 >= 0; j5--) {
          $insertFirst3(currentRowNode, $createTableCellNode(colStyles[j5] | rowStyles[i2]).append($createParagraphNode2()));
        }
      } else {
        for (let j5 = colSpan - 1; j5 >= 0; j5--) {
          insertAfterCell.insertAfter($createTableCellNode(colStyles[j5] | rowStyles[i2]).append($createParagraphNode2()));
        }
      }
    }
    cell.setRowSpan(1);
  }
}
function $computeTableMap(tableNode, cellA, cellB) {
  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);
  if (!(cellAValue !== null)) {
    formatDevErrorMessage7(`Anchor not found in Table`);
  }
  if (!(cellBValue !== null)) {
    formatDevErrorMessage7(`Focus not found in Table`);
  }
  return [tableMap, cellAValue, cellBValue];
}
function $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {
  const tableMap = [];
  let cellAValue = null;
  let cellBValue = null;
  function getMapRow(i2) {
    let row = tableMap[i2];
    if (row === void 0) {
      tableMap[i2] = row = [];
    }
    return row;
  }
  const gridChildren = tableNode.getChildren();
  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {
    const row = gridChildren[rowIdx];
    if (!$isTableRowNode(row)) {
      formatDevErrorMessage7(`Expected TableNode children to be TableRowNode`);
    }
    const startMapRow = getMapRow(rowIdx);
    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {
      if (!$isTableCellNode(cell)) {
        formatDevErrorMessage7(`Expected TableRowNode children to be TableCellNode`);
      }
      while (startMapRow[colIdx] !== void 0) {
        colIdx++;
      }
      const value = {
        cell,
        startColumn: colIdx,
        startRow: rowIdx
      };
      const {
        __rowSpan: rowSpan,
        __colSpan: colSpan
      } = cell;
      for (let j5 = 0; j5 < rowSpan; j5++) {
        if (rowIdx + j5 >= gridChildren.length) {
          break;
        }
        const mapRow = getMapRow(rowIdx + j5);
        for (let i2 = 0; i2 < colSpan; i2++) {
          mapRow[colIdx + i2] = value;
        }
      }
      if (cellA !== null && cellAValue === null && cellA.is(cell)) {
        cellAValue = value;
      }
      if (cellB !== null && cellBValue === null && cellB.is(cell)) {
        cellBValue = value;
      }
    }
  }
  return [tableMap, cellAValue, cellBValue];
}
function $getNodeTriplet(source) {
  let cell;
  if (source instanceof TableCellNode) {
    cell = source;
  } else if ("__type" in source) {
    const cell_ = $findMatchingParent3(source, $isTableCellNode);
    if (!$isTableCellNode(cell_)) {
      formatDevErrorMessage7(`Expected to find a parent TableCellNode`);
    }
    cell = cell_;
  } else {
    const cell_ = $findMatchingParent3(source.getNode(), $isTableCellNode);
    if (!$isTableCellNode(cell_)) {
      formatDevErrorMessage7(`Expected to find a parent TableCellNode`);
    }
    cell = cell_;
  }
  const row = cell.getParent();
  if (!$isTableRowNode(row)) {
    formatDevErrorMessage7(`Expected TableCellNode to have a parent TableRowNode`);
  }
  const grid = row.getParent();
  if (!$isTableNode(grid)) {
    formatDevErrorMessage7(`Expected TableRowNode to have a parent TableNode`);
  }
  return [cell, row, grid];
}
function $computeTableCellRectSpans(map, boundary) {
  const {
    minColumn,
    maxColumn,
    minRow,
    maxRow
  } = boundary;
  let topSpan = 1;
  let leftSpan = 1;
  let rightSpan = 1;
  let bottomSpan = 1;
  const topRow = map[minRow];
  const bottomRow = map[maxRow];
  for (let col = minColumn; col <= maxColumn; col++) {
    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);
    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);
  }
  for (let row = minRow; row <= maxRow; row++) {
    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);
    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);
  }
  return {
    bottomSpan,
    leftSpan,
    rightSpan,
    topSpan
  };
}
function $computeTableCellRectBoundary(map, cellAMap, cellBMap) {
  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);
  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);
  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);
  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);
  let hasChanges;
  do {
    hasChanges = false;
    for (let row = 0; row < map.length; row++) {
      for (let col = 0; col < map[0].length; col++) {
        const cell = map[row][col];
        if (!cell) {
          continue;
        }
        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;
        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;
        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;
        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;
        if (intersectsHorizontally && intersectsVertically) {
          const newMinColumn = Math.min(minColumn, cell.startColumn);
          const newMaxColumn = Math.max(maxColumn, cellEndCol);
          const newMinRow = Math.min(minRow, cell.startRow);
          const newMaxRow = Math.max(maxRow, cellEndRow);
          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {
            minColumn = newMinColumn;
            maxColumn = newMaxColumn;
            minRow = newMinRow;
            maxRow = newMaxRow;
            hasChanges = true;
          }
        }
      }
    }
  } while (hasChanges);
  return {
    maxColumn,
    maxRow,
    minColumn,
    minRow
  };
}
function $getTableCellNodeRect(tableCellNode) {
  const [cellNode, , gridNode] = $getNodeTriplet(tableCellNode);
  const rows = gridNode.getChildren();
  const rowCount = rows.length;
  const columnCount = rows[0].getChildren().length;
  const cellMatrix = new Array(rowCount);
  for (let i2 = 0; i2 < rowCount; i2++) {
    cellMatrix[i2] = new Array(columnCount);
  }
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
    const row = rows[rowIndex];
    const cells = row.getChildren();
    let columnIndex = 0;
    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
      while (cellMatrix[rowIndex][columnIndex]) {
        columnIndex++;
      }
      const cell = cells[cellIndex];
      const rowSpan = cell.__rowSpan || 1;
      const colSpan = cell.__colSpan || 1;
      for (let i2 = 0; i2 < rowSpan; i2++) {
        for (let j5 = 0; j5 < colSpan; j5++) {
          cellMatrix[rowIndex + i2][columnIndex + j5] = cell;
        }
      }
      if (cellNode === cell) {
        return {
          colSpan,
          columnIndex,
          rowIndex,
          rowSpan
        };
      }
      columnIndex += colSpan;
    }
  }
  return null;
}
function $getCellNodes(tableSelection) {
  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ["anchor", "focus"].map((k5) => {
    const node = tableSelection[k5].getNode();
    const cellNode = $findMatchingParent3(node, $isTableCellNode);
    if (!$isTableCellNode(cellNode)) {
      formatDevErrorMessage7(`Expected TableSelection ${k5} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);
    }
    const rowNode = cellNode.getParent();
    if (!$isTableRowNode(rowNode)) {
      formatDevErrorMessage7(`Expected TableSelection ${k5} cell parent to be a TableRowNode`);
    }
    const tableNode = rowNode.getParent();
    if (!$isTableNode(tableNode)) {
      formatDevErrorMessage7(`Expected TableSelection ${k5} row parent to be a TableNode`);
    }
    return [node, cellNode, rowNode, tableNode];
  });
  if (!anchorTable.is(focusTable)) {
    formatDevErrorMessage7(`Expected TableSelection anchor and focus to be in the same table`);
  }
  return {
    anchorCell,
    anchorNode,
    anchorRow,
    anchorTable,
    focusCell,
    focusNode,
    focusRow,
    focusTable
  };
}
function $isTableSelection(x4) {
  return x4 instanceof TableSelection;
}
function $createTableSelection() {
  const anchor = $createPoint2("root", 0, "element");
  const focus = $createPoint2("root", 0, "element");
  return new TableSelection("root", anchor, focus);
}
function $createTableSelectionFrom(tableNode, anchorCell, focusCell) {
  const tableNodeKey = tableNode.getKey();
  const anchorCellKey = anchorCell.getKey();
  const focusCellKey = focusCell.getKey();
  {
    if (!tableNode.isAttached()) {
      formatDevErrorMessage7(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);
    }
    if (!tableNode.is($findTableNode(anchorCell))) {
      formatDevErrorMessage7(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);
    }
    if (!tableNode.is($findTableNode(focusCell))) {
      formatDevErrorMessage7(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);
    }
  }
  const prevSelection = $getSelection2();
  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();
  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());
  return nextSelection;
}
function $visitRecursively(node, $visit) {
  const stack = [[node]];
  for (let currentArray = stack.at(-1); currentArray !== void 0 && stack.length > 0; currentArray = stack.at(-1)) {
    const currentNode = currentArray.pop();
    if (currentNode === void 0) {
      stack.pop();
    } else if ($visit(currentNode) !== false && $isElementNode2(currentNode)) {
      stack.push(currentNode.getChildren());
    }
  }
}
function $getTableAndElementByKey(tableNodeKey, editor = $getEditor2()) {
  const tableNode = $getNodeByKey2(tableNodeKey);
  if (!$isTableNode(tableNode)) {
    formatDevErrorMessage7(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);
  }
  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));
  if (!(tableElement !== null)) {
    formatDevErrorMessage7(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);
  }
  return {
    tableElement,
    tableNode
  };
}
function isHTMLTableElement(el2) {
  return isHTMLElement2(el2) && el2.nodeName === "TABLE";
}
function getTableElement(tableNode, dom2) {
  if (!dom2) {
    return dom2;
  }
  const element = isHTMLTableElement(dom2) ? dom2 : tableNode.getDOMSlot(dom2).element;
  if (!(element.nodeName === "TABLE")) {
    formatDevErrorMessage7(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom2.nodeName}`);
  }
  return element;
}
function getEditorWindow(editor) {
  return editor._window;
}
function $findParentTableCellNodeInTable(tableNode, node) {
  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {
    if (tableNode.is(currentNode)) {
      return lastTableCellNode;
    } else if ($isTableCellNode(currentNode)) {
      lastTableCellNode = currentNode;
    }
  }
  return null;
}
function applyTableHandlers(tableNode, element, editor, hasTabHandler) {
  const rootElement = editor.getRootElement();
  const editorWindow = getEditorWindow(editor);
  if (!(rootElement !== null && editorWindow !== null)) {
    formatDevErrorMessage7(`applyTableHandlers: editor has no root element set`);
  }
  const tableObserver = new TableObserver(editor, tableNode.getKey());
  const tableElement = getTableElement(tableNode, element);
  attachTableObserverToTableElement(tableElement, tableObserver);
  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));
  const createPointerHandlers = () => {
    if (tableObserver.isSelecting) {
      return;
    }
    const onPointerUp = () => {
      tableObserver.isSelecting = false;
      editorWindow.removeEventListener("pointerup", onPointerUp);
      editorWindow.removeEventListener("pointermove", onPointerMove);
    };
    const onPointerMove = (moveEvent) => {
      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {
        tableObserver.isSelecting = false;
        editorWindow.removeEventListener("pointerup", onPointerUp);
        editorWindow.removeEventListener("pointermove", onPointerMove);
        return;
      }
      if (!isDOMNode2(moveEvent.target)) {
        return;
      }
      let focusCell = null;
      const override = !(IS_FIREFOX4 || tableElement.contains(moveEvent.target));
      if (override) {
        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);
      } else {
        for (const el2 of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {
          focusCell = getDOMCellInTableFromTarget(tableElement, el2);
          if (focusCell) {
            break;
          }
        }
      }
      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {
        tableObserver.setNextFocus({
          focusCell,
          override
        });
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
    };
    tableObserver.isSelecting = true;
    editorWindow.addEventListener("pointerup", onPointerUp, tableObserver.listenerOptions);
    editorWindow.addEventListener("pointermove", onPointerMove, tableObserver.listenerOptions);
  };
  const onPointerDown2 = (event) => {
    tableObserver.pointerType = event.pointerType;
    if (event.button !== 0 || !isDOMNode2(event.target) || !editorWindow) {
      return;
    }
    const targetCell = getDOMCellFromTarget(event.target);
    if (targetCell !== null) {
      editor.update(() => {
        const prevSelection = $getPreviousSelection2();
        if (IS_FIREFOX4 && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection2(prevSelection) || $isTableSelection(prevSelection))) {
          const prevAnchorNode = prevSelection.anchor.getNode();
          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());
          if (prevAnchorCell) {
            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));
            tableObserver.$setFocusCellForSelection(targetCell);
            stopEvent(event);
          } else {
            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();
            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);
          }
        } else {
          tableObserver.$setAnchorCellForSelection(targetCell);
        }
      });
    }
    createPointerHandlers();
  };
  tableElement.addEventListener("pointerdown", onPointerDown2, tableObserver.listenerOptions);
  tableObserver.listenersToRemove.add(() => {
    tableElement.removeEventListener("pointerdown", onPointerDown2);
  });
  const onTripleClick = (event) => {
    if (event.detail >= 3 && isDOMNode2(event.target)) {
      const targetCell = getDOMCellFromTarget(event.target);
      if (targetCell !== null) {
        event.preventDefault();
      }
    }
  };
  tableElement.addEventListener("mousedown", onTripleClick, tableObserver.listenerOptions);
  tableObserver.listenersToRemove.add(() => {
    tableElement.removeEventListener("mousedown", onTripleClick);
  });
  const pointerDownCallback = (event) => {
    const target = event.target;
    if (event.button !== 0 || !isDOMNode2(target)) {
      return;
    }
    editor.update(() => {
      const selection = $getSelection2();
      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {
        tableObserver.$clearHighlight();
      }
    });
  };
  editorWindow.addEventListener("pointerdown", pointerDownCallback, tableObserver.listenerOptions);
  tableObserver.listenersToRemove.add(() => {
    editorWindow.removeEventListener("pointerdown", pointerDownCallback);
  });
  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {
    tableObserver.listenersToRemove.add(editor.registerCommand(command, (event) => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH2));
  }
  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isTableSelection(selection)) {
      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());
      if (focusCellNode !== null) {
        stopEvent(event);
        focusCellNode.selectEnd();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  const deleteTextHandler = (command) => () => {
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      tableObserver.$clearText();
      return true;
    } else if ($isRangeSelection2(selection)) {
      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());
      if (!$isTableCellNode(tableCellNode)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      const isAnchorInside = tableNode.isParentOf(anchorNode);
      const isFocusInside = tableNode.isParentOf(focusNode);
      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;
      if (selectionContainsPartialTable) {
        tableObserver.$clearText();
        return true;
      }
      const nearestElementNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isElementNode2(n2));
      const topLevelCellElementNode = nearestElementNode && $findMatchingParent3(nearestElementNode, (n2) => $isElementNode2(n2) && $isTableCellNode(n2.getParent()));
      if (!$isElementNode2(topLevelCellElementNode) || !$isElementNode2(nearestElementNode)) {
        return false;
      }
      if (command === DELETE_LINE_COMMAND2 && topLevelCellElementNode.getPreviousSibling() === null) {
        return true;
      }
    }
    return false;
  };
  for (const command of DELETE_TEXT_COMMANDS) {
    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL2));
  }
  const $deleteCellHandler = (event) => {
    const selection = $getSelection2();
    if (!($isTableSelection(selection) || $isRangeSelection2(selection))) {
      return false;
    }
    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());
    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());
    if (isAnchorInside !== isFocusInside) {
      const tablePoint = isAnchorInside ? "anchor" : "focus";
      const outerPoint = isAnchorInside ? "focus" : "anchor";
      const {
        key: key2,
        offset,
        type
      } = selection[outerPoint];
      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? "selectPrevious" : "selectNext"]();
      newSelection[outerPoint].set(key2, offset, type);
      return false;
    }
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      tableObserver.$clearText();
      return true;
    }
    return false;
  };
  for (const command of DELETE_KEY_COMMANDS) {
    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL2));
  }
  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (selection) {
      if (!($isTableSelection(selection) || $isRangeSelection2(selection))) {
        return false;
      }
      void copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection2(selection));
      const intercepted = $deleteCellHandler(event);
      if ($isRangeSelection2(selection)) {
        selection.removeText();
        return true;
      }
      return intercepted;
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2));
  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      tableObserver.$formatCells(payload);
      return true;
    } else if ($isRangeSelection2(selection)) {
      const tableCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
      if (!$isTableCellNode(tableCellNode)) {
        return false;
      }
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2));
  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND2, (formatType) => {
    const selection = $getSelection2();
    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {
      return false;
    }
    if ($isFullTableSelection(selection, tableNode)) {
      tableNode.setFormat(formatType);
      return true;
    }
    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);
    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);
    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);
    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);
    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);
    const visited = /* @__PURE__ */ new Set();
    for (let i2 = minRow; i2 <= maxRow; i2++) {
      for (let j5 = minColumn; j5 <= maxColumn; j5++) {
        const cell = tableMap[i2][j5].cell;
        if (visited.has(cell)) {
          continue;
        }
        visited.add(cell);
        cell.setFormat(formatType);
        const cellChildren = cell.getChildren();
        for (let k5 = 0; k5 < cellChildren.length; k5++) {
          const child = cellChildren[k5];
          if ($isElementNode2(child) && !child.isInline()) {
            child.setFormat(formatType);
          }
        }
      }
    }
    return true;
  }, COMMAND_PRIORITY_CRITICAL2));
  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      tableObserver.$clearHighlight();
      return false;
    } else if ($isRangeSelection2(selection)) {
      const tableCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
      if (!$isTableCellNode(tableCellNode)) {
        return false;
      }
      if (typeof payload === "string") {
        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);
        if (edgePosition) {
          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode2(payload)]);
          return true;
        }
      }
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2));
  if (hasTabHandler) {
    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      const tableCellNode = $findCellNode(selection.anchor.getNode());
      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {
        return false;
      }
      stopEvent(event);
      $selectAdjacentCell(tableCellNode, event.shiftKey ? "previous" : "next");
      return true;
    }, COMMAND_PRIORITY_CRITICAL2));
  }
  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND2, (payload) => {
    return tableNode.isSelected();
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, (selectionPayload) => {
    const {
      nodes,
      selection
    } = selectionPayload;
    const anchorAndFocus = selection.getStartEndPoints();
    const isTableSelection = $isTableSelection(selection);
    const isRangeSelection = $isRangeSelection2(selection);
    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2)) !== null && $findMatchingParent3(selection.focus.getNode(), (n2) => $isTableCellNode(n2)) !== null || isTableSelection;
    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {
      return false;
    }
    const [anchor, focus] = anchorAndFocus;
    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);
    const focusCellNode = $findMatchingParent3(focus.getNode(), (n2) => $isTableCellNode(n2));
    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {
      return false;
    }
    const templateGrid = nodes[0];
    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);
    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);
    const initialRowCount = initialGridMap.length;
    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;
    let startRow = anchorCellMap.startRow;
    let startCol = anchorCellMap.startColumn;
    let affectedRowCount = templateGridMap.length;
    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;
    if (isTableSelection) {
      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);
      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;
      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;
      startRow = selectionBoundary.minRow;
      startCol = selectionBoundary.minColumn;
      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);
      affectedColCount = Math.min(affectedColCount, selectionColCount);
    }
    let didPerformMergeOperations = false;
    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;
    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;
    const unmergedKeys = /* @__PURE__ */ new Set();
    for (let row = startRow; row <= lastRowForUnmerge; row++) {
      for (let col = startCol; col <= lastColForUnmerge; col++) {
        const cellMap = initialGridMap[row][col];
        if (unmergedKeys.has(cellMap.cell.getKey())) {
          continue;
        }
        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {
          continue;
        }
        $unmergeCellNode(cellMap.cell);
        unmergedKeys.add(cellMap.cell.getKey());
        didPerformMergeOperations = true;
      }
    }
    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
    const rowsToInsert = affectedRowCount - initialRowCount + startRow;
    for (let i2 = 0; i2 < rowsToInsert; i2++) {
      const cellMap = interimGridMap[initialRowCount - 1][0];
      $insertTableRowAtNode(cellMap.cell);
    }
    const colsToInsert = affectedColCount - initialColCount + startCol;
    for (let i2 = 0; i2 < colsToInsert; i2++) {
      const cellMap = interimGridMap[0][initialColCount - 1];
      $insertTableColumnAtNode(cellMap.cell, true, false);
    }
    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
    for (let row = startRow; row < startRow + affectedRowCount; row++) {
      for (let col = startCol; col < startCol + affectedColCount; col++) {
        const templateRow = row - startRow;
        const templateCol = col - startCol;
        const templateCellMap = templateGridMap[templateRow][templateCol];
        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {
          continue;
        }
        const templateCell = templateCellMap.cell;
        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {
          const cellsToMerge = [];
          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;
          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;
          for (let r2 = row; r2 <= lastRowForMerge; r2++) {
            for (let c2 = col; c2 <= lastColForMerge; c2++) {
              const cellMap = interimGridMap[r2][c2];
              cellsToMerge.push(cellMap.cell);
            }
          }
          $mergeCells(cellsToMerge);
          didPerformMergeOperations = true;
        }
        const {
          cell
        } = interimGridMap[row][col];
        const originalChildren = cell.getChildren();
        templateCell.getChildren().forEach((child) => {
          if ($isTextNode2(child)) {
            const paragraphNode = $createParagraphNode2();
            paragraphNode.append(child);
            cell.append(child);
          } else {
            cell.append(child);
          }
        });
        originalChildren.forEach((n2) => n2.remove());
      }
    }
    if (isTableSelection && didPerformMergeOperations) {
      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];
      newAnchorCellMap.cell.selectEnd();
    }
    return true;
  }, COMMAND_PRIORITY_CRITICAL2));
  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND2, () => {
    const selection = $getSelection2();
    const prevSelection = $getPreviousSelection2();
    const nextFocus = tableObserver.getAndClearNextFocus();
    if (nextFocus !== null) {
      const {
        focusCell
      } = nextFocus;
      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {
        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {
          return false;
        } else {
          tableObserver.$setFocusCellForSelection(focusCell);
          return true;
        }
      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {
        tableObserver.$setFocusCellForSelection(focusCell);
        return true;
      }
    }
    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();
    if (shouldCheckSelection && $isRangeSelection2(prevSelection) && $isRangeSelection2(selection) && selection.isCollapsed()) {
      const anchor = selection.anchor.getNode();
      const firstRow = tableNode.getFirstChild();
      const anchorCell = $findCellNode(anchor);
      if (anchorCell !== null && $isTableRowNode(firstRow)) {
        const firstCell = firstRow.getFirstChild();
        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent3(anchorCell, (node) => node.is(tableNode) || node.is(firstCell)))) {
          firstCell.selectStart();
          return true;
        }
      }
    }
    if ($isRangeSelection2(selection)) {
      const {
        anchor,
        focus
      } = selection;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      const anchorCellNode = $findCellNode(anchorNode);
      const focusCellNode = $findCellNode(focusNode);
      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));
      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));
      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;
      const isWithinTable = isAnchorInside && isFocusInside;
      const isBackward = selection.isBackward();
      if (isPartiallyWithinTable) {
        const newSelection = selection.clone();
        if (isFocusInside) {
          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);
          const firstCell = tableMap[0][0].cell;
          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;
          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), "element");
        } else if (isAnchorInside) {
          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);
          const firstCell = tableMap[0][0].cell;
          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;
          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, "element");
        }
        $setSelection2(newSelection);
        $addHighlightStyleToTable(editor, tableObserver);
      } else if (isWithinTable) {
        if (!anchorCellNode.is(focusCellNode)) {
          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));
          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);
        }
        if (tableObserver.pointerType === "touch" && selection.isCollapsed() && $isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());
          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {
            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));
            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);
            tableObserver.pointerType = null;
          }
        }
      }
    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {
      const domSelection = getDOMSelection2(editorWindow);
      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {
        const focusNode = $getNearestNodeFromDOMNode2(domSelection.focusNode);
        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);
        const anchorNode = $getNearestNodeFromDOMNode2(domSelection.anchorNode);
        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);
        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {
          const newSelection = $createRangeSelectionFromDom2(domSelection, editor);
          if (newSelection) {
            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, "element");
            domSelection.removeAllRanges();
            $setSelection2(newSelection);
          }
        }
      }
    }
    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {
      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {
        tableObserver.$updateTableTableSelection(selection);
      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {
        tableObserver.$updateTableTableSelection(null);
      }
      return false;
    }
    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {
      $removeHighlightStyleToTable(editor, tableObserver);
    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {
      $addHighlightStyleToTable(editor, tableObserver);
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2));
  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);
    if (edgePosition) {
      $insertParagraphAtTableEdge(edgePosition, tableNode);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2));
  return tableObserver;
}
function detachTableObserverFromTableElement(tableElement, tableObserver) {
  if (getTableObserverFromTableElement(tableElement) === tableObserver) {
    delete tableElement[LEXICAL_ELEMENT_KEY];
  }
}
function attachTableObserverToTableElement(tableElement, tableObserver) {
  if (!(getTableObserverFromTableElement(tableElement) === null)) {
    formatDevErrorMessage7(`tableElement already has an attached TableObserver`);
  }
  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;
}
function getTableObserverFromTableElement(tableElement) {
  return tableElement[LEXICAL_ELEMENT_KEY] || null;
}
function getDOMCellFromTarget(node) {
  let currentNode = node;
  while (currentNode != null) {
    const nodeName = currentNode.nodeName;
    if (nodeName === "TD" || nodeName === "TH") {
      const cell = currentNode._cell;
      if (cell === void 0) {
        return null;
      }
      return cell;
    }
    currentNode = currentNode.parentNode;
  }
  return null;
}
function getDOMCellInTableFromTarget(table, node) {
  if (!table.contains(node)) {
    return null;
  }
  let cell = null;
  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {
    if (currentNode === table) {
      return cell;
    }
    const nodeName = currentNode.nodeName;
    if (nodeName === "TD" || nodeName === "TH") {
      cell = currentNode._cell || null;
    }
  }
  return null;
}
function getTable(tableNode, dom2) {
  const tableElement = getTableElement(tableNode, dom2);
  const domRows = [];
  const grid = {
    columns: 0,
    domRows,
    rows: 0
  };
  let currentNode = tableElement.querySelector("tr");
  let x4 = 0;
  let y4 = 0;
  domRows.length = 0;
  while (currentNode != null) {
    const nodeMame = currentNode.nodeName;
    if (nodeMame === "TD" || nodeMame === "TH") {
      const elem = currentNode;
      const cell = {
        elem,
        hasBackgroundColor: elem.style.backgroundColor !== "",
        highlighted: false,
        x: x4,
        y: y4
      };
      currentNode._cell = cell;
      let row = domRows[y4];
      if (row === void 0) {
        row = domRows[y4] = [];
      }
      row[x4] = cell;
    } else {
      const child = currentNode.firstChild;
      if (child != null) {
        currentNode = child;
        continue;
      }
    }
    const sibling = currentNode.nextSibling;
    if (sibling != null) {
      x4++;
      currentNode = sibling;
      continue;
    }
    const parent = currentNode.parentNode;
    if (parent != null) {
      const parentSibling = parent.nextSibling;
      if (parentSibling == null) {
        break;
      }
      y4++;
      x4 = 0;
      currentNode = parentSibling;
    }
  }
  grid.columns = x4 + 1;
  grid.rows = y4 + 1;
  return grid;
}
function $updateDOMForSelection(editor, table, selection) {
  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);
  $forEachTableCell(table, (cell, lexicalNode) => {
    const elem = cell.elem;
    if (selectedCellNodes.has(lexicalNode)) {
      cell.highlighted = true;
      $addHighlightToDOM(editor, cell);
    } else {
      cell.highlighted = false;
      $removeHighlightFromDOM(editor, cell);
      if (!elem.getAttribute("style")) {
        elem.removeAttribute("style");
      }
    }
  });
}
function $forEachTableCell(grid, cb) {
  const {
    domRows
  } = grid;
  for (let y4 = 0; y4 < domRows.length; y4++) {
    const row = domRows[y4];
    if (!row) {
      continue;
    }
    for (let x4 = 0; x4 < row.length; x4++) {
      const cell = row[x4];
      if (!cell) {
        continue;
      }
      const lexicalNode = $getNearestNodeFromDOMNode2(cell.elem);
      if (lexicalNode !== null) {
        cb(cell, lexicalNode, {
          x: x4,
          y: y4
        });
      }
    }
  }
}
function $addHighlightStyleToTable(editor, tableSelection) {
  tableSelection.$disableHighlightStyle();
  $forEachTableCell(tableSelection.table, (cell) => {
    cell.highlighted = true;
    $addHighlightToDOM(editor, cell);
  });
}
function $removeHighlightStyleToTable(editor, tableObserver) {
  tableObserver.$enableHighlightStyle();
  $forEachTableCell(tableObserver.table, (cell) => {
    const elem = cell.elem;
    cell.highlighted = false;
    $removeHighlightFromDOM(editor, cell);
    if (!elem.getAttribute("style")) {
      elem.removeAttribute("style");
    }
  });
}
function $selectAdjacentCell(tableCellNode, direction) {
  const siblingMethod = direction === "next" ? "getNextSibling" : "getPreviousSibling";
  const childMethod = direction === "next" ? "getFirstChild" : "getLastChild";
  const sibling = tableCellNode[siblingMethod]();
  if ($isElementNode2(sibling)) {
    return sibling.selectEnd();
  }
  const parentRow = $findMatchingParent3(tableCellNode, $isTableRowNode);
  if (!(parentRow !== null)) {
    formatDevErrorMessage7(`selectAdjacentCell: Cell not in table row`);
  }
  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {
    const child = nextRow[childMethod]();
    if ($isElementNode2(child)) {
      return child.selectEnd();
    }
  }
  const parentTable = $findMatchingParent3(parentRow, $isTableNode);
  if (!(parentTable !== null)) {
    formatDevErrorMessage7(`selectAdjacentCell: Row not in table`);
  }
  return direction === "next" ? parentTable.selectNext() : parentTable.selectPrevious();
}
function getCorner(rect, cellValue) {
  let colName;
  let rowName;
  if (cellValue.startColumn === rect.minColumn) {
    colName = "minColumn";
  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {
    colName = "maxColumn";
  } else {
    return null;
  }
  if (cellValue.startRow === rect.minRow) {
    rowName = "minRow";
  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {
    rowName = "maxRow";
  } else {
    return null;
  }
  return [colName, rowName];
}
function getCornerOrThrow(rect, cellValue) {
  const corner = getCorner(rect, cellValue);
  if (!(corner !== null)) {
    formatDevErrorMessage7(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);
  }
  return corner;
}
function oppositeCorner([colName, rowName]) {
  return [colName === "minColumn" ? "maxColumn" : "minColumn", rowName === "minRow" ? "maxRow" : "minRow"];
}
function cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {
  const rowNum = rect[rowName];
  const rowMap = tableMap[rowNum];
  if (!(rowMap !== void 0)) {
    formatDevErrorMessage7(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);
  }
  const colNum = rect[colName];
  const cell = rowMap[colNum];
  if (!(cell !== void 0)) {
    formatDevErrorMessage7(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);
  }
  return cell;
}
function $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {
  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);
  const anchorCorner = getCorner(rect, anchorCellValue);
  if (anchorCorner) {
    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];
  }
  const newFocusCorner = getCorner(rect, newFocusCellValue);
  if (newFocusCorner) {
    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];
  }
  const newAnchorCorner = ["minColumn", "minRow"];
  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];
}
function $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {
  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);
  const spans = $computeTableCellRectSpans(tableMap, rect);
  const {
    topSpan,
    leftSpan,
    bottomSpan,
    rightSpan
  } = spans;
  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);
  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);
  let fCol = rect[focusColumn];
  let fRow = rect[focusRow];
  if (direction === "forward") {
    fCol += focusColumn === "maxColumn" ? 1 : leftSpan;
  } else if (direction === "backward") {
    fCol -= focusColumn === "minColumn" ? 1 : rightSpan;
  } else if (direction === "down") {
    fRow += focusRow === "maxRow" ? 1 : topSpan;
  } else if (direction === "up") {
    fRow -= focusRow === "minRow" ? 1 : bottomSpan;
  }
  const targetRowMap = tableMap[fRow];
  if (targetRowMap === void 0) {
    return false;
  }
  const newFocusCellValue = targetRowMap[fCol];
  if (newFocusCellValue === void 0) {
    return false;
  }
  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);
  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);
  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);
  tableObserver.$setAnchorCellForSelection(anchorDOM);
  tableObserver.$setFocusCellForSelection(focusDOM, true);
  return true;
}
function $isSelectionInTable(selection, tableNode) {
  if ($isRangeSelection2(selection) || $isTableSelection(selection)) {
    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());
    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());
    return isAnchorInside && isFocusInside;
  }
  return false;
}
function $isFullTableSelection(selection, tableNode) {
  if ($isTableSelection(selection)) {
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    if (tableNode && anchorNode && focusNode) {
      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);
      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();
    }
  }
  return false;
}
function selectTableCellNode(tableCell, fromStart) {
  if (fromStart) {
    tableCell.selectStart();
  } else {
    tableCell.selectEnd();
  }
}
function $addHighlightToDOM(editor, cell) {
  const element = cell.elem;
  const editorThemeClasses = editor._config.theme;
  const node = $getNearestNodeFromDOMNode2(element);
  if (!$isTableCellNode(node)) {
    formatDevErrorMessage7(`Expected to find LexicalNode from Table Cell DOMNode`);
  }
  addClassNamesToElement2(element, editorThemeClasses.tableCellSelected);
}
function $removeHighlightFromDOM(editor, cell) {
  const element = cell.elem;
  const node = $getNearestNodeFromDOMNode2(element);
  if (!$isTableCellNode(node)) {
    formatDevErrorMessage7(`Expected to find LexicalNode from Table Cell DOMNode`);
  }
  const editorThemeClasses = editor._config.theme;
  removeClassNamesFromElement2(element, editorThemeClasses.tableCellSelected);
}
function $findCellNode(node) {
  const cellNode = $findMatchingParent3(node, $isTableCellNode);
  return $isTableCellNode(cellNode) ? cellNode : null;
}
function $findTableNode(node) {
  const tableNode = $findMatchingParent3(node, $isTableNode);
  return $isTableNode(tableNode) ? tableNode : null;
}
function $getBlockParentIfFirstNode(node) {
  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {
    if ($isElementNode2(currentNode)) {
      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {
        return null;
      } else if (!currentNode.isInline()) {
        return currentNode;
      }
    }
  }
  return null;
}
function $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {
  const initialFocus = $caretFromPoint2(selection.focus, isBackward ? "previous" : "next");
  if ($isExtendableTextPointCaret2(initialFocus)) {
    return false;
  }
  let lastCaret = initialFocus;
  for (const nextCaret of $extendCaretToRange2(initialFocus).iterNodeCarets("shadowRoot")) {
    if (!($isSiblingCaret2(nextCaret) && $isElementNode2(nextCaret.origin))) {
      return false;
    }
    lastCaret = nextCaret;
  }
  const lastCaretParent = lastCaret.getParentAtCaret();
  if (!$isTableCellNode(lastCaretParent)) {
    return false;
  }
  const anchorCell = lastCaretParent;
  const focusCaret = $findNextTableCell($getSiblingCaret2(anchorCell, lastCaret.direction));
  const anchorCellTable = $findMatchingParent3(anchorCell, $isTableNode);
  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {
    return false;
  }
  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());
  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);
  if (!anchorCellDOM || !anchorDOMCell) {
    return false;
  }
  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);
  tableObserver.table = anchorCellTableElement;
  if (!focusCaret) {
    if (alter === "extend") {
      tableObserver.$setAnchorCellForSelection(anchorDOMCell);
      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);
    } else {
      const outerFocusCaret = $getTableExitCaret($getSiblingCaret2(anchorCellTable, initialFocus.direction));
      $setPointFromCaret2(selection.anchor, outerFocusCaret);
      $setPointFromCaret2(selection.focus, outerFocusCaret);
    }
  } else if (alter === "extend") {
    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));
    if (!focusDOMCell) {
      return false;
    }
    tableObserver.$setAnchorCellForSelection(anchorDOMCell);
    tableObserver.$setFocusCellForSelection(focusDOMCell, true);
  } else {
    const innerFocusCaret = $normalizeCaret2(focusCaret);
    $setPointFromCaret2(selection.anchor, innerFocusCaret);
    $setPointFromCaret2(selection.focus, innerFocusCaret);
  }
  stopEvent(event);
  return true;
}
function $getTableExitCaret(initialCaret) {
  const adjacent = $getAdjacentChildCaret2(initialCaret);
  return $isChildCaret2(adjacent) ? $normalizeCaret2(adjacent) : initialCaret;
}
function $findNextTableCell(initialCaret) {
  for (const nextCaret of $extendCaretToRange2(initialCaret).iterNodeCarets("root")) {
    const {
      origin
    } = nextCaret;
    if ($isTableCellNode(origin)) {
      if ($isChildCaret2(nextCaret)) {
        return $getChildCaret2(origin, initialCaret.direction);
      }
    } else if (!$isTableRowNode(origin)) {
      break;
    }
  }
  return null;
}
function $handleArrowKey(editor, event, direction, tableNode, tableObserver) {
  if ((direction === "up" || direction === "down") && isTypeaheadMenuInView(editor)) {
    return false;
  }
  const selection = $getSelection2();
  if (!$isSelectionInTable(selection, tableNode)) {
    if ($isRangeSelection2(selection)) {
      if (direction === "backward") {
        if (selection.focus.offset > 0) {
          return false;
        }
        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());
        if (!parentNode) {
          return false;
        }
        const siblingNode = parentNode.getPreviousSibling();
        if (!$isTableNode(siblingNode)) {
          return false;
        }
        stopEvent(event);
        if (event.shiftKey) {
          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), "element");
        } else {
          siblingNode.selectEnd();
        }
        return true;
      } else if (event.shiftKey && (direction === "up" || direction === "down")) {
        const focusNode = selection.focus.getNode();
        const isTableUnselect = !selection.isCollapsed() && (direction === "up" && !selection.isBackward() || direction === "down" && selection.isBackward());
        if (isTableUnselect) {
          let focusParentNode = $findMatchingParent3(focusNode, (n2) => $isTableNode(n2));
          if ($isTableCellNode(focusParentNode)) {
            focusParentNode = $findMatchingParent3(focusParentNode, $isTableNode);
          }
          if (focusParentNode !== tableNode) {
            return false;
          }
          if (!focusParentNode) {
            return false;
          }
          const sibling = direction === "down" ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();
          if (!sibling) {
            return false;
          }
          let newOffset = 0;
          if (direction === "up") {
            if ($isElementNode2(sibling)) {
              newOffset = sibling.getChildrenSize();
            }
          }
          let newFocusNode = sibling;
          if (direction === "up") {
            if ($isElementNode2(sibling)) {
              const lastCell = sibling.getLastChild();
              newFocusNode = lastCell ? lastCell : sibling;
              newOffset = $isTextNode2(newFocusNode) ? newFocusNode.getTextContentSize() : 0;
            }
          }
          const newSelection = selection.clone();
          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode2(newFocusNode) ? "text" : "element");
          $setSelection2(newSelection);
          stopEvent(event);
          return true;
        } else if ($isRootOrShadowRoot2(focusNode)) {
          const selectedNode = direction === "up" ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];
          if (selectedNode) {
            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);
            if (tableCellNode !== null) {
              const firstDescendant = tableNode.getFirstDescendant();
              const lastDescendant = tableNode.getLastDescendant();
              if (!firstDescendant || !lastDescendant) {
                return false;
              }
              const [firstCellNode] = $getNodeTriplet(firstDescendant);
              const [lastCellNode] = $getNodeTriplet(lastDescendant);
              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);
              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);
              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);
              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);
              tableObserver.$setAnchorCellForSelection(firstCellDOM);
              tableObserver.$setFocusCellForSelection(lastCellDOM, true);
              return true;
            }
          }
          return false;
        } else {
          let focusParentNode = $findMatchingParent3(focusNode, (n2) => $isElementNode2(n2) && !n2.isInline());
          if ($isTableCellNode(focusParentNode)) {
            focusParentNode = $findMatchingParent3(focusParentNode, $isTableNode);
          }
          if (!focusParentNode) {
            return false;
          }
          const sibling = direction === "down" ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();
          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {
            const firstDescendant = sibling.getFirstDescendant();
            const lastDescendant = sibling.getLastDescendant();
            if (!firstDescendant || !lastDescendant) {
              return false;
            }
            const [firstCellNode] = $getNodeTriplet(firstDescendant);
            const [lastCellNode] = $getNodeTriplet(lastDescendant);
            const newSelection = selection.clone();
            newSelection.focus.set((direction === "up" ? firstCellNode : lastCellNode).getKey(), direction === "up" ? 0 : lastCellNode.getChildrenSize(), "element");
            stopEvent(event);
            $setSelection2(newSelection);
            return true;
          }
        }
      }
    }
    if (direction === "down" && $isScrollableTablesActive(editor)) {
      tableObserver.setShouldCheckSelection();
    }
    return false;
  }
  if ($isRangeSelection2(selection)) {
    if (direction === "backward" || direction === "forward") {
      const alter = event.shiftKey ? "extend" : "move";
      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === "backward", tableNode, tableObserver);
    }
    if (selection.isCollapsed()) {
      const {
        anchor,
        focus
      } = selection;
      const anchorCellNode = $findMatchingParent3(anchor.getNode(), $isTableCellNode);
      const focusCellNode = $findMatchingParent3(focus.getNode(), $isTableCellNode);
      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {
        return false;
      }
      const anchorCellTable = $findTableNode(anchorCellNode);
      if (anchorCellTable !== tableNode && anchorCellTable != null) {
        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));
        if (anchorCellTableElement != null) {
          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);
          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);
        }
      }
      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);
      const anchorDOM = editor.getElementByKey(anchor.key);
      if (anchorDOM == null || anchorCellDom == null) {
        return false;
      }
      let edgeSelectionRect;
      if (anchor.type === "element") {
        edgeSelectionRect = anchorDOM.getBoundingClientRect();
      } else {
        const domSelection = getDOMSelection2(getEditorWindow(editor));
        if (domSelection === null || domSelection.rangeCount === 0) {
          return false;
        }
        const range = domSelection.getRangeAt(0);
        edgeSelectionRect = range.getBoundingClientRect();
      }
      const edgeChild = direction === "up" ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();
      if (edgeChild == null) {
        return false;
      }
      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);
      if (edgeChildDOM == null) {
        return false;
      }
      const edgeRect = edgeChildDOM.getBoundingClientRect();
      const isExiting = direction === "up" ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;
      if (isExiting) {
        stopEvent(event);
        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);
        if (event.shiftKey) {
          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);
          tableObserver.$setAnchorCellForSelection(cell);
          tableObserver.$setFocusCellForSelection(cell, true);
        } else {
          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);
        }
        return true;
      }
    }
  } else if ($isTableSelection(selection)) {
    const {
      anchor,
      focus
    } = selection;
    const anchorCellNode = $findMatchingParent3(anchor.getNode(), $isTableCellNode);
    const focusCellNode = $findMatchingParent3(focus.getNode(), $isTableCellNode);
    const [tableNodeFromSelection] = selection.getNodes();
    if (!$isTableNode(tableNodeFromSelection)) {
      formatDevErrorMessage7(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);
    }
    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));
    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {
      return false;
    }
    tableObserver.$updateTableTableSelection(selection);
    const grid = getTable(tableNodeFromSelection, tableElement);
    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);
    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);
    tableObserver.$setAnchorCellForSelection(anchorCell);
    stopEvent(event);
    if (event.shiftKey) {
      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);
      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);
    } else {
      focusCellNode.selectEnd();
    }
    return true;
  }
  return false;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
  event.stopPropagation();
}
function isTypeaheadMenuInView(editor) {
  const root = editor.getRootElement();
  if (!root) {
    return false;
  }
  return root.hasAttribute("aria-controls") && root.getAttribute("aria-controls") === "typeahead-menu";
}
function $insertParagraphAtTableEdge(edgePosition, tableNode, children) {
  const paragraphNode = $createParagraphNode2();
  if (edgePosition === "first") {
    tableNode.insertBefore(paragraphNode);
  } else {
    tableNode.insertAfter(paragraphNode);
  }
  paragraphNode.append(...children || []);
  paragraphNode.selectEnd();
}
function $getTableEdgeCursorPosition(editor, selection, tableNode) {
  const tableNodeParent = tableNode.getParent();
  if (!tableNodeParent) {
    return void 0;
  }
  const domSelection = getDOMSelection2(getEditorWindow(editor));
  if (!domSelection) {
    return void 0;
  }
  const domAnchorNode = domSelection.anchorNode;
  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());
  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));
  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {
    return void 0;
  }
  const anchorCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
  if (!anchorCellNode) {
    return void 0;
  }
  const parentTable = $findMatchingParent3(anchorCellNode, (n2) => $isTableNode(n2));
  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {
    return void 0;
  }
  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);
  const firstCell = tableMap[0][0];
  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];
  const {
    startRow,
    startColumn
  } = cellValue;
  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;
  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;
  if (isAtFirstCell) {
    return "first";
  } else if (isAtLastCell) {
    return "last";
  } else {
    return void 0;
  }
}
function $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {
  const {
    tableNode
  } = tableObserver.$lookup();
  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);
  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);
}
function $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {
  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode2(startingDOM, editorState));
}
function isHTMLDivElement(element) {
  return isHTMLElement3(element) && element.nodeName === "DIV";
}
function updateColgroup(dom2, config, colCount, colWidths) {
  const colGroup = dom2.querySelector("colgroup");
  if (!colGroup) {
    return;
  }
  const cols = [];
  for (let i2 = 0; i2 < colCount; i2++) {
    const col = document.createElement("col");
    const width = colWidths && colWidths[i2];
    if (width) {
      col.style.width = `${width}px`;
    }
    cols.push(col);
  }
  colGroup.replaceChildren(...cols);
}
function setRowStriping(dom2, config, rowStriping) {
  if (rowStriping) {
    addClassNamesToElement2(dom2, config.theme.tableRowStriping);
    dom2.setAttribute("data-lexical-row-striping", "true");
  } else {
    removeClassNamesFromElement2(dom2, config.theme.tableRowStriping);
    dom2.removeAttribute("data-lexical-row-striping");
  }
}
function setFrozenColumns(dom2, tableElement, config, frozenColumnCount) {
  if (frozenColumnCount > 0) {
    addClassNamesToElement2(dom2, config.theme.tableFrozenColumn);
    tableElement.setAttribute("data-lexical-frozen-column", "true");
  } else {
    removeClassNamesFromElement2(dom2, config.theme.tableFrozenColumn);
    tableElement.removeAttribute("data-lexical-frozen-column");
  }
}
function setFrozenRows(dom2, tableElement, config, frozenRowCount) {
  if (frozenRowCount > 0) {
    addClassNamesToElement2(dom2, config.theme.tableFrozenRow);
    tableElement.setAttribute("data-lexical-frozen-row", "true");
  } else {
    removeClassNamesFromElement2(dom2, config.theme.tableFrozenRow);
    tableElement.removeAttribute("data-lexical-frozen-row");
  }
}
function alignTableElement(dom2, config, formatType) {
  if (!config.theme.tableAlignment) {
    return;
  }
  const removeClasses = [];
  const addClasses = [];
  for (const format of ["center", "right"]) {
    const classes = config.theme.tableAlignment[format];
    if (!classes) {
      continue;
    }
    (format === formatType ? addClasses : removeClasses).push(classes);
  }
  removeClassNamesFromElement2(dom2, ...removeClasses);
  addClassNamesToElement2(dom2, ...addClasses);
}
function $isScrollableTablesActive(editor = $getEditor2()) {
  return scrollableEditors.has(editor);
}
function setScrollableTablesActive(editor, active) {
  if (active) {
    if (!editor._config.theme.tableScrollableWrapper) {
      console.warn("TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.");
    }
    scrollableEditors.add(editor);
  } else {
    scrollableEditors.delete(editor);
  }
}
function $getElementForTableNode(editor, tableNode) {
  const tableElement = editor.getElementByKey(tableNode.getKey());
  if (!(tableElement !== null)) {
    formatDevErrorMessage7(`$getElementForTableNode: Table Element Not Found`);
  }
  return getTable(tableNode, tableElement);
}
function $convertTableElement(domNode) {
  const tableNode = $createTableNode();
  if (domNode.hasAttribute("data-lexical-row-striping")) {
    tableNode.setRowStriping(true);
  }
  if (domNode.hasAttribute("data-lexical-frozen-column")) {
    tableNode.setFrozenColumns(1);
  }
  if (domNode.hasAttribute("data-lexical-frozen-row")) {
    tableNode.setFrozenRows(1);
  }
  const colGroup = domNode.querySelector(":scope > colgroup");
  if (colGroup) {
    let columns = [];
    for (const col of colGroup.querySelectorAll(":scope > col")) {
      let width = col.style.width || "";
      if (!PIXEL_VALUE_REG_EXP.test(width)) {
        width = col.getAttribute("width") || "";
        if (!/^\d+$/.test(width)) {
          columns = void 0;
          break;
        }
      }
      columns.push(parseFloat(width));
    }
    if (columns) {
      tableNode.setColWidths(columns);
    }
  }
  return {
    after: (children) => $descendantsMatching2(children, $isTableRowNode),
    node: tableNode
  };
}
function $createTableNode() {
  return $applyNodeReplacement2(new TableNode());
}
function $isTableNode(node) {
  return node instanceof TableNode;
}
function $insertTableCommandListener({
  rows,
  columns,
  includeHeaders
}) {
  const selection = $getSelection2() || $getPreviousSelection2();
  if (!selection || !$isRangeSelection2(selection)) {
    return false;
  }
  if ($findTableNode(selection.anchor.getNode())) {
    return false;
  }
  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);
  $insertNodeToNearestRoot2(tableNode);
  const firstDescendant = tableNode.getFirstDescendant();
  if ($isTextNode2(firstDescendant)) {
    firstDescendant.select();
  }
  return true;
}
function $tableCellTransform(node) {
  if (!$isTableRowNode(node.getParent())) {
    node.remove();
  } else if (node.isEmpty()) {
    node.append($createParagraphNode2());
  }
}
function $tableRowTransform(node) {
  if (!$isTableNode(node.getParent())) {
    node.remove();
  } else {
    $unwrapAndFilterDescendants2(node, $isTableCellNode);
  }
}
function $tableTransform(node) {
  $unwrapAndFilterDescendants2(node, $isTableRowNode);
  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);
  const maxRowLength = gridMap.reduce((curLength, row) => {
    return Math.max(curLength, row.length);
  }, 0);
  const rowNodes = node.getChildren();
  for (let i2 = 0; i2 < gridMap.length; ++i2) {
    const rowNode = rowNodes[i2];
    if (!rowNode) {
      continue;
    }
    if (!$isTableRowNode(rowNode)) {
      formatDevErrorMessage7(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);
    }
    const rowLength = gridMap[i2].reduce((acc, cell) => cell ? 1 + acc : acc, 0);
    if (rowLength === maxRowLength) {
      continue;
    }
    for (let j5 = rowLength; j5 < maxRowLength; ++j5) {
      const newCell = $createTableCellNode();
      newCell.append($createParagraphNode2());
      rowNode.append(newCell);
    }
  }
}
function $tableClickCommand(event) {
  if (event.detail < 3 || !isDOMNode2(event.target)) {
    return false;
  }
  const startNode = $getNearestNodeFromDOMNode2(event.target);
  if (startNode === null) {
    return false;
  }
  const blockNode = $findMatchingParent3(startNode, (node) => $isElementNode2(node) && !node.isInline());
  if (blockNode === null) {
    return false;
  }
  const rootNode = blockNode.getParent();
  if (!$isTableCellNode(rootNode)) {
    return false;
  }
  blockNode.select(0);
  return true;
}
function registerTableCellUnmergeTransform(editor) {
  return editor.registerNodeTransform(TableCellNode, (node) => {
    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {
      const [, , gridNode] = $getNodeTriplet(node);
      const [gridMap] = $computeTableMap(gridNode, node, node);
      const rowsCount = gridMap.length;
      const columnsCount = gridMap[0].length;
      let row = gridNode.getFirstChild();
      if (!$isTableRowNode(row)) {
        formatDevErrorMessage7(`Expected TableNode first child to be a RowNode`);
      }
      const unmerged = [];
      for (let i2 = 0; i2 < rowsCount; i2++) {
        if (i2 !== 0) {
          row = row.getNextSibling();
          if (!$isTableRowNode(row)) {
            formatDevErrorMessage7(`Expected TableNode first child to be a RowNode`);
          }
        }
        let lastRowCell = null;
        for (let j5 = 0; j5 < columnsCount; j5++) {
          const cellMap = gridMap[i2][j5];
          const cell = cellMap.cell;
          if (cellMap.startRow === i2 && cellMap.startColumn === j5) {
            lastRowCell = cell;
            unmerged.push(cell);
          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {
            if (!$isTableCellNode(cell)) {
              formatDevErrorMessage7(`Expected TableNode cell to be a TableCellNode`);
            }
            const newCell = $createTableCellNode(cell.__headerState);
            if (lastRowCell !== null) {
              lastRowCell.insertAfter(newCell);
            } else {
              $insertFirst2(row, newCell);
            }
          }
        }
      }
      for (const cell of unmerged) {
        cell.setColSpan(1);
        cell.setRowSpan(1);
      }
    }
  });
}
function registerTableSelectionObserver(editor, hasTabHandler = true) {
  const tableSelections = /* @__PURE__ */ new Map();
  const initializeTableNode = (tableNode, nodeKey, dom2) => {
    const tableElement = getTableElement(tableNode, dom2);
    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);
    tableSelections.set(nodeKey, [tableSelection, tableElement]);
  };
  const unregisterMutationListener = editor.registerMutationListener(TableNode, (nodeMutations) => {
    editor.getEditorState().read(() => {
      for (const [nodeKey, mutation] of nodeMutations) {
        const tableSelection = tableSelections.get(nodeKey);
        if (mutation === "created" || mutation === "updated") {
          const {
            tableNode,
            tableElement
          } = $getTableAndElementByKey(nodeKey);
          if (tableSelection === void 0) {
            initializeTableNode(tableNode, nodeKey, tableElement);
          } else if (tableElement !== tableSelection[1]) {
            tableSelection[0].removeListeners();
            tableSelections.delete(nodeKey);
            initializeTableNode(tableNode, nodeKey, tableElement);
          }
        } else if (mutation === "destroyed") {
          if (tableSelection !== void 0) {
            tableSelection[0].removeListeners();
            tableSelections.delete(nodeKey);
          }
        }
      }
    }, {
      editor
    });
  }, {
    skipInitialization: false
  });
  return () => {
    unregisterMutationListener();
    for (const [, [tableSelection]] of tableSelections) {
      tableSelection.removeListeners();
    }
  };
}
function registerTablePlugin(editor) {
  if (!editor.hasNodes([TableNode])) {
    {
      formatDevErrorMessage7(`TablePlugin: TableNode is not registered on editor`);
    }
  }
  return mergeRegister2(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, ({
    nodes,
    selection
  }) => {
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;
    return isInsideTableCell && nodes.some($isTableNode);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLICK_COMMAND2, $tableClickCommand, COMMAND_PRIORITY_EDITOR2), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));
}
var PIXEL_VALUE_REG_EXP, COLUMN_WIDTH, TableCellHeaderStates, TableCellNode, INSERT_TABLE_COMMAND, TableRowNode, CAN_USE_DOM5, documentMode4, IS_FIREFOX4, getHeaderState, $insertTableRow__EXPERIMENTAL, $insertTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $deleteTableColumn__EXPERIMENTAL, TableSelection, TableObserver, LEXICAL_ELEMENT_KEY, isPointerDownOnEvent, ARROW_KEY_COMMANDS_WITH_DIRECTION, DELETE_TEXT_COMMANDS, DELETE_KEY_COMMANDS, selectTableNodeInDirection, scrollableEditors, TableNode;
var init_LexicalTable_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/table@0.32.1/node_modules/@lexical/table/LexicalTable.dev.mjs"() {
    await init_LexicalUtils_node();
    await init_Lexical_node();
    await init_LexicalClipboard_node();
    PIXEL_VALUE_REG_EXP = /^(\d+(?:\.\d+)?)px$/;
    COLUMN_WIDTH = 75;
    TableCellHeaderStates = {
      BOTH: 3,
      COLUMN: 2,
      NO_STATUS: 0,
      ROW: 1
    };
    TableCellNode = class _TableCellNode extends ElementNode2 {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "tablecell";
      }
      static clone(node) {
        return new _TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);
      }
      afterCloneFrom(node) {
        super.afterCloneFrom(node);
        this.__rowSpan = node.__rowSpan;
        this.__backgroundColor = node.__backgroundColor;
        this.__verticalAlign = node.__verticalAlign;
      }
      static importDOM() {
        return {
          td: (node) => ({
            conversion: $convertTableCellNodeElement,
            priority: 0
          }),
          th: (node) => ({
            conversion: $convertTableCellNodeElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        return $createTableCellNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || void 0).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || void 0);
      }
      constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key2) {
        super(key2);
        this.__colSpan = colSpan;
        this.__rowSpan = 1;
        this.__headerState = headerState;
        this.__width = width;
        this.__backgroundColor = null;
        this.__verticalAlign = void 0;
      }
      createDOM(config) {
        const element = document.createElement(this.getTag());
        if (this.__width) {
          element.style.width = `${this.__width}px`;
        }
        if (this.__colSpan > 1) {
          element.colSpan = this.__colSpan;
        }
        if (this.__rowSpan > 1) {
          element.rowSpan = this.__rowSpan;
        }
        if (this.__backgroundColor !== null) {
          element.style.backgroundColor = this.__backgroundColor;
        }
        if (isValidVerticalAlign(this.__verticalAlign)) {
          element.style.verticalAlign = this.__verticalAlign;
        }
        addClassNamesToElement2(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);
        return element;
      }
      exportDOM(editor) {
        const output = super.exportDOM(editor);
        if (isHTMLElement2(output.element)) {
          const element = output.element;
          element.setAttribute("data-temporary-table-cell-lexical-key", this.getKey());
          element.style.border = "1px solid black";
          if (this.__colSpan > 1) {
            element.colSpan = this.__colSpan;
          }
          if (this.__rowSpan > 1) {
            element.rowSpan = this.__rowSpan;
          }
          element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;
          element.style.verticalAlign = this.getVerticalAlign() || "top";
          element.style.textAlign = "start";
          if (this.__backgroundColor === null && this.hasHeader()) {
            element.style.backgroundColor = "#f2f3f5";
          }
        }
        return output;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          ...isValidVerticalAlign(this.__verticalAlign) && {
            verticalAlign: this.__verticalAlign
          },
          backgroundColor: this.getBackgroundColor(),
          colSpan: this.__colSpan,
          headerState: this.__headerState,
          rowSpan: this.__rowSpan,
          width: this.getWidth()
        };
      }
      getColSpan() {
        return this.getLatest().__colSpan;
      }
      setColSpan(colSpan) {
        const self = this.getWritable();
        self.__colSpan = colSpan;
        return self;
      }
      getRowSpan() {
        return this.getLatest().__rowSpan;
      }
      setRowSpan(rowSpan) {
        const self = this.getWritable();
        self.__rowSpan = rowSpan;
        return self;
      }
      getTag() {
        return this.hasHeader() ? "th" : "td";
      }
      setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {
        const self = this.getWritable();
        self.__headerState = headerState & mask | self.__headerState & ~mask;
        return self;
      }
      getHeaderStyles() {
        return this.getLatest().__headerState;
      }
      setWidth(width) {
        const self = this.getWritable();
        self.__width = width;
        return self;
      }
      getWidth() {
        return this.getLatest().__width;
      }
      getBackgroundColor() {
        return this.getLatest().__backgroundColor;
      }
      setBackgroundColor(newBackgroundColor) {
        const self = this.getWritable();
        self.__backgroundColor = newBackgroundColor;
        return self;
      }
      getVerticalAlign() {
        return this.getLatest().__verticalAlign;
      }
      setVerticalAlign(newVerticalAlign) {
        const self = this.getWritable();
        self.__verticalAlign = newVerticalAlign || void 0;
        return self;
      }
      toggleHeaderStyle(headerStateToToggle) {
        const self = this.getWritable();
        if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {
          self.__headerState -= headerStateToToggle;
        } else {
          self.__headerState += headerStateToToggle;
        }
        return self;
      }
      hasHeaderState(headerState) {
        return (this.getHeaderStyles() & headerState) === headerState;
      }
      hasHeader() {
        return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;
      }
      updateDOM(prevNode) {
        return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;
      }
      isShadowRoot() {
        return true;
      }
      collapseAtStart() {
        return true;
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
    };
    INSERT_TABLE_COMMAND = createCommand2("INSERT_TABLE_COMMAND");
    TableRowNode = class _TableRowNode extends ElementNode2 {
      /** @internal */
      static getType() {
        return "tablerow";
      }
      static clone(node) {
        return new _TableRowNode(node.__height, node.__key);
      }
      static importDOM() {
        return {
          tr: (node) => ({
            conversion: $convertTableRowElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        return $createTableRowNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);
      }
      constructor(height, key2) {
        super(key2);
        this.__height = height;
      }
      exportJSON() {
        const height = this.getHeight();
        return {
          ...super.exportJSON(),
          ...height === void 0 ? void 0 : {
            height
          }
        };
      }
      createDOM(config) {
        const element = document.createElement("tr");
        if (this.__height) {
          element.style.height = `${this.__height}px`;
        }
        addClassNamesToElement2(element, config.theme.tableRow);
        return element;
      }
      extractWithChild(child, selection, destination) {
        return destination === "html";
      }
      isShadowRoot() {
        return true;
      }
      setHeight(height) {
        const self = this.getWritable();
        self.__height = height;
        return self;
      }
      getHeight() {
        return this.getLatest().__height;
      }
      updateDOM(prevNode) {
        return prevNode.__height !== this.__height;
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
    };
    CAN_USE_DOM5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode4 = CAN_USE_DOM5 && "documentMode" in document ? document.documentMode : null;
    IS_FIREFOX4 = CAN_USE_DOM5 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    CAN_USE_DOM5 && "InputEvent" in window && !documentMode4 ? "getTargetRanges" in new window.InputEvent("input") : false;
    getHeaderState = (currentState, possibleState) => {
      if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {
        return possibleState;
      }
      return TableCellHeaderStates.NO_STATUS;
    };
    $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;
    $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;
    $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;
    $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;
    TableSelection = class _TableSelection {
      constructor(tableKey, anchor, focus) {
        this.anchor = anchor;
        this.focus = focus;
        anchor._selection = this;
        focus._selection = this;
        this._cachedNodes = null;
        this.dirty = false;
        this.tableKey = tableKey;
      }
      getStartEndPoints() {
        return [this.anchor, this.focus];
      }
      /**
       * {@link $createTableSelection} unfortunately makes it very easy to create
       * nonsense selections, so we have a method to see if the selection probably
       * makes sense.
       *
       * @returns true if the TableSelection is (probably) valid
       */
      isValid() {
        return this.tableKey !== "root" && this.anchor.key !== "root" && this.anchor.type === "element" && this.focus.key !== "root" && this.focus.type === "element";
      }
      /**
       * Returns whether the Selection is "backwards", meaning the focus
       * logically precedes the anchor in the EditorState.
       * @returns true if the Selection is backwards, false otherwise.
       */
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(nodes) {
        this._cachedNodes = nodes;
      }
      is(selection) {
        return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
      }
      set(tableKey, anchorCellKey, focusCellKey) {
        this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;
        this.tableKey = tableKey;
        this.anchor.key = anchorCellKey;
        this.focus.key = focusCellKey;
        this._cachedNodes = null;
      }
      clone() {
        return new _TableSelection(this.tableKey, $createPoint2(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint2(this.focus.key, this.focus.offset, this.focus.type));
      }
      isCollapsed() {
        return false;
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text) {
      }
      insertText() {
      }
      /**
       * Returns whether the provided TextFormatType is present on the Selection.
       * This will be true if any paragraph in table cells has the specified format.
       *
       * @param type the TextFormatType to check for.
       * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
       */
      hasFormat(type) {
        let format = 0;
        const cellNodes = this.getNodes().filter($isTableCellNode);
        cellNodes.forEach((cellNode) => {
          const paragraph = cellNode.getFirstChild();
          if ($isParagraphNode2(paragraph)) {
            format |= paragraph.getTextFormat();
          }
        });
        const formatFlag = TEXT_TYPE_TO_FORMAT2[type];
        return (format & formatFlag) !== 0;
      }
      insertNodes(nodes) {
        const focusNode = this.focus.getNode();
        if (!$isElementNode2(focusNode)) {
          formatDevErrorMessage7(`Expected TableSelection focus to be an ElementNode`);
        }
        const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));
        selection.insertNodes(nodes);
      }
      // TODO Deprecate this method. It's confusing when used with colspan|rowspan
      getShape() {
        const {
          anchorCell,
          focusCell
        } = $getCellNodes(this);
        const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);
        if (!(anchorCellNodeRect !== null)) {
          formatDevErrorMessage7(`getCellRect: expected to find AnchorNode`);
        }
        const focusCellNodeRect = $getTableCellNodeRect(focusCell);
        if (!(focusCellNodeRect !== null)) {
          formatDevErrorMessage7(`getCellRect: expected to find focusCellNode`);
        }
        const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);
        const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);
        const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);
        const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);
        return {
          fromX: Math.min(startX, stopX),
          fromY: Math.min(startY, stopY),
          toX: Math.max(startX, stopX),
          toY: Math.max(startY, stopY)
        };
      }
      getNodes() {
        if (!this.isValid()) {
          return [];
        }
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const {
          anchorTable: tableNode,
          anchorCell,
          focusCell
        } = $getCellNodes(this);
        const focusCellGrid = focusCell.getParents()[1];
        if (focusCellGrid !== tableNode) {
          if (!tableNode.isParentOf(focusCell)) {
            const gridParent = tableNode.getParent();
            if (!(gridParent != null)) {
              formatDevErrorMessage7(`Expected gridParent to have a parent`);
            }
            this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());
          } else {
            const focusCellParent = focusCellGrid.getParent();
            if (!(focusCellParent != null)) {
              formatDevErrorMessage7(`Expected focusCellParent to have a parent`);
            }
            this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());
          }
          return this.getNodes();
        }
        const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);
        const {
          minColumn,
          maxColumn,
          minRow,
          maxRow
        } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);
        const nodeMap = /* @__PURE__ */ new Map([[tableNode.getKey(), tableNode]]);
        let lastRow = null;
        for (let i2 = minRow; i2 <= maxRow; i2++) {
          for (let j5 = minColumn; j5 <= maxColumn; j5++) {
            const {
              cell
            } = map[i2][j5];
            const currentRow = cell.getParent();
            if (!$isTableRowNode(currentRow)) {
              formatDevErrorMessage7(`Expected TableCellNode parent to be a TableRowNode`);
            }
            if (currentRow !== lastRow) {
              nodeMap.set(currentRow.getKey(), currentRow);
              lastRow = currentRow;
            }
            if (!nodeMap.has(cell.getKey())) {
              $visitRecursively(cell, (childNode) => {
                nodeMap.set(childNode.getKey(), childNode);
              });
            }
          }
        }
        const nodes = Array.from(nodeMap.values());
        if (!isCurrentlyReadOnlyMode2()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes().filter((node) => $isTableCellNode(node));
        let textContent2 = "";
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          const row = node.__parent;
          const nextRow = (nodes[i2 + 1] || {}).__parent;
          textContent2 += node.getTextContent() + (nextRow !== row ? "\n" : "	");
        }
        return textContent2;
      }
    };
    TableObserver = class {
      constructor(editor, tableNodeKey) {
        this.isHighlightingCells = false;
        this.anchorX = -1;
        this.anchorY = -1;
        this.focusX = -1;
        this.focusY = -1;
        this.listenersToRemove = /* @__PURE__ */ new Set();
        this.tableNodeKey = tableNodeKey;
        this.editor = editor;
        this.table = {
          columns: 0,
          domRows: [],
          rows: 0
        };
        this.tableSelection = null;
        this.anchorCellNodeKey = null;
        this.focusCellNodeKey = null;
        this.anchorCell = null;
        this.focusCell = null;
        this.hasHijackedSelectionStyles = false;
        this.isSelecting = false;
        this.pointerType = null;
        this.shouldCheckSelection = false;
        this.abortController = new AbortController();
        this.listenerOptions = {
          signal: this.abortController.signal
        };
        this.nextFocus = null;
        this.trackTable();
      }
      getTable() {
        return this.table;
      }
      removeListeners() {
        this.abortController.abort("removeListeners");
        Array.from(this.listenersToRemove).forEach((removeListener) => removeListener());
        this.listenersToRemove.clear();
      }
      $lookup() {
        return $getTableAndElementByKey(this.tableNodeKey, this.editor);
      }
      trackTable() {
        const observer = new MutationObserver((records) => {
          this.editor.getEditorState().read(() => {
            let gridNeedsRedraw = false;
            for (let i2 = 0; i2 < records.length; i2++) {
              const record = records[i2];
              const target = record.target;
              const nodeName = target.nodeName;
              if (nodeName === "TABLE" || nodeName === "TBODY" || nodeName === "THEAD" || nodeName === "TR") {
                gridNeedsRedraw = true;
                break;
              }
            }
            if (!gridNeedsRedraw) {
              return;
            }
            const {
              tableNode,
              tableElement
            } = this.$lookup();
            this.table = getTable(tableNode, tableElement);
          }, {
            editor: this.editor
          });
        });
        this.editor.getEditorState().read(() => {
          const {
            tableNode,
            tableElement
          } = this.$lookup();
          this.table = getTable(tableNode, tableElement);
          observer.observe(tableElement, {
            attributes: true,
            childList: true,
            subtree: true
          });
        }, {
          editor: this.editor
        });
      }
      $clearHighlight() {
        const editor = this.editor;
        this.isHighlightingCells = false;
        this.anchorX = -1;
        this.anchorY = -1;
        this.focusX = -1;
        this.focusY = -1;
        this.tableSelection = null;
        this.anchorCellNodeKey = null;
        this.focusCellNodeKey = null;
        this.anchorCell = null;
        this.focusCell = null;
        this.hasHijackedSelectionStyles = false;
        this.$enableHighlightStyle();
        const {
          tableNode,
          tableElement
        } = this.$lookup();
        const grid = getTable(tableNode, tableElement);
        $updateDOMForSelection(editor, grid, null);
        if ($getSelection2() !== null) {
          $setSelection2(null);
          editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
        }
      }
      $enableHighlightStyle() {
        const editor = this.editor;
        const {
          tableElement
        } = this.$lookup();
        removeClassNamesFromElement2(tableElement, editor._config.theme.tableSelection);
        tableElement.classList.remove("disable-selection");
        this.hasHijackedSelectionStyles = false;
      }
      $disableHighlightStyle() {
        const {
          tableElement
        } = this.$lookup();
        addClassNamesToElement2(tableElement, this.editor._config.theme.tableSelection);
        this.hasHijackedSelectionStyles = true;
      }
      $updateTableTableSelection(selection) {
        if (selection !== null) {
          if (!(selection.tableKey === this.tableNodeKey)) {
            formatDevErrorMessage7(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);
          }
          const editor = this.editor;
          this.tableSelection = selection;
          this.isHighlightingCells = true;
          this.$disableHighlightStyle();
          this.updateDOMSelection();
          $updateDOMForSelection(editor, this.table, this.tableSelection);
        } else {
          this.$clearHighlight();
        }
      }
      /**
       * @internal
       * Firefox has a strange behavior where pressing the down arrow key from
       * above the table will move the caret after the table and then lexical
       * will select the last cell instead of the first.
       * We do still want to let the browser handle caret movement but we will
       * use this property to "tag" the update so that we can recheck the
       * selection after the event is processed.
       */
      setShouldCheckSelection() {
        this.shouldCheckSelection = true;
      }
      /**
       * @internal
       */
      getAndClearShouldCheckSelection() {
        if (this.shouldCheckSelection) {
          this.shouldCheckSelection = false;
          return true;
        }
        return false;
      }
      /**
       * @internal
       * When handling mousemove events we track what the focus cell should be, but
       * the DOM selection may end up somewhere else entirely. We don't have an elegant
       * way to handle this after the DOM selection has been resolved in a
       * SELECTION_CHANGE_COMMAND callback.
       */
      setNextFocus(nextFocus) {
        this.nextFocus = nextFocus;
      }
      /** @internal */
      getAndClearNextFocus() {
        const {
          nextFocus
        } = this;
        if (nextFocus !== null) {
          this.nextFocus = null;
        }
        return nextFocus;
      }
      /** @internal */
      updateDOMSelection() {
        if (this.anchorCell !== null && this.focusCell !== null) {
          const domSelection = getDOMSelection2(this.editor._window);
          if (domSelection && domSelection.rangeCount > 0) {
            domSelection.removeAllRanges();
          }
        }
      }
      $setFocusCellForSelection(cell, ignoreStart = false) {
        const editor = this.editor;
        const {
          tableNode
        } = this.$lookup();
        const cellX = cell.x;
        const cellY = cell.y;
        this.focusCell = cell;
        if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {
          this.isHighlightingCells = true;
          this.$disableHighlightStyle();
        } else if (cellX === this.focusX && cellY === this.focusY) {
          return false;
        }
        this.focusX = cellX;
        this.focusY = cellY;
        if (this.isHighlightingCells) {
          const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);
          if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {
            this.focusCellNodeKey = focusTableCellNode.getKey();
            this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);
            $setSelection2(this.tableSelection);
            editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
            $updateDOMForSelection(editor, this.table, this.tableSelection);
            return true;
          }
        }
        return false;
      }
      $getAnchorTableCell() {
        return this.anchorCellNodeKey ? $getNodeByKey2(this.anchorCellNodeKey) : null;
      }
      $getAnchorTableCellOrThrow() {
        const anchorTableCell = this.$getAnchorTableCell();
        if (!(anchorTableCell !== null)) {
          formatDevErrorMessage7(`TableObserver anchorTableCell is null`);
        }
        return anchorTableCell;
      }
      $getFocusTableCell() {
        return this.focusCellNodeKey ? $getNodeByKey2(this.focusCellNodeKey) : null;
      }
      $getFocusTableCellOrThrow() {
        const focusTableCell = this.$getFocusTableCell();
        if (!(focusTableCell !== null)) {
          formatDevErrorMessage7(`TableObserver focusTableCell is null`);
        }
        return focusTableCell;
      }
      $setAnchorCellForSelection(cell) {
        this.isHighlightingCells = false;
        this.anchorCell = cell;
        this.anchorX = cell.x;
        this.anchorY = cell.y;
        const {
          tableNode
        } = this.$lookup();
        const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);
        if (anchorTableCellNode !== null) {
          const anchorNodeKey = anchorTableCellNode.getKey();
          this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();
          this.anchorCellNodeKey = anchorNodeKey;
        }
      }
      $formatCells(type) {
        const selection = $getSelection2();
        if (!$isTableSelection(selection)) {
          formatDevErrorMessage7(`Expected Table selection`);
        }
        const formatSelection = $createRangeSelection2();
        const anchor = formatSelection.anchor;
        const focus = formatSelection.focus;
        const cellNodes = selection.getNodes().filter($isTableCellNode);
        if (!(cellNodes.length > 0)) {
          formatDevErrorMessage7(`No table cells present`);
        }
        const paragraph = cellNodes[0].getFirstChild();
        const alignFormatWith = $isParagraphNode2(paragraph) ? paragraph.getFormatFlags(type, null) : null;
        cellNodes.forEach((cellNode) => {
          anchor.set(cellNode.getKey(), 0, "element");
          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), "element");
          formatSelection.formatText(type, alignFormatWith);
        });
        $setSelection2(selection);
        this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
      $clearText() {
        const {
          editor
        } = this;
        const tableNode = $getNodeByKey2(this.tableNodeKey);
        if (!$isTableNode(tableNode)) {
          throw new Error("Expected TableNode.");
        }
        const selection = $getSelection2();
        if (!$isTableSelection(selection)) {
          formatDevErrorMessage7(`Expected TableSelection`);
        }
        const selectedNodes = selection.getNodes().filter($isTableCellNode);
        const firstRow = tableNode.getFirstChild();
        const lastRow = tableNode.getLastChild();
        const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();
        if (isEntireTableSelected) {
          tableNode.selectPrevious();
          const parent = tableNode.getParent();
          tableNode.remove();
          if ($isRootNode2(parent) && parent.isEmpty()) {
            editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
          }
          return;
        }
        selectedNodes.forEach((cellNode) => {
          if ($isElementNode2(cellNode)) {
            const paragraphNode = $createParagraphNode2();
            const textNode = $createTextNode2();
            paragraphNode.append(textNode);
            cellNode.append(paragraphNode);
            cellNode.getChildren().forEach((child) => {
              if (child !== paragraphNode) {
                child.remove();
              }
            });
          }
        });
        $updateDOMForSelection(editor, this.table, null);
        $setSelection2(null);
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
    };
    LEXICAL_ELEMENT_KEY = "__lexicalTableSelection";
    isPointerDownOnEvent = (event) => {
      return (event.buttons & 1) === 1;
    };
    ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND2, "down"], [KEY_ARROW_UP_COMMAND2, "up"], [KEY_ARROW_LEFT_COMMAND2, "backward"], [KEY_ARROW_RIGHT_COMMAND2, "forward"]];
    DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND2, DELETE_LINE_COMMAND2, DELETE_CHARACTER_COMMAND2];
    DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND2, KEY_DELETE_COMMAND2];
    selectTableNodeInDirection = (tableObserver, tableNode, x4, y4, direction) => {
      const isForward = direction === "forward";
      switch (direction) {
        case "backward":
        case "forward":
          if (x4 !== (isForward ? tableObserver.table.columns - 1 : 0)) {
            selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x4 + (isForward ? 1 : -1), y4, tableObserver.table), isForward);
          } else {
            if (y4 !== (isForward ? tableObserver.table.rows - 1 : 0)) {
              selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y4 + (isForward ? 1 : -1), tableObserver.table), isForward);
            } else if (!isForward) {
              tableNode.selectPrevious();
            } else {
              tableNode.selectNext();
            }
          }
          return true;
        case "up":
          if (y4 !== 0) {
            selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x4, y4 - 1, tableObserver.table), false);
          } else {
            tableNode.selectPrevious();
          }
          return true;
        case "down":
          if (y4 !== tableObserver.table.rows - 1) {
            selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x4, y4 + 1, tableObserver.table), true);
          } else {
            tableNode.selectNext();
          }
          return true;
        default:
          return false;
      }
    };
    scrollableEditors = /* @__PURE__ */ new WeakSet();
    TableNode = class _TableNode extends ElementNode2 {
      /** @internal */
      static getType() {
        return "table";
      }
      getColWidths() {
        const self = this.getLatest();
        return self.__colWidths;
      }
      setColWidths(colWidths) {
        const self = this.getWritable();
        self.__colWidths = colWidths !== void 0 && true ? Object.freeze(colWidths) : colWidths;
        return self;
      }
      static clone(node) {
        return new _TableNode(node.__key);
      }
      afterCloneFrom(prevNode) {
        super.afterCloneFrom(prevNode);
        this.__colWidths = prevNode.__colWidths;
        this.__rowStriping = prevNode.__rowStriping;
        this.__frozenColumnCount = prevNode.__frozenColumnCount;
        this.__frozenRowCount = prevNode.__frozenRowCount;
      }
      static importDOM() {
        return {
          table: (_node) => ({
            conversion: $convertTableElement,
            priority: 1
          })
        };
      }
      static importJSON(serializedNode) {
        return $createTableNode().updateFromJSON(serializedNode);
      }
      updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);
      }
      constructor(key2) {
        super(key2);
        this.__rowStriping = false;
        this.__frozenColumnCount = 0;
        this.__frozenRowCount = 0;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          colWidths: this.getColWidths(),
          frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : void 0,
          frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : void 0,
          rowStriping: this.__rowStriping ? this.__rowStriping : void 0
        };
      }
      extractWithChild(child, selection, destination) {
        return destination === "html";
      }
      getDOMSlot(element) {
        const tableElement = !isHTMLTableElement(element) ? element.querySelector("table") : element;
        if (!isHTMLTableElement(tableElement)) {
          formatDevErrorMessage7(`TableNode.getDOMSlot: createDOM() did not return a table`);
        }
        return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector("colgroup"));
      }
      createDOM(config, editor) {
        const tableElement = document.createElement("table");
        if (this.__style) {
          tableElement.style.cssText = this.__style;
        }
        const colGroup = document.createElement("colgroup");
        tableElement.appendChild(colGroup);
        setDOMUnmanaged2(colGroup);
        addClassNamesToElement2(tableElement, config.theme.table);
        this.updateTableElement(null, tableElement, config);
        if ($isScrollableTablesActive(editor)) {
          const wrapperElement = document.createElement("div");
          const classes = config.theme.tableScrollableWrapper;
          if (classes) {
            addClassNamesToElement2(wrapperElement, classes);
          } else {
            wrapperElement.style.cssText = "overflow-x: auto;";
          }
          wrapperElement.appendChild(tableElement);
          this.updateTableWrapper(null, wrapperElement, tableElement, config);
          return wrapperElement;
        }
        return tableElement;
      }
      updateTableWrapper(prevNode, tableWrapper, tableElement, config) {
        if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {
          setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);
        }
        if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {
          setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);
        }
      }
      updateTableElement(prevNode, tableElement, config) {
        if (this.__style !== (prevNode ? prevNode.__style : "")) {
          tableElement.style.cssText = this.__style;
        }
        if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {
          setRowStriping(tableElement, config, this.__rowStriping);
        }
        updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());
        alignTableElement(tableElement, config, this.getFormatType());
      }
      updateDOM(prevNode, dom2, config) {
        const slot = this.getDOMSlot(dom2);
        const tableElement = slot.element;
        if (dom2 === tableElement === $isScrollableTablesActive()) {
          return true;
        }
        if (isHTMLDivElement(dom2)) {
          this.updateTableWrapper(prevNode, dom2, tableElement, config);
        }
        this.updateTableElement(prevNode, tableElement, config);
        return false;
      }
      exportDOM(editor) {
        const superExport = super.exportDOM(editor);
        const {
          element
        } = superExport;
        return {
          after: (tableElement) => {
            if (superExport.after) {
              tableElement = superExport.after(tableElement);
            }
            if (!isHTMLTableElement(tableElement) && isHTMLElement3(tableElement)) {
              tableElement = tableElement.querySelector("table");
            }
            if (!isHTMLTableElement(tableElement)) {
              return null;
            }
            alignTableElement(tableElement, editor._config, this.getFormatType());
            const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);
            const cellValues = /* @__PURE__ */ new Map();
            for (const mapRow of tableMap) {
              for (const mapValue of mapRow) {
                const key2 = mapValue.cell.getKey();
                if (!cellValues.has(key2)) {
                  cellValues.set(key2, {
                    colSpan: mapValue.cell.getColSpan(),
                    startColumn: mapValue.startColumn
                  });
                }
              }
            }
            const knownColumns = /* @__PURE__ */ new Set();
            for (const cellDOM of tableElement.querySelectorAll(":scope > tr > [data-temporary-table-cell-lexical-key]")) {
              const key2 = cellDOM.getAttribute("data-temporary-table-cell-lexical-key");
              if (key2) {
                const cellSpan = cellValues.get(key2);
                cellDOM.removeAttribute("data-temporary-table-cell-lexical-key");
                if (cellSpan) {
                  cellValues.delete(key2);
                  for (let i2 = 0; i2 < cellSpan.colSpan; i2++) {
                    knownColumns.add(i2 + cellSpan.startColumn);
                  }
                }
              }
            }
            const colGroup = tableElement.querySelector(":scope > colgroup");
            if (colGroup) {
              const cols = Array.from(tableElement.querySelectorAll(":scope > colgroup > col")).filter((dom2, i2) => knownColumns.has(i2));
              colGroup.replaceChildren(...cols);
            }
            const rows = tableElement.querySelectorAll(":scope > tr");
            if (rows.length > 0) {
              const tBody = document.createElement("tbody");
              for (const row of rows) {
                tBody.appendChild(row);
              }
              tableElement.append(tBody);
            }
            return tableElement;
          },
          element: !isHTMLTableElement(element) && isHTMLElement3(element) ? element.querySelector("table") : element
        };
      }
      canBeEmpty() {
        return false;
      }
      isShadowRoot() {
        return true;
      }
      getCordsFromCellNode(tableCellNode, table) {
        const {
          rows,
          domRows
        } = table;
        for (let y4 = 0; y4 < rows; y4++) {
          const row = domRows[y4];
          if (row == null) {
            continue;
          }
          for (let x4 = 0; x4 < row.length; x4++) {
            const cell = row[x4];
            if (cell == null) {
              continue;
            }
            const {
              elem
            } = cell;
            const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);
            if (cellNode !== null && tableCellNode.is(cellNode)) {
              return {
                x: x4,
                y: y4
              };
            }
          }
        }
        throw new Error("Cell not found in table.");
      }
      getDOMCellFromCords(x4, y4, table) {
        const {
          domRows
        } = table;
        const row = domRows[y4];
        if (row == null) {
          return null;
        }
        const index = x4 < row.length ? x4 : row.length - 1;
        const cell = row[index];
        if (cell == null) {
          return null;
        }
        return cell;
      }
      getDOMCellFromCordsOrThrow(x4, y4, table) {
        const cell = this.getDOMCellFromCords(x4, y4, table);
        if (!cell) {
          throw new Error("Cell not found at cords.");
        }
        return cell;
      }
      getCellNodeFromCords(x4, y4, table) {
        const cell = this.getDOMCellFromCords(x4, y4, table);
        if (cell == null) {
          return null;
        }
        const node = $getNearestNodeFromDOMNode2(cell.elem);
        if ($isTableCellNode(node)) {
          return node;
        }
        return null;
      }
      getCellNodeFromCordsOrThrow(x4, y4, table) {
        const node = this.getCellNodeFromCords(x4, y4, table);
        if (!node) {
          throw new Error("Node at cords not TableCellNode.");
        }
        return node;
      }
      getRowStriping() {
        return Boolean(this.getLatest().__rowStriping);
      }
      setRowStriping(newRowStriping) {
        const self = this.getWritable();
        self.__rowStriping = newRowStriping;
        return self;
      }
      setFrozenColumns(columnCount) {
        const self = this.getWritable();
        self.__frozenColumnCount = columnCount;
        return self;
      }
      getFrozenColumns() {
        return this.getLatest().__frozenColumnCount;
      }
      setFrozenRows(rowCount) {
        const self = this.getWritable();
        self.__frozenRowCount = rowCount;
        return self;
      }
      getFrozenRows() {
        return this.getLatest().__frozenRowCount;
      }
      canSelectBefore() {
        return true;
      }
      canIndent() {
        return false;
      }
      getColumnCount() {
        const firstRow = this.getFirstChild();
        if (!firstRow) {
          return 0;
        }
        let columnCount = 0;
        firstRow.getChildren().forEach((cell) => {
          if ($isTableCellNode(cell)) {
            columnCount += cell.getColSpan();
          }
        });
        return columnCount;
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/table@0.32.1/node_modules/@lexical/table/LexicalTable.prod.mjs
var LexicalTable_prod_exports = {};
__export(LexicalTable_prod_exports, {
  $computeTableMap: () => ut4,
  $computeTableMapSkipCellCheck: () => ht5,
  $createTableCellNode: () => ve2,
  $createTableNode: () => dn2,
  $createTableNodeWithDimensions: () => Le2,
  $createTableRowNode: () => Ke2,
  $createTableSelection: () => _t5,
  $createTableSelectionFrom: () => St4,
  $deleteTableColumn: () => Ze2,
  $deleteTableColumnAtSelection: () => nt4,
  $deleteTableColumn__EXPERIMENTAL: () => ot4,
  $deleteTableRowAtSelection: () => et4,
  $deleteTableRow__EXPERIMENTAL: () => tt4,
  $findCellNode: () => jt2,
  $findTableNode: () => Vt2,
  $getElementForTableNode: () => un2,
  $getNodeTriplet: () => dt5,
  $getTableAndElementByKey: () => bt3,
  $getTableCellNodeFromLexicalNode: () => We2,
  $getTableCellNodeRect: () => gt5,
  $getTableColumnIndexFromTableCellNode: () => Be2,
  $getTableNodeFromLexicalNodeOrThrow: () => He2,
  $getTableRowIndexFromTableCellNode: () => Pe2,
  $getTableRowNodeFromTableCellNodeOrThrow: () => ze2,
  $insertTableColumn: () => je2,
  $insertTableColumnAtSelection: () => Ve2,
  $insertTableColumn__EXPERIMENTAL: () => Ge2,
  $insertTableRow: () => Ue2,
  $insertTableRowAtSelection: () => Ye2,
  $insertTableRow__EXPERIMENTAL: () => qe2,
  $isScrollableTablesActive: () => sn2,
  $isTableCellNode: () => Re2,
  $isTableNode: () => fn2,
  $isTableRowNode: () => Ee2,
  $isTableSelection: () => Ct5,
  $mergeCells: () => st4,
  $removeTableRowAtIndex: () => Ie2,
  $unmergeCell: () => ct4,
  INSERT_TABLE_COMMAND: () => Te2,
  TableCellHeaderStates: () => be2,
  TableCellNode: () => ye2,
  TableNode: () => an2,
  TableObserver: () => yt5,
  TableRowNode: () => Oe2,
  applyTableHandlers: () => Et4,
  getDOMCellFromTarget: () => Mt4,
  getTableElement: () => Rt3,
  getTableObserverFromTableElement: () => kt3,
  registerTableCellUnmergeTransform: () => Sn2,
  registerTablePlugin: () => bn2,
  registerTableSelectionObserver: () => wn2,
  setScrollableTablesActive: () => cn2
});
function Ne2(e2) {
  return "middle" === e2 || "bottom" === e2;
}
function xe2(e2) {
  const t3 = e2, n2 = e2.nodeName.toLowerCase();
  let o2;
  we2.test(t3.style.width) && (o2 = parseFloat(t3.style.width));
  const r2 = ve2("th" === n2 ? be2.ROW : be2.NO_STATUS, t3.colSpan, o2);
  r2.__rowSpan = t3.rowSpan;
  const l2 = t3.style.backgroundColor;
  "" !== l2 && (r2.__backgroundColor = l2);
  const s2 = t3.style.verticalAlign;
  Ne2(s2) && (r2.__verticalAlign = s2);
  const i2 = t3.style, c2 = (i2 && i2.textDecoration || "").split(" "), a2 = "700" === i2.fontWeight || "bold" === i2.fontWeight, u2 = c2.includes("line-through"), h4 = "italic" === i2.fontStyle, p3 = c2.includes("underline");
  return { after: (e3) => {
    const t4 = [];
    let n3 = null;
    const o3 = () => {
      if (n3) {
        const e4 = n3.getFirstChild();
        $isLineBreakNode2(e4) && 1 === n3.getChildrenSize() && e4.remove();
      }
    };
    for (const r3 of e3) $isInlineElementOrDecoratorNode2(r3) || $isTextNode2(r3) || $isLineBreakNode2(r3) ? ($isTextNode2(r3) && (a2 && r3.toggleFormat("bold"), u2 && r3.toggleFormat("strikethrough"), h4 && r3.toggleFormat("italic"), p3 && r3.toggleFormat("underline")), n3 ? n3.append(r3) : (n3 = $createParagraphNode2().append(r3), t4.push(n3))) : (t4.push(r3), o3(), n3 = null);
    return o3(), 0 === t4.length && t4.push($createParagraphNode2()), t4;
  }, node: r2 };
}
function ve2(e2 = be2.NO_STATUS, t3 = 1, n2) {
  return $applyNodeReplacement2(new ye2(e2, t3, n2));
}
function Re2(e2) {
  return e2 instanceof ye2;
}
function Fe2(e2, ...t3) {
  const n2 = new URL("https://lexical.dev/docs/error"), o2 = new URLSearchParams();
  o2.append("code", e2);
  for (const e3 of t3) o2.append("v", e3);
  throw n2.search = o2.toString(), Error(`Minified Lexical error #${e2}; visit ${n2.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function Ae2(e2) {
  const n2 = e2;
  let o2;
  return we2.test(n2.style.height) && (o2 = parseFloat(n2.style.height)), { after: (e3) => $descendantsMatching2(e3, Re2), node: Ke2(o2) };
}
function Ke2(e2) {
  return $applyNodeReplacement2(new Oe2(e2));
}
function Ee2(e2) {
  return e2 instanceof Oe2;
}
function Le2(e2, t3, n2 = true) {
  const o2 = dn2();
  for (let r2 = 0; r2 < e2; r2++) {
    const e3 = Ke2();
    for (let o3 = 0; o3 < t3; o3++) {
      let t4 = be2.NO_STATUS;
      "object" == typeof n2 ? (0 === r2 && n2.rows && (t4 |= be2.ROW), 0 === o3 && n2.columns && (t4 |= be2.COLUMN)) : n2 && (0 === r2 && (t4 |= be2.ROW), 0 === o3 && (t4 |= be2.COLUMN));
      const l2 = ve2(t4), s2 = $createParagraphNode2();
      s2.append($createTextNode2()), l2.append(s2), e3.append(l2);
    }
    o2.append(e3);
  }
  return o2;
}
function We2(e2) {
  const t3 = $findMatchingParent3(e2, (e3) => Re2(e3));
  return Re2(t3) ? t3 : null;
}
function ze2(e2) {
  const t3 = $findMatchingParent3(e2, (e3) => Ee2(e3));
  if (Ee2(t3)) return t3;
  throw new Error("Expected table cell to be inside of table row.");
}
function He2(e2) {
  const t3 = $findMatchingParent3(e2, (e3) => fn2(e3));
  if (fn2(t3)) return t3;
  throw new Error("Expected table cell to be inside of table.");
}
function Pe2(e2) {
  const t3 = ze2(e2);
  return He2(t3).getChildren().findIndex((e3) => e3.is(t3));
}
function Be2(e2) {
  return ze2(e2).getChildren().findIndex((t3) => t3.is(e2));
}
function De2(e2, t3) {
  const n2 = He2(e2), { x: o2, y: r2 } = n2.getCordsFromCellNode(e2, t3);
  return { above: n2.getCellNodeFromCords(o2, r2 - 1, t3), below: n2.getCellNodeFromCords(o2, r2 + 1, t3), left: n2.getCellNodeFromCords(o2 - 1, r2, t3), right: n2.getCellNodeFromCords(o2 + 1, r2, t3) };
}
function Ie2(e2, t3) {
  const n2 = e2.getChildren();
  if (t3 >= n2.length || t3 < 0) throw new Error("Expected table cell to be inside of table row.");
  return n2[t3].remove(), e2;
}
function Ue2(e2, t3, n2 = true, o2, r2) {
  const l2 = e2.getChildren();
  if (t3 >= l2.length || t3 < 0) throw new Error("Table row target index out of range");
  const s2 = l2[t3];
  if (!Ee2(s2)) throw new Error("Row before insertion index does not exist.");
  for (let e3 = 0; e3 < o2; e3++) {
    const e4 = s2.getChildren(), t4 = e4.length, o3 = Ke2();
    for (let n3 = 0; n3 < t4; n3++) {
      const t5 = e4[n3];
      Re2(t5) || Fe2(12);
      const { above: l3, below: s3 } = De2(t5, r2);
      let i2 = be2.NO_STATUS;
      const c2 = l3 && l3.getWidth() || s3 && s3.getWidth() || void 0;
      (l3 && l3.hasHeaderState(be2.COLUMN) || s3 && s3.hasHeaderState(be2.COLUMN)) && (i2 |= be2.COLUMN);
      const a2 = ve2(i2, 1, c2);
      a2.append($createParagraphNode2()), o3.append(a2);
    }
    n2 ? s2.insertAfter(o3) : s2.insertBefore(o3);
  }
  return e2;
}
function Ye2(e2 = true) {
  const t3 = $getSelection2();
  $isRangeSelection2(t3) || Ct5(t3) || Fe2(188);
  const n2 = t3.anchor.getNode(), o2 = t3.focus.getNode(), [r2] = dt5(n2), [l2, , s2] = dt5(o2), [, i2, c2] = ut4(s2, l2, r2), { startRow: a2 } = c2, { startRow: u2 } = i2;
  return e2 ? Xe2(a2 + r2.__rowSpan > u2 + l2.__rowSpan ? r2 : l2, true) : Xe2(u2 < a2 ? l2 : r2, false);
}
function Xe2(e2, t3 = true) {
  const [, , n2] = dt5(e2), [o2, r2] = ut4(n2, e2, e2), l2 = o2[0].length, { startRow: s2 } = r2;
  let i2 = null;
  if (t3) {
    const t4 = s2 + e2.__rowSpan - 1, r3 = o2[t4], c2 = Ke2();
    for (let e3 = 0; e3 < l2; e3++) {
      const { cell: n3, startRow: o3 } = r3[e3];
      if (o3 + n3.__rowSpan - 1 <= t4) {
        const t5 = r3[e3].cell.__headerState, n4 = Je2(t5, be2.COLUMN);
        c2.append(ve2(n4).append($createParagraphNode2()));
      } else n3.setRowSpan(n3.__rowSpan + 1);
    }
    const a2 = n2.getChildAtIndex(t4);
    Ee2(a2) || Fe2(256), a2.insertAfter(c2), i2 = c2;
  } else {
    const e3 = s2, t4 = o2[e3], r3 = Ke2();
    for (let n3 = 0; n3 < l2; n3++) {
      const { cell: o3, startRow: l3 } = t4[n3];
      if (l3 === e3) {
        const e4 = t4[n3].cell.__headerState, o4 = Je2(e4, be2.COLUMN);
        r3.append(ve2(o4).append($createParagraphNode2()));
      } else o3.setRowSpan(o3.__rowSpan + 1);
    }
    const c2 = n2.getChildAtIndex(e3);
    Ee2(c2) || Fe2(257), c2.insertBefore(r3), i2 = r3;
  }
  return i2;
}
function je2(e2, t3, n2 = true, o2, r2) {
  const l2 = e2.getChildren(), s2 = [];
  for (let e3 = 0; e3 < l2.length; e3++) {
    const n3 = l2[e3];
    if (Ee2(n3)) for (let e4 = 0; e4 < o2; e4++) {
      const e5 = n3.getChildren();
      if (t3 >= e5.length || t3 < 0) throw new Error("Table column target index out of range");
      const o3 = e5[t3];
      Re2(o3) || Fe2(12);
      const { left: l3, right: i2 } = De2(o3, r2);
      let c2 = be2.NO_STATUS;
      (l3 && l3.hasHeaderState(be2.ROW) || i2 && i2.hasHeaderState(be2.ROW)) && (c2 |= be2.ROW);
      const a2 = ve2(c2);
      a2.append($createParagraphNode2()), s2.push({ newTableCell: a2, targetCell: o3 });
    }
  }
  return s2.forEach(({ newTableCell: e3, targetCell: t4 }) => {
    n2 ? t4.insertAfter(e3) : t4.insertBefore(e3);
  }), e2;
}
function Ve2(e2 = true) {
  const t3 = $getSelection2();
  $isRangeSelection2(t3) || Ct5(t3) || Fe2(188);
  const n2 = t3.anchor.getNode(), o2 = t3.focus.getNode(), [r2] = dt5(n2), [l2, , s2] = dt5(o2), [, i2, c2] = ut4(s2, l2, r2), { startColumn: a2 } = c2, { startColumn: u2 } = i2;
  return e2 ? Qe2(a2 + r2.__colSpan > u2 + l2.__colSpan ? r2 : l2, true) : Qe2(u2 < a2 ? l2 : r2, false);
}
function Qe2(e2, t3 = true, n2 = true) {
  const [, , o2] = dt5(e2), [r2, l2] = ut4(o2, e2, e2), s2 = r2.length, { startColumn: i2 } = l2, c2 = t3 ? i2 + e2.__colSpan - 1 : i2 - 1, a2 = o2.getFirstChild();
  Ee2(a2) || Fe2(120);
  let u2 = null;
  function h4(e3 = be2.NO_STATUS) {
    const t4 = ve2(e3).append($createParagraphNode2());
    return null === u2 && (u2 = t4), t4;
  }
  let d3 = a2;
  e: for (let e3 = 0; e3 < s2; e3++) {
    if (0 !== e3) {
      const e4 = d3.getNextSibling();
      Ee2(e4) || Fe2(121), d3 = e4;
    }
    const t4 = r2[e3], n3 = t4[c2 < 0 ? 0 : c2].cell.__headerState, o3 = Je2(n3, be2.ROW);
    if (c2 < 0) {
      lt4(d3, h4(o3));
      continue;
    }
    const { cell: l3, startColumn: s3, startRow: i3 } = t4[c2];
    if (s3 + l3.__colSpan - 1 <= c2) {
      let n4 = l3, r3 = i3, s4 = c2;
      for (; r3 !== e3 && n4.__rowSpan > 1; ) {
        if (s4 -= l3.__colSpan, !(s4 >= 0)) {
          d3.append(h4(o3));
          continue e;
        }
        {
          const { cell: e4, startRow: o4 } = t4[s4];
          n4 = e4, r3 = o4;
        }
      }
      n4.insertAfter(h4(o3));
    } else l3.setColSpan(l3.__colSpan + 1);
  }
  null !== u2 && n2 && rt4(u2);
  const f3 = o2.getColWidths();
  if (f3) {
    const e3 = [...f3], t4 = c2 < 0 ? 0 : c2, n3 = e3[t4];
    e3.splice(t4, 0, n3), o2.setColWidths(e3);
  }
  return u2;
}
function Ze2(e2, t3) {
  const n2 = e2.getChildren();
  for (let e3 = 0; e3 < n2.length; e3++) {
    const o2 = n2[e3];
    if (Ee2(o2)) {
      const e4 = o2.getChildren();
      if (t3 >= e4.length || t3 < 0) throw new Error("Table column target index out of range");
      e4[t3].remove();
    }
  }
  return e2;
}
function et4() {
  const e2 = $getSelection2();
  $isRangeSelection2(e2) || Ct5(e2) || Fe2(188);
  const [t3, n2] = e2.isBackward() ? [e2.focus.getNode(), e2.anchor.getNode()] : [e2.anchor.getNode(), e2.focus.getNode()], [o2, , r2] = dt5(t3), [l2] = dt5(n2), [s2, i2, c2] = ut4(r2, o2, l2), { startRow: a2 } = i2, { startRow: u2 } = c2, h4 = u2 + l2.__rowSpan - 1;
  if (s2.length === h4 - a2 + 1) return void r2.remove();
  const d3 = s2[0].length, f3 = s2[h4 + 1], g4 = r2.getChildAtIndex(h4 + 1);
  for (let e3 = h4; e3 >= a2; e3--) {
    for (let t5 = d3 - 1; t5 >= 0; t5--) {
      const { cell: n3, startRow: o3, startColumn: r3 } = s2[e3][t5];
      if (r3 === t5) {
        if (o3 < a2 || o3 + n3.__rowSpan - 1 > h4) {
          const e4 = Math.max(o3, a2), t6 = Math.min(n3.__rowSpan + o3 - 1, h4), r4 = e4 <= t6 ? t6 - e4 + 1 : 0;
          n3.setRowSpan(n3.__rowSpan - r4);
        }
        if (o3 >= a2 && o3 + n3.__rowSpan - 1 > h4 && e3 === h4) {
          null === g4 && Fe2(122);
          let o4 = null;
          for (let n4 = 0; n4 < t5; n4++) {
            const t6 = f3[n4], r4 = t6.cell;
            t6.startRow === e3 + 1 && (o4 = r4), r4.__colSpan > 1 && (n4 += r4.__colSpan - 1);
          }
          null === o4 ? lt4(g4, n3) : o4.insertAfter(n3);
        }
      }
    }
    const t4 = r2.getChildAtIndex(e3);
    Ee2(t4) || Fe2(206, String(e3)), t4.remove();
  }
  if (void 0 !== f3) {
    const { cell: e3 } = f3[0];
    rt4(e3);
  } else {
    const e3 = s2[a2 - 1], { cell: t4 } = e3[0];
    rt4(t4);
  }
}
function nt4() {
  const e2 = $getSelection2();
  $isRangeSelection2(e2) || Ct5(e2) || Fe2(188);
  const t3 = e2.anchor.getNode(), n2 = e2.focus.getNode(), [o2, , r2] = dt5(t3), [l2] = dt5(n2), [s2, i2, c2] = ut4(r2, o2, l2), { startColumn: a2 } = i2, { startRow: u2, startColumn: h4 } = c2, d3 = Math.min(a2, h4), f3 = Math.max(a2 + o2.__colSpan - 1, h4 + l2.__colSpan - 1), g4 = f3 - d3 + 1;
  if (s2[0].length === f3 - d3 + 1) return r2.selectPrevious(), void r2.remove();
  const m4 = s2.length;
  for (let e3 = 0; e3 < m4; e3++) for (let t4 = d3; t4 <= f3; t4++) {
    const { cell: n3, startColumn: o3 } = s2[e3][t4];
    if (o3 < d3) {
      if (t4 === d3) {
        const e4 = d3 - o3;
        n3.setColSpan(n3.__colSpan - Math.min(g4, n3.__colSpan - e4));
      }
    } else if (o3 + n3.__colSpan - 1 > f3) {
      if (t4 === f3) {
        const e4 = f3 - o3 + 1;
        n3.setColSpan(n3.__colSpan - e4);
      }
    } else n3.remove();
  }
  const p3 = s2[u2], C4 = a2 > h4 ? p3[a2 + o2.__colSpan] : p3[h4 + l2.__colSpan];
  if (void 0 !== C4) {
    const { cell: e3 } = C4;
    rt4(e3);
  } else {
    const e3 = h4 < a2 ? p3[h4 - 1] : p3[a2 - 1], { cell: t4 } = e3;
    rt4(t4);
  }
  const _5 = r2.getColWidths();
  if (_5) {
    const e3 = [..._5];
    e3.splice(d3, g4), r2.setColWidths(e3);
  }
}
function rt4(e2) {
  const t3 = e2.getFirstDescendant();
  null == t3 ? e2.selectStart() : t3.getParentOrThrow().selectStart();
}
function lt4(e2, t3) {
  const n2 = e2.getFirstChild();
  null !== n2 ? n2.insertBefore(t3) : e2.append(t3);
}
function st4(e2) {
  if (0 === e2.length) return null;
  const t3 = He2(e2[0]), [n2] = ht5(t3, null, null);
  let o2 = 1 / 0, r2 = -1 / 0, l2 = 1 / 0, s2 = -1 / 0;
  const i2 = /* @__PURE__ */ new Set();
  for (const t4 of n2) for (const n3 of t4) {
    if (!n3 || !n3.cell) continue;
    const t5 = n3.cell.getKey();
    if (!i2.has(t5) && e2.some((e3) => e3.is(n3.cell))) {
      i2.add(t5);
      const e3 = n3.startRow, c3 = n3.startColumn, a3 = n3.cell.__rowSpan || 1, u3 = n3.cell.__colSpan || 1;
      o2 = Math.min(o2, e3), r2 = Math.max(r2, e3 + a3 - 1), l2 = Math.min(l2, c3), s2 = Math.max(s2, c3 + u3 - 1);
    }
  }
  if (o2 === 1 / 0 || l2 === 1 / 0) return null;
  const c2 = r2 - o2 + 1, a2 = s2 - l2 + 1, u2 = n2[o2][l2];
  if (!u2.cell) return null;
  const h4 = u2.cell;
  h4.setColSpan(a2), h4.setRowSpan(c2);
  const d3 = /* @__PURE__ */ new Set([h4.getKey()]);
  for (let e3 = o2; e3 <= r2; e3++) for (let t4 = l2; t4 <= s2; t4++) {
    const o3 = n2[e3][t4];
    if (!o3.cell) continue;
    const r3 = o3.cell, l3 = r3.getKey();
    if (!d3.has(l3)) {
      d3.add(l3);
      it4(r3) || h4.append(...r3.getChildren()), r3.remove();
    }
  }
  return 0 === h4.getChildrenSize() && h4.append($createParagraphNode2()), h4;
}
function it4(e2) {
  if (1 !== e2.getChildrenSize()) return false;
  const t3 = e2.getFirstChildOrThrow();
  return !(!$isParagraphNode2(t3) || !t3.isEmpty());
}
function ct4() {
  const e2 = $getSelection2();
  $isRangeSelection2(e2) || Ct5(e2) || Fe2(188);
  const t3 = e2.anchor.getNode(), o2 = $findMatchingParent3(t3, Re2);
  return Re2(o2) || Fe2(148), at4(o2);
}
function at4(e2) {
  const [t3, n2, o2] = dt5(e2), r2 = t3.__colSpan, l2 = t3.__rowSpan;
  if (1 === r2 && 1 === l2) return;
  const [s2, i2] = ut4(o2, t3, t3), { startColumn: c2, startRow: a2 } = i2, u2 = t3.__headerState & be2.COLUMN, h4 = Array.from({ length: r2 }, (e3, t4) => {
    let n3 = u2;
    for (let e4 = 0; 0 !== n3 && e4 < s2.length; e4++) n3 &= s2[e4][t4 + c2].cell.__headerState;
    return n3;
  }), d3 = t3.__headerState & be2.ROW, f3 = Array.from({ length: l2 }, (e3, t4) => {
    let n3 = d3;
    for (let e4 = 0; 0 !== n3 && e4 < s2[0].length; e4++) n3 &= s2[t4 + a2][e4].cell.__headerState;
    return n3;
  });
  if (r2 > 1) {
    for (let e3 = 1; e3 < r2; e3++) t3.insertAfter(ve2(h4[e3] | f3[0]).append($createParagraphNode2()));
    t3.setColSpan(1);
  }
  if (l2 > 1) {
    let e3;
    for (let t4 = 1; t4 < l2; t4++) {
      const o3 = a2 + t4, l3 = s2[o3];
      e3 = (e3 || n2).getNextSibling(), Ee2(e3) || Fe2(125);
      let i3 = null;
      for (let e4 = 0; e4 < c2; e4++) {
        const t5 = l3[e4], n3 = t5.cell;
        t5.startRow === o3 && (i3 = n3), n3.__colSpan > 1 && (e4 += n3.__colSpan - 1);
      }
      if (null === i3) for (let n3 = r2 - 1; n3 >= 0; n3--) lt4(e3, ve2(h4[n3] | f3[t4]).append($createParagraphNode2()));
      else for (let e4 = r2 - 1; e4 >= 0; e4--) i3.insertAfter(ve2(h4[e4] | f3[t4]).append($createParagraphNode2()));
    }
    t3.setRowSpan(1);
  }
}
function ut4(e2, t3, n2) {
  const [o2, r2, l2] = ht5(e2, t3, n2);
  return null === r2 && Fe2(207), null === l2 && Fe2(208), [o2, r2, l2];
}
function ht5(e2, t3, n2) {
  const o2 = [];
  let r2 = null, l2 = null;
  function s2(e3) {
    let t4 = o2[e3];
    return void 0 === t4 && (o2[e3] = t4 = []), t4;
  }
  const i2 = e2.getChildren();
  for (let e3 = 0; e3 < i2.length; e3++) {
    const o3 = i2[e3];
    Ee2(o3) || Fe2(209);
    const c2 = s2(e3);
    for (let a2 = o3.getFirstChild(), u2 = 0; null != a2; a2 = a2.getNextSibling()) {
      for (Re2(a2) || Fe2(147); void 0 !== c2[u2]; ) u2++;
      const o4 = { cell: a2, startColumn: u2, startRow: e3 }, { __rowSpan: h4, __colSpan: d3 } = a2;
      for (let t4 = 0; t4 < h4 && !(e3 + t4 >= i2.length); t4++) {
        const n3 = s2(e3 + t4);
        for (let e4 = 0; e4 < d3; e4++) n3[u2 + e4] = o4;
      }
      null !== t3 && null === r2 && t3.is(a2) && (r2 = o4), null !== n2 && null === l2 && n2.is(a2) && (l2 = o4);
    }
  }
  return [o2, r2, l2];
}
function dt5(e2) {
  let t3;
  if (e2 instanceof ye2) t3 = e2;
  else if ("__type" in e2) {
    const o3 = $findMatchingParent3(e2, Re2);
    Re2(o3) || Fe2(148), t3 = o3;
  } else {
    const o3 = $findMatchingParent3(e2.getNode(), Re2);
    Re2(o3) || Fe2(148), t3 = o3;
  }
  const o2 = t3.getParent();
  Ee2(o2) || Fe2(149);
  const r2 = o2.getParent();
  return fn2(r2) || Fe2(210), [t3, o2, r2];
}
function ft5(e2, t3, n2) {
  let o2, r2 = Math.min(t3.startColumn, n2.startColumn), l2 = Math.min(t3.startRow, n2.startRow), s2 = Math.max(t3.startColumn + t3.cell.__colSpan - 1, n2.startColumn + n2.cell.__colSpan - 1), i2 = Math.max(t3.startRow + t3.cell.__rowSpan - 1, n2.startRow + n2.cell.__rowSpan - 1);
  do {
    o2 = false;
    for (let t4 = 0; t4 < e2.length; t4++) for (let n3 = 0; n3 < e2[0].length; n3++) {
      const c2 = e2[t4][n3];
      if (!c2) continue;
      const a2 = c2.startColumn + c2.cell.__colSpan - 1, u2 = c2.startRow + c2.cell.__rowSpan - 1, h4 = c2.startColumn <= s2 && a2 >= r2, d3 = c2.startRow <= i2 && u2 >= l2;
      if (h4 && d3) {
        const e3 = Math.min(r2, c2.startColumn), t5 = Math.max(s2, a2), n4 = Math.min(l2, c2.startRow), h5 = Math.max(i2, u2);
        e3 === r2 && t5 === s2 && n4 === l2 && h5 === i2 || (r2 = e3, s2 = t5, l2 = n4, i2 = h5, o2 = true);
      }
    }
  } while (o2);
  return { maxColumn: s2, maxRow: i2, minColumn: r2, minRow: l2 };
}
function gt5(e2) {
  const [t3, , n2] = dt5(e2), o2 = n2.getChildren(), r2 = o2.length, l2 = o2[0].getChildren().length, s2 = new Array(r2);
  for (let e3 = 0; e3 < r2; e3++) s2[e3] = new Array(l2);
  for (let e3 = 0; e3 < r2; e3++) {
    const n3 = o2[e3].getChildren();
    let r3 = 0;
    for (let o3 = 0; o3 < n3.length; o3++) {
      for (; s2[e3][r3]; ) r3++;
      const l3 = n3[o3], i2 = l3.__rowSpan || 1, c2 = l3.__colSpan || 1;
      for (let t4 = 0; t4 < i2; t4++) for (let n4 = 0; n4 < c2; n4++) s2[e3 + t4][r3 + n4] = l3;
      if (t3 === l3) return { colSpan: c2, columnIndex: r3, rowIndex: e3, rowSpan: i2 };
      r3 += c2;
    }
  }
  return null;
}
function mt5(e2) {
  const [[t3, o2, r2, l2], [s2, i2, c2, a2]] = ["anchor", "focus"].map((t4) => {
    const o3 = e2[t4].getNode(), r3 = $findMatchingParent3(o3, Re2);
    Re2(r3) || Fe2(238, t4, o3.getKey(), o3.getType());
    const l3 = r3.getParent();
    Ee2(l3) || Fe2(239, t4);
    const s3 = l3.getParent();
    return fn2(s3) || Fe2(240, t4), [o3, r3, l3, s3];
  });
  return l2.is(a2) || Fe2(241), { anchorCell: o2, anchorNode: t3, anchorRow: r2, anchorTable: l2, focusCell: i2, focusNode: s2, focusRow: c2, focusTable: a2 };
}
function Ct5(e2) {
  return e2 instanceof pt5;
}
function _t5() {
  const e2 = $createPoint2("root", 0, "element"), t3 = $createPoint2("root", 0, "element");
  return new pt5("root", e2, t3);
}
function St4(e2, t3, n2) {
  e2.getKey(), t3.getKey(), n2.getKey();
  const o2 = $getSelection2(), r2 = Ct5(o2) ? o2.clone() : _t5();
  return r2.set(e2.getKey(), t3.getKey(), n2.getKey()), r2;
}
function wt4(e2, t3) {
  const n2 = [[e2]];
  for (let e3 = n2.at(-1); void 0 !== e3 && n2.length > 0; e3 = n2.at(-1)) {
    const o2 = e3.pop();
    void 0 === o2 ? n2.pop() : false !== t3(o2) && $isElementNode2(o2) && n2.push(o2.getChildren());
  }
}
function bt3(e2, t3 = $getEditor2()) {
  const n2 = $getNodeByKey2(e2);
  fn2(n2) || Fe2(231, e2);
  const o2 = Rt3(n2, t3.getElementByKey(e2));
  return null === o2 && Fe2(232, e2), { tableElement: o2, tableNode: n2 };
}
function vt4(e2) {
  return isHTMLElement2(e2) && "TABLE" === e2.nodeName;
}
function Rt3(e2, t3) {
  if (!t3) return t3;
  const n2 = vt4(t3) ? t3 : e2.getDOMSlot(t3).element;
  return "TABLE" !== n2.nodeName && Fe2(245, t3.nodeName), n2;
}
function Tt5(e2) {
  return e2._window;
}
function Ft3(e2, t3) {
  for (let n2 = t3, o2 = null; null !== n2; n2 = n2.getParent()) {
    if (e2.is(n2)) return o2;
    Re2(n2) && (o2 = n2);
  }
  return null;
}
function Et4(e2, t3, o2, l2) {
  const s2 = o2.getRootElement(), i2 = Tt5(o2);
  null !== s2 && null !== i2 || Fe2(246);
  const c2 = new yt5(o2, e2.getKey()), a2 = Rt3(e2, t3);
  !function(e3, t4) {
    null !== kt3(e3) && Fe2(205);
    e3[Nt4] = t4;
  }(a2, c2), c2.listenersToRemove.add(() => function(e3, t4) {
    kt3(e3) === t4 && delete e3[Nt4];
  }(a2, c2));
  const u2 = (t4) => {
    if (c2.pointerType = t4.pointerType, 0 !== t4.button || !isDOMNode2(t4.target) || !i2) return;
    const n2 = Mt4(t4.target);
    null !== n2 && o2.update(() => {
      const o3 = $getPreviousSelection2();
      if ($e2 && t4.shiftKey && Jt2(o3, e2) && ($isRangeSelection2(o3) || Ct5(o3))) {
        const r2 = o3.anchor.getNode(), l3 = Ft3(e2, o3.anchor.getNode());
        if (l3) c2.$setAnchorCellForSelection(nn2(c2, l3)), c2.$setFocusCellForSelection(n2), Zt2(t4);
        else {
          (e2.isBefore(r2) ? e2.selectStart() : e2.selectEnd()).anchor.set(o3.anchor.key, o3.anchor.offset, o3.anchor.type);
        }
      } else c2.$setAnchorCellForSelection(n2);
    }), (() => {
      if (c2.isSelecting) return;
      const e3 = () => {
        c2.isSelecting = false, i2.removeEventListener("pointerup", e3), i2.removeEventListener("pointermove", t5);
      }, t5 = (n3) => {
        if (!xt4(n3) && c2.isSelecting) return c2.isSelecting = false, i2.removeEventListener("pointerup", e3), void i2.removeEventListener("pointermove", t5);
        if (!isDOMNode2(n3.target)) return;
        let r2 = null;
        const l3 = !($e2 || a2.contains(n3.target));
        if (l3) r2 = $t3(a2, n3.target);
        else for (const e4 of document.elementsFromPoint(n3.clientX, n3.clientY)) if (r2 = $t3(a2, e4), r2) break;
        !r2 || null !== c2.focusCell && r2.elem === c2.focusCell.elem || (c2.setNextFocus({ focusCell: r2, override: l3 }), o2.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0));
      };
      c2.isSelecting = true, i2.addEventListener("pointerup", e3, c2.listenerOptions), i2.addEventListener("pointermove", t5, c2.listenerOptions);
    })();
  };
  a2.addEventListener("pointerdown", u2, c2.listenerOptions), c2.listenersToRemove.add(() => {
    a2.removeEventListener("pointerdown", u2);
  });
  const h4 = (e3) => {
    if (e3.detail >= 3 && isDOMNode2(e3.target)) {
      null !== Mt4(e3.target) && e3.preventDefault();
    }
  };
  a2.addEventListener("mousedown", h4, c2.listenerOptions), c2.listenersToRemove.add(() => {
    a2.removeEventListener("mousedown", h4);
  });
  const d3 = (e3) => {
    const t4 = e3.target;
    0 === e3.button && isDOMNode2(t4) && o2.update(() => {
      const e4 = $getSelection2();
      Ct5(e4) && e4.tableKey === c2.tableNodeKey && s2.contains(t4) && c2.$clearHighlight();
    });
  };
  i2.addEventListener("pointerdown", d3, c2.listenerOptions), c2.listenersToRemove.add(() => {
    i2.removeEventListener("pointerdown", d3);
  });
  for (const [t4, n2] of Ot4) c2.listenersToRemove.add(o2.registerCommand(t4, (t5) => Qt2(o2, t5, n2, e2, c2), COMMAND_PRIORITY_HIGH2));
  c2.listenersToRemove.add(o2.registerCommand(KEY_ESCAPE_COMMAND2, (t4) => {
    const n2 = $getSelection2();
    if (Ct5(n2)) {
      const o3 = Ft3(e2, n2.focus.getNode());
      if (null !== o3) return Zt2(t4), o3.selectEnd(), true;
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  const g4 = (t4) => () => {
    const o3 = $getSelection2();
    if (!Jt2(o3, e2)) return false;
    if (Ct5(o3)) return c2.$clearText(), true;
    if ($isRangeSelection2(o3)) {
      if (!Re2(Ft3(e2, o3.anchor.getNode()))) return false;
      const r2 = o3.anchor.getNode(), l3 = o3.focus.getNode(), s3 = e2.isParentOf(r2), i3 = e2.isParentOf(l3);
      if (s3 && !i3 || i3 && !s3) return c2.$clearText(), true;
      const a3 = $findMatchingParent3(o3.anchor.getNode(), (e3) => $isElementNode2(e3)), u3 = a3 && $findMatchingParent3(a3, (e3) => $isElementNode2(e3) && Re2(e3.getParent()));
      if (!$isElementNode2(u3) || !$isElementNode2(a3)) return false;
      if (t4 === DELETE_LINE_COMMAND2 && null === u3.getPreviousSibling()) return true;
    }
    return false;
  };
  for (const e3 of At4) c2.listenersToRemove.add(o2.registerCommand(e3, g4(e3), COMMAND_PRIORITY_CRITICAL2));
  const p3 = (t4) => {
    const n2 = $getSelection2();
    if (!Ct5(n2) && !$isRangeSelection2(n2)) return false;
    const o3 = e2.isParentOf(n2.anchor.getNode());
    if (o3 !== e2.isParentOf(n2.focus.getNode())) {
      const t5 = o3 ? "anchor" : "focus", r2 = o3 ? "focus" : "anchor", { key: l3, offset: s3, type: i3 } = n2[r2];
      return e2[n2[t5].isBefore(n2[r2]) ? "selectPrevious" : "selectNext"]()[r2].set(l3, s3, i3), false;
    }
    return !!Jt2(n2, e2) && (!!Ct5(n2) && (t4 && (t4.preventDefault(), t4.stopPropagation()), c2.$clearText(), true));
  };
  for (const e3 of Kt3) c2.listenersToRemove.add(o2.registerCommand(e3, p3, COMMAND_PRIORITY_CRITICAL2));
  return c2.listenersToRemove.add(o2.registerCommand(CUT_COMMAND2, (e3) => {
    const t4 = $getSelection2();
    if (t4) {
      if (!Ct5(t4) && !$isRangeSelection2(t4)) return false;
      copyToClipboard2(o2, objectKlassEquals2(e3, ClipboardEvent) ? e3 : null, $getClipboardDataFromSelection2(t4));
      const n2 = p3(e3);
      return $isRangeSelection2(t4) ? (t4.removeText(), true) : n2;
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2)), c2.listenersToRemove.add(o2.registerCommand(FORMAT_TEXT_COMMAND2, (t4) => {
    const o3 = $getSelection2();
    if (!Jt2(o3, e2)) return false;
    if (Ct5(o3)) return c2.$formatCells(t4), true;
    if ($isRangeSelection2(o3)) {
      const e3 = $findMatchingParent3(o3.anchor.getNode(), (e4) => Re2(e4));
      if (!Re2(e3)) return false;
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2)), c2.listenersToRemove.add(o2.registerCommand(FORMAT_ELEMENT_COMMAND2, (t4) => {
    const n2 = $getSelection2();
    if (!Ct5(n2) || !Jt2(n2, e2)) return false;
    const o3 = n2.anchor.getNode(), r2 = n2.focus.getNode();
    if (!Re2(o3) || !Re2(r2)) return false;
    if (function(e3, t5) {
      if (Ct5(e3)) {
        const n3 = e3.anchor.getNode(), o4 = e3.focus.getNode();
        if (t5 && n3 && o4) {
          const [e4] = ut4(t5, n3, o4);
          return n3.getKey() === e4[0][0].cell.getKey() && o4.getKey() === e4[e4.length - 1].at(-1).cell.getKey();
        }
      }
      return false;
    }(n2, e2)) return e2.setFormat(t4), true;
    const [l3, s3, i3] = ut4(e2, o3, r2), c3 = Math.max(s3.startRow + s3.cell.__rowSpan - 1, i3.startRow + i3.cell.__rowSpan - 1), a3 = Math.max(s3.startColumn + s3.cell.__colSpan - 1, i3.startColumn + i3.cell.__colSpan - 1), u3 = Math.min(s3.startRow, i3.startRow), h5 = Math.min(s3.startColumn, i3.startColumn), d4 = /* @__PURE__ */ new Set();
    for (let e3 = u3; e3 <= c3; e3++) for (let n3 = h5; n3 <= a3; n3++) {
      const o4 = l3[e3][n3].cell;
      if (d4.has(o4)) continue;
      d4.add(o4), o4.setFormat(t4);
      const r3 = o4.getChildren();
      for (let e4 = 0; e4 < r3.length; e4++) {
        const n4 = r3[e4];
        $isElementNode2(n4) && !n4.isInline() && n4.setFormat(t4);
      }
    }
    return true;
  }, COMMAND_PRIORITY_CRITICAL2)), c2.listenersToRemove.add(o2.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (t4) => {
    const r2 = $getSelection2();
    if (!Jt2(r2, e2)) return false;
    if (Ct5(r2)) return c2.$clearHighlight(), false;
    if ($isRangeSelection2(r2)) {
      const l3 = $findMatchingParent3(r2.anchor.getNode(), (e3) => Re2(e3));
      if (!Re2(l3)) return false;
      if ("string" == typeof t4) {
        const n2 = tn2(o2, r2, e2);
        if (n2) return en2(n2, e2, [$createTextNode2(t4)]), true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_CRITICAL2)), l2 && c2.listenersToRemove.add(o2.registerCommand(KEY_TAB_COMMAND2, (t4) => {
    const o3 = $getSelection2();
    if (!$isRangeSelection2(o3) || !o3.isCollapsed() || !Jt2(o3, e2)) return false;
    const r2 = jt2(o3.anchor.getNode());
    return !(null === r2 || !e2.is(Vt2(r2))) && (Zt2(t4), function(e3, t5) {
      const o4 = "next" === t5 ? "getNextSibling" : "getPreviousSibling", r3 = "next" === t5 ? "getFirstChild" : "getLastChild", l3 = e3[o4]();
      if ($isElementNode2(l3)) return l3.selectEnd();
      const s3 = $findMatchingParent3(e3, Ee2);
      null === s3 && Fe2(247);
      for (let e4 = s3[o4](); Ee2(e4); e4 = e4[o4]()) {
        const t6 = e4[r3]();
        if ($isElementNode2(t6)) return t6.selectEnd();
      }
      const i3 = $findMatchingParent3(s3, fn2);
      null === i3 && Fe2(248);
      "next" === t5 ? i3.selectNext() : i3.selectPrevious();
    }(r2, t4.shiftKey ? "previous" : "next"), true);
  }, COMMAND_PRIORITY_CRITICAL2)), c2.listenersToRemove.add(o2.registerCommand(FOCUS_COMMAND2, (t4) => e2.isSelected(), COMMAND_PRIORITY_HIGH2)), c2.listenersToRemove.add(o2.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, (e3) => {
    const { nodes: t4, selection: o3 } = e3, r2 = o3.getStartEndPoints(), l3 = Ct5(o3), s3 = $isRangeSelection2(o3) && null !== $findMatchingParent3(o3.anchor.getNode(), (e4) => Re2(e4)) && null !== $findMatchingParent3(o3.focus.getNode(), (e4) => Re2(e4)) || l3;
    if (1 !== t4.length || !fn2(t4[0]) || !s3 || null === r2) return false;
    const [i3, c3] = r2, [a3, u3, h5] = dt5(i3), d4 = $findMatchingParent3(c3.getNode(), (e4) => Re2(e4));
    if (!(Re2(a3) && Re2(d4) && Ee2(u3) && fn2(h5))) return false;
    const g5 = t4[0], [p4, C4, _5] = ut4(h5, a3, d4), [S4] = ht5(g5, null, null), b3 = p4.length, y4 = b3 > 0 ? p4[0].length : 0;
    let N5 = C4.startRow, x4 = C4.startColumn, v4 = S4.length, R6 = v4 > 0 ? S4[0].length : 0;
    if (l3) {
      const e4 = ft5(p4, C4, _5), t5 = e4.maxRow - e4.minRow + 1, n2 = e4.maxColumn - e4.minColumn + 1;
      N5 = e4.minRow, x4 = e4.minColumn, v4 = Math.min(v4, t5), R6 = Math.min(R6, n2);
    }
    let T5 = false;
    const F4 = Math.min(b3, N5 + v4) - 1, O6 = Math.min(y4, x4 + R6) - 1, A4 = /* @__PURE__ */ new Set();
    for (let e4 = N5; e4 <= F4; e4++) for (let t5 = x4; t5 <= O6; t5++) {
      const n2 = p4[e4][t5];
      A4.has(n2.cell.getKey()) || (1 === n2.cell.__rowSpan && 1 === n2.cell.__colSpan || (at4(n2.cell), A4.add(n2.cell.getKey()), T5 = true));
    }
    let [K5] = ht5(h5.getWritable(), null, null);
    const E4 = v4 - b3 + N5;
    for (let e4 = 0; e4 < E4; e4++) {
      Xe2(K5[b3 - 1][0].cell);
    }
    const k5 = R6 - y4 + x4;
    for (let e4 = 0; e4 < k5; e4++) {
      Qe2(K5[0][y4 - 1].cell, true, false);
    }
    [K5] = ht5(h5.getWritable(), null, null);
    for (let e4 = N5; e4 < N5 + v4; e4++) for (let t5 = x4; t5 < x4 + R6; t5++) {
      const n2 = e4 - N5, o4 = t5 - x4, r3 = S4[n2][o4];
      if (r3.startRow !== n2 || r3.startColumn !== o4) continue;
      const l4 = r3.cell;
      if (1 !== l4.__rowSpan || 1 !== l4.__colSpan) {
        const n3 = [], o5 = Math.min(e4 + l4.__rowSpan, N5 + v4) - 1, r4 = Math.min(t5 + l4.__colSpan, x4 + R6) - 1;
        for (let l5 = e4; l5 <= o5; l5++) for (let e5 = t5; e5 <= r4; e5++) {
          const t6 = K5[l5][e5];
          n3.push(t6.cell);
        }
        st4(n3), T5 = true;
      }
      const { cell: s4 } = K5[e4][t5], i4 = s4.getChildren();
      l4.getChildren().forEach((e5) => {
        if ($isTextNode2(e5)) {
          $createParagraphNode2().append(e5), s4.append(e5);
        } else s4.append(e5);
      }), i4.forEach((e5) => e5.remove());
    }
    if (l3 && T5) {
      const [e4] = ht5(h5.getWritable(), null, null);
      e4[C4.startRow][C4.startColumn].cell.selectEnd();
    }
    return true;
  }, COMMAND_PRIORITY_CRITICAL2)), c2.listenersToRemove.add(o2.registerCommand(SELECTION_CHANGE_COMMAND2, () => {
    const t4 = $getSelection2(), r2 = $getPreviousSelection2(), l3 = c2.getAndClearNextFocus();
    if (null !== l3) {
      const { focusCell: n2 } = l3;
      if (Ct5(t4) && t4.tableKey === c2.tableNodeKey) return (n2.x !== c2.focusX || n2.y !== c2.focusY) && (c2.$setFocusCellForSelection(n2), true);
      if (n2 !== c2.anchorCell && Jt2(t4, e2)) return c2.$setFocusCellForSelection(n2), true;
    }
    if (c2.getAndClearShouldCheckSelection() && $isRangeSelection2(r2) && $isRangeSelection2(t4) && t4.isCollapsed()) {
      const o3 = t4.anchor.getNode(), r3 = e2.getFirstChild(), l4 = jt2(o3);
      if (null !== l4 && Ee2(r3)) {
        const t5 = r3.getFirstChild();
        if (Re2(t5) && e2.is($findMatchingParent3(l4, (n2) => n2.is(e2) || n2.is(t5)))) return t5.selectStart(), true;
      }
    }
    if ($isRangeSelection2(t4)) {
      const { anchor: n2, focus: l4 } = t4, s3 = n2.getNode(), i3 = l4.getNode(), a3 = jt2(s3), u3 = jt2(i3), h5 = !(!a3 || !e2.is(Vt2(a3))), d4 = !(!u3 || !e2.is(Vt2(u3))), f3 = h5 !== d4, g5 = h5 && d4, m4 = t4.isBackward();
      if (f3) {
        const n3 = t4.clone();
        if (d4) {
          const [t5] = ut4(e2, u3, u3), o3 = t5[0][0].cell, r3 = t5[t5.length - 1].at(-1).cell;
          n3.focus.set(m4 ? o3.getKey() : r3.getKey(), m4 ? o3.getChildrenSize() : r3.getChildrenSize(), "element");
        } else if (h5) {
          const [t5] = ut4(e2, a3, a3), o3 = t5[0][0].cell, r3 = t5[t5.length - 1].at(-1).cell;
          n3.anchor.set(m4 ? r3.getKey() : o3.getKey(), m4 ? r3.getChildrenSize() : 0, "element");
        }
        $setSelection2(n3), Ht3(o2, c2);
      } else if (g5 && (a3.is(u3) || (c2.$setAnchorCellForSelection(nn2(c2, a3)), c2.$setFocusCellForSelection(nn2(c2, u3), true)), "touch" === c2.pointerType && t4.isCollapsed() && $isRangeSelection2(r2) && r2.isCollapsed())) {
        const e3 = jt2(r2.anchor.getNode());
        e3 && !e3.is(u3) && (c2.$setAnchorCellForSelection(nn2(c2, e3)), c2.$setFocusCellForSelection(nn2(c2, u3), true), c2.pointerType = null);
      }
    } else if (t4 && Ct5(t4) && t4.is(r2) && t4.tableKey === e2.getKey()) {
      const n2 = getDOMSelection2(i2);
      if (n2 && n2.anchorNode && n2.focusNode) {
        const r3 = $getNearestNodeFromDOMNode2(n2.focusNode), l4 = r3 && !e2.isParentOf(r3), s3 = $getNearestNodeFromDOMNode2(n2.anchorNode), i3 = s3 && e2.isParentOf(s3);
        if (l4 && i3 && n2.rangeCount > 0) {
          const r4 = $createRangeSelectionFromDom2(n2, o2);
          r4 && (r4.anchor.set(e2.getKey(), t4.isBackward() ? e2.getChildrenSize() : 0, "element"), n2.removeAllRanges(), $setSelection2(r4));
        }
      }
    }
    return t4 && !t4.is(r2) && (Ct5(t4) || Ct5(r2)) && c2.tableSelection && !c2.tableSelection.is(r2) ? (Ct5(t4) && t4.tableKey === c2.tableNodeKey ? c2.$updateTableTableSelection(t4) : !Ct5(t4) && Ct5(r2) && r2.tableKey === c2.tableNodeKey && c2.$updateTableTableSelection(null), false) : (c2.hasHijackedSelectionStyles && !e2.isSelected() ? function(e3, t5) {
      t5.$enableHighlightStyle(), zt2(t5.table, (t6) => {
        const n2 = t6.elem;
        t6.highlighted = false, Xt2(e3, t6), n2.getAttribute("style") || n2.removeAttribute("style");
      });
    }(o2, c2) : !c2.hasHijackedSelectionStyles && e2.isSelected() && Ht3(o2, c2), false);
  }, COMMAND_PRIORITY_CRITICAL2)), c2.listenersToRemove.add(o2.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const t4 = $getSelection2();
    if (!$isRangeSelection2(t4) || !t4.isCollapsed() || !Jt2(t4, e2)) return false;
    const n2 = tn2(o2, t4, e2);
    return !!n2 && (en2(n2, e2), true);
  }, COMMAND_PRIORITY_CRITICAL2)), c2;
}
function kt3(e2) {
  return e2[Nt4] || null;
}
function Mt4(e2) {
  let t3 = e2;
  for (; null != t3; ) {
    const e3 = t3.nodeName;
    if ("TD" === e3 || "TH" === e3) {
      const e4 = t3._cell;
      return void 0 === e4 ? null : e4;
    }
    t3 = t3.parentNode;
  }
  return null;
}
function $t3(e2, t3) {
  if (!e2.contains(t3)) return null;
  let n2 = null;
  for (let o2 = t3; null != o2; o2 = o2.parentNode) {
    if (o2 === e2) return n2;
    const t4 = o2.nodeName;
    "TD" !== t4 && "TH" !== t4 || (n2 = o2._cell || null);
  }
  return null;
}
function Lt3(e2, t3) {
  const n2 = [], o2 = { columns: 0, domRows: n2, rows: 0 };
  let r2 = Rt3(e2, t3).querySelector("tr"), l2 = 0, s2 = 0;
  for (n2.length = 0; null != r2; ) {
    const e3 = r2.nodeName;
    if ("TD" === e3 || "TH" === e3) {
      const e4 = { elem: r2, hasBackgroundColor: "" !== r2.style.backgroundColor, highlighted: false, x: l2, y: s2 };
      r2._cell = e4;
      let t5 = n2[s2];
      void 0 === t5 && (t5 = n2[s2] = []), t5[l2] = e4;
    } else {
      const e4 = r2.firstChild;
      if (null != e4) {
        r2 = e4;
        continue;
      }
    }
    const t4 = r2.nextSibling;
    if (null != t4) {
      l2++, r2 = t4;
      continue;
    }
    const o3 = r2.parentNode;
    if (null != o3) {
      const e4 = o3.nextSibling;
      if (null == e4) break;
      s2++, l2 = 0, r2 = e4;
    }
  }
  return o2.columns = l2 + 1, o2.rows = s2 + 1, o2;
}
function Wt2(e2, t3, n2) {
  const o2 = new Set(n2 ? n2.getNodes() : []);
  zt2(t3, (t4, n3) => {
    const r2 = t4.elem;
    o2.has(n3) ? (t4.highlighted = true, qt2(e2, t4)) : (t4.highlighted = false, Xt2(e2, t4), r2.getAttribute("style") || r2.removeAttribute("style"));
  });
}
function zt2(e2, t3) {
  const { domRows: n2 } = e2;
  for (let e3 = 0; e3 < n2.length; e3++) {
    const o2 = n2[e3];
    if (o2) for (let n3 = 0; n3 < o2.length; n3++) {
      const r2 = o2[n3];
      if (!r2) continue;
      const l2 = $getNearestNodeFromDOMNode2(r2.elem);
      null !== l2 && t3(r2, l2, { x: n3, y: e3 });
    }
  }
}
function Ht3(e2, t3) {
  t3.$disableHighlightStyle(), zt2(t3.table, (t4) => {
    t4.highlighted = true, qt2(e2, t4);
  });
}
function Bt3(e2, t3) {
  let n2, o2;
  if (t3.startColumn === e2.minColumn) n2 = "minColumn";
  else {
    if (t3.startColumn + t3.cell.__colSpan - 1 !== e2.maxColumn) return null;
    n2 = "maxColumn";
  }
  if (t3.startRow === e2.minRow) o2 = "minRow";
  else {
    if (t3.startRow + t3.cell.__rowSpan - 1 !== e2.maxRow) return null;
    o2 = "maxRow";
  }
  return [n2, o2];
}
function Dt4([e2, t3]) {
  return ["minColumn" === e2 ? "maxColumn" : "minColumn", "minRow" === t3 ? "maxRow" : "minRow"];
}
function It3(e2, t3, [n2, o2]) {
  const r2 = t3[o2], l2 = e2[r2];
  void 0 === l2 && Fe2(250, o2, String(r2));
  const s2 = t3[n2], i2 = l2[s2];
  return void 0 === i2 && Fe2(250, n2, String(s2)), i2;
}
function Ut2(e2, t3, n2, o2, r2) {
  const l2 = ft5(t3, n2, o2), s2 = function(e3, t4) {
    const { minColumn: n3, maxColumn: o3, minRow: r3, maxRow: l3 } = t4;
    let s3 = 1, i3 = 1, c3 = 1, a3 = 1;
    const u3 = e3[r3], h5 = e3[l3];
    for (let e4 = n3; e4 <= o3; e4++) s3 = Math.max(s3, u3[e4].cell.__rowSpan), a3 = Math.max(a3, h5[e4].cell.__rowSpan);
    for (let t5 = r3; t5 <= l3; t5++) i3 = Math.max(i3, e3[t5][n3].cell.__colSpan), c3 = Math.max(c3, e3[t5][o3].cell.__colSpan);
    return { bottomSpan: a3, leftSpan: i3, rightSpan: c3, topSpan: s3 };
  }(t3, l2), { topSpan: i2, leftSpan: c2, bottomSpan: a2, rightSpan: u2 } = s2, h4 = function(e3, t4) {
    const n3 = Bt3(e3, t4);
    return null === n3 && Fe2(249, t4.cell.getKey()), n3;
  }(l2, n2), [d3, f3] = Dt4(h4);
  let g4 = l2[d3], m4 = l2[f3];
  "forward" === r2 ? g4 += "maxColumn" === d3 ? 1 : c2 : "backward" === r2 ? g4 -= "minColumn" === d3 ? 1 : u2 : "down" === r2 ? m4 += "maxRow" === f3 ? 1 : i2 : "up" === r2 && (m4 -= "minRow" === f3 ? 1 : a2);
  const p3 = t3[m4];
  if (void 0 === p3) return false;
  const C4 = p3[g4];
  if (void 0 === C4) return false;
  const [_5, S4] = function(e3, t4, n3) {
    const o3 = ft5(e3, t4, n3), r3 = Bt3(o3, t4);
    if (r3) return [It3(e3, o3, r3), It3(e3, o3, Dt4(r3))];
    const l3 = Bt3(o3, n3);
    if (l3) return [It3(e3, o3, Dt4(l3)), It3(e3, o3, l3)];
    const s3 = ["minColumn", "minRow"];
    return [It3(e3, o3, s3), It3(e3, o3, Dt4(s3))];
  }(t3, n2, C4), w4 = nn2(e2, _5.cell), b3 = nn2(e2, S4.cell);
  return e2.$setAnchorCellForSelection(w4), e2.$setFocusCellForSelection(b3, true), true;
}
function Jt2(e2, t3) {
  if ($isRangeSelection2(e2) || Ct5(e2)) {
    const n2 = t3.isParentOf(e2.anchor.getNode()), o2 = t3.isParentOf(e2.focus.getNode());
    return n2 && o2;
  }
  return false;
}
function Yt2(e2, t3) {
  t3 ? e2.selectStart() : e2.selectEnd();
}
function qt2(t3, n2) {
  const o2 = n2.elem, r2 = t3._config.theme;
  Re2($getNearestNodeFromDOMNode2(o2)) || Fe2(131), addClassNamesToElement2(o2, r2.tableCellSelected);
}
function Xt2(e2, t3) {
  const n2 = t3.elem;
  Re2($getNearestNodeFromDOMNode2(n2)) || Fe2(131);
  const r2 = e2._config.theme;
  removeClassNamesFromElement2(n2, r2.tableCellSelected);
}
function jt2(e2) {
  const t3 = $findMatchingParent3(e2, Re2);
  return Re2(t3) ? t3 : null;
}
function Vt2(e2) {
  const t3 = $findMatchingParent3(e2, fn2);
  return fn2(t3) ? t3 : null;
}
function Gt2(e2, t3, o2, r2, l2, s2, i2) {
  const c2 = $caretFromPoint2(o2.focus, l2 ? "previous" : "next");
  if ($isExtendableTextPointCaret2(c2)) return false;
  let a2 = c2;
  for (const e3 of $extendCaretToRange2(c2).iterNodeCarets("shadowRoot")) {
    if (!$isSiblingCaret2(e3) || !$isElementNode2(e3.origin)) return false;
    a2 = e3;
  }
  const u2 = a2.getParentAtCaret();
  if (!Re2(u2)) return false;
  const h4 = u2, d3 = function(e3) {
    for (const t4 of $extendCaretToRange2(e3).iterNodeCarets("root")) {
      const { origin: n2 } = t4;
      if (Re2(n2)) {
        if ($isChildCaret2(t4)) return $getChildCaret2(n2, e3.direction);
      } else if (!Ee2(n2)) break;
    }
    return null;
  }($getSiblingCaret2(h4, a2.direction)), f3 = $findMatchingParent3(h4, fn2);
  if (!f3 || !f3.is(s2)) return false;
  const g4 = e2.getElementByKey(h4.getKey()), m4 = Mt4(g4);
  if (!g4 || !m4) return false;
  const p3 = un2(e2, f3);
  if (i2.table = p3, d3) if ("extend" === r2) {
    const t4 = Mt4(e2.getElementByKey(d3.origin.getKey()));
    if (!t4) return false;
    i2.$setAnchorCellForSelection(m4), i2.$setFocusCellForSelection(t4, true);
  } else {
    const e3 = $normalizeCaret2(d3);
    $setPointFromCaret2(o2.anchor, e3), $setPointFromCaret2(o2.focus, e3);
  }
  else if ("extend" === r2) i2.$setAnchorCellForSelection(m4), i2.$setFocusCellForSelection(m4, true);
  else {
    const e3 = function(e4) {
      const t4 = $getAdjacentChildCaret2(e4);
      return $isChildCaret2(t4) ? $normalizeCaret2(t4) : e4;
    }($getSiblingCaret2(f3, c2.direction));
    $setPointFromCaret2(o2.anchor, e3), $setPointFromCaret2(o2.focus, e3);
  }
  return Zt2(t3), true;
}
function Qt2(e2, t3, o2, r2, l2) {
  if (("up" === o2 || "down" === o2) && function(e3) {
    const t4 = e3.getRootElement();
    if (!t4) return false;
    return t4.hasAttribute("aria-controls") && "typeahead-menu" === t4.getAttribute("aria-controls");
  }(e2)) return false;
  const s2 = $getSelection2();
  if (!Jt2(s2, r2)) {
    if ($isRangeSelection2(s2)) {
      if ("backward" === o2) {
        if (s2.focus.offset > 0) return false;
        const e3 = function(e4) {
          for (let t4 = e4, n3 = e4; null !== n3; t4 = n3, n3 = n3.getParent()) if ($isElementNode2(n3)) {
            if (n3 !== t4 && n3.getFirstChild() !== t4) return null;
            if (!n3.isInline()) return n3;
          }
          return null;
        }(s2.focus.getNode());
        if (!e3) return false;
        const n2 = e3.getPreviousSibling();
        return !!fn2(n2) && (Zt2(t3), t3.shiftKey ? s2.focus.set(n2.getParentOrThrow().getKey(), n2.getIndexWithinParent(), "element") : n2.selectEnd(), true);
      }
      if (t3.shiftKey && ("up" === o2 || "down" === o2)) {
        const e3 = s2.focus.getNode();
        if (!s2.isCollapsed() && ("up" === o2 && !s2.isBackward() || "down" === o2 && s2.isBackward())) {
          let l3 = $findMatchingParent3(e3, (e4) => fn2(e4));
          if (Re2(l3) && (l3 = $findMatchingParent3(l3, fn2)), l3 !== r2) return false;
          if (!l3) return false;
          const i2 = "down" === o2 ? l3.getNextSibling() : l3.getPreviousSibling();
          if (!i2) return false;
          let c2 = 0;
          "up" === o2 && $isElementNode2(i2) && (c2 = i2.getChildrenSize());
          let a2 = i2;
          if ("up" === o2 && $isElementNode2(i2)) {
            const e4 = i2.getLastChild();
            a2 = e4 || i2, c2 = $isTextNode2(a2) ? a2.getTextContentSize() : 0;
          }
          const u2 = s2.clone();
          return u2.focus.set(a2.getKey(), c2, $isTextNode2(a2) ? "text" : "element"), $setSelection2(u2), Zt2(t3), true;
        }
        if ($isRootOrShadowRoot2(e3)) {
          const e4 = "up" === o2 ? s2.getNodes()[s2.getNodes().length - 1] : s2.getNodes()[0];
          if (e4) {
            if (null !== Ft3(r2, e4)) {
              const e5 = r2.getFirstDescendant(), t4 = r2.getLastDescendant();
              if (!e5 || !t4) return false;
              const [n2] = dt5(e5), [o3] = dt5(t4), s3 = r2.getCordsFromCellNode(n2, l2.table), i2 = r2.getCordsFromCellNode(o3, l2.table), c2 = r2.getDOMCellFromCordsOrThrow(s3.x, s3.y, l2.table), a2 = r2.getDOMCellFromCordsOrThrow(i2.x, i2.y, l2.table);
              return l2.$setAnchorCellForSelection(c2), l2.$setFocusCellForSelection(a2, true), true;
            }
          }
          return false;
        }
        {
          let r3 = $findMatchingParent3(e3, (e4) => $isElementNode2(e4) && !e4.isInline());
          if (Re2(r3) && (r3 = $findMatchingParent3(r3, fn2)), !r3) return false;
          const i2 = "down" === o2 ? r3.getNextSibling() : r3.getPreviousSibling();
          if (fn2(i2) && l2.tableNodeKey === i2.getKey()) {
            const e4 = i2.getFirstDescendant(), n2 = i2.getLastDescendant();
            if (!e4 || !n2) return false;
            const [r4] = dt5(e4), [l3] = dt5(n2), c2 = s2.clone();
            return c2.focus.set(("up" === o2 ? r4 : l3).getKey(), "up" === o2 ? 0 : l3.getChildrenSize(), "element"), Zt2(t3), $setSelection2(c2), true;
          }
        }
      }
    }
    return "down" === o2 && sn2(e2) && l2.setShouldCheckSelection(), false;
  }
  if ($isRangeSelection2(s2)) {
    if ("backward" === o2 || "forward" === o2) {
      return Gt2(e2, t3, s2, t3.shiftKey ? "extend" : "move", "backward" === o2, r2, l2);
    }
    if (s2.isCollapsed()) {
      const { anchor: i2, focus: c2 } = s2, a2 = $findMatchingParent3(i2.getNode(), Re2), u2 = $findMatchingParent3(c2.getNode(), Re2);
      if (!Re2(a2) || !a2.is(u2)) return false;
      const h4 = Vt2(a2);
      if (h4 !== r2 && null != h4) {
        const n2 = Rt3(h4, e2.getElementByKey(h4.getKey()));
        if (null != n2) return l2.table = Lt3(h4, n2), Qt2(e2, t3, o2, h4, l2);
      }
      const d3 = e2.getElementByKey(a2.__key), f3 = e2.getElementByKey(i2.key);
      if (null == f3 || null == d3) return false;
      let g4;
      if ("element" === i2.type) g4 = f3.getBoundingClientRect();
      else {
        const t4 = getDOMSelection2(Tt5(e2));
        if (null === t4 || 0 === t4.rangeCount) return false;
        g4 = t4.getRangeAt(0).getBoundingClientRect();
      }
      const m4 = "up" === o2 ? a2.getFirstChild() : a2.getLastChild();
      if (null == m4) return false;
      const p3 = e2.getElementByKey(m4.__key);
      if (null == p3) return false;
      const C4 = p3.getBoundingClientRect();
      if ("up" === o2 ? C4.top > g4.top - g4.height : g4.bottom + g4.height > C4.bottom) {
        Zt2(t3);
        const e3 = r2.getCordsFromCellNode(a2, l2.table);
        if (!t3.shiftKey) return Pt4(l2, r2, e3.x, e3.y, o2);
        {
          const t4 = r2.getDOMCellFromCordsOrThrow(e3.x, e3.y, l2.table);
          l2.$setAnchorCellForSelection(t4), l2.$setFocusCellForSelection(t4, true);
        }
        return true;
      }
    }
  } else if (Ct5(s2)) {
    const { anchor: i2, focus: c2 } = s2, a2 = $findMatchingParent3(i2.getNode(), Re2), u2 = $findMatchingParent3(c2.getNode(), Re2), [h4] = s2.getNodes();
    fn2(h4) || Fe2(251);
    const d3 = Rt3(h4, e2.getElementByKey(h4.getKey()));
    if (!Re2(a2) || !Re2(u2) || !fn2(h4) || null == d3) return false;
    l2.$updateTableTableSelection(s2);
    const f3 = Lt3(h4, d3), g4 = r2.getCordsFromCellNode(a2, f3), m4 = r2.getDOMCellFromCordsOrThrow(g4.x, g4.y, f3);
    if (l2.$setAnchorCellForSelection(m4), Zt2(t3), t3.shiftKey) {
      const [e3, t4, n2] = ut4(r2, a2, u2);
      return Ut2(l2, e3, t4, n2, o2);
    }
    return u2.selectEnd(), true;
  }
  return false;
}
function Zt2(e2) {
  e2.preventDefault(), e2.stopImmediatePropagation(), e2.stopPropagation();
}
function en2(e2, t3, n2) {
  const o2 = $createParagraphNode2();
  "first" === e2 ? t3.insertBefore(o2) : t3.insertAfter(o2), o2.append(...n2 || []), o2.selectEnd();
}
function tn2(e2, t3, o2) {
  const r2 = o2.getParent();
  if (!r2) return;
  const l2 = getDOMSelection2(Tt5(e2));
  if (!l2) return;
  const s2 = l2.anchorNode, i2 = e2.getElementByKey(r2.getKey()), c2 = Rt3(o2, e2.getElementByKey(o2.getKey()));
  if (!s2 || !i2 || !c2 || !i2.contains(s2) || c2.contains(s2)) return;
  const a2 = $findMatchingParent3(t3.anchor.getNode(), (e3) => Re2(e3));
  if (!a2) return;
  const u2 = $findMatchingParent3(a2, (e3) => fn2(e3));
  if (!fn2(u2) || !u2.is(o2)) return;
  const [h4, d3] = ut4(o2, a2, a2), f3 = h4[0][0], g4 = h4[h4.length - 1][h4[0].length - 1], { startRow: m4, startColumn: p3 } = d3, C4 = m4 === f3.startRow && p3 === f3.startColumn, _5 = m4 === g4.startRow && p3 === g4.startColumn;
  return C4 ? "first" : _5 ? "last" : void 0;
}
function nn2(e2, t3) {
  const { tableNode: n2 } = e2.$lookup(), o2 = n2.getCordsFromCellNode(t3, e2.table);
  return n2.getDOMCellFromCordsOrThrow(o2.x, o2.y, e2.table);
}
function on2(e2, t3, n2) {
  return Ft3(e2, $getNearestNodeFromDOMNode2(t3, n2));
}
function rn2(t3, n2, r2) {
  if (!n2.theme.tableAlignment) return;
  const l2 = [], s2 = [];
  for (const e2 of ["center", "right"]) {
    const t4 = n2.theme.tableAlignment[e2];
    t4 && (e2 === r2 ? s2 : l2).push(t4);
  }
  removeClassNamesFromElement2(t3, ...l2), addClassNamesToElement2(t3, ...s2);
}
function sn2(e2 = $getEditor2()) {
  return ln2.has(e2);
}
function cn2(e2, t3) {
  t3 ? ln2.add(e2) : ln2.delete(e2);
}
function un2(e2, t3) {
  const n2 = e2.getElementByKey(t3.getKey());
  return null === n2 && Fe2(230), Lt3(t3, n2);
}
function hn2(e2) {
  const n2 = dn2();
  e2.hasAttribute("data-lexical-row-striping") && n2.setRowStriping(true), e2.hasAttribute("data-lexical-frozen-column") && n2.setFrozenColumns(1), e2.hasAttribute("data-lexical-frozen-row") && n2.setFrozenRows(1);
  const o2 = e2.querySelector(":scope > colgroup");
  if (o2) {
    let e3 = [];
    for (const t3 of o2.querySelectorAll(":scope > col")) {
      let n3 = t3.style.width || "";
      if (!we2.test(n3) && (n3 = t3.getAttribute("width") || "", !/^\d+$/.test(n3))) {
        e3 = void 0;
        break;
      }
      e3.push(parseFloat(n3));
    }
    e3 && n2.setColWidths(e3);
  }
  return { after: (e3) => $descendantsMatching2(e3, Ee2), node: n2 };
}
function dn2() {
  return $applyNodeReplacement2(new an2());
}
function fn2(e2) {
  return e2 instanceof an2;
}
function gn2({ rows: e2, columns: t3, includeHeaders: n2 }) {
  const o2 = $getSelection2() || $getPreviousSelection2();
  if (!o2 || !$isRangeSelection2(o2)) return false;
  if (Vt2(o2.anchor.getNode())) return false;
  const r2 = Le2(Number(e2), Number(t3), n2);
  $insertNodeToNearestRoot2(r2);
  const l2 = r2.getFirstDescendant();
  return $isTextNode2(l2) && l2.select(), true;
}
function mn2(e2) {
  Ee2(e2.getParent()) ? e2.isEmpty() && e2.append($createParagraphNode2()) : e2.remove();
}
function pn2(e2) {
  fn2(e2.getParent()) ? $unwrapAndFilterDescendants2(e2, Re2) : e2.remove();
}
function Cn2(e2) {
  $unwrapAndFilterDescendants2(e2, Ee2);
  const [t3] = ht5(e2, null, null), n2 = t3.reduce((e3, t4) => Math.max(e3, t4.length), 0), o2 = e2.getChildren();
  for (let e3 = 0; e3 < t3.length; ++e3) {
    const r2 = o2[e3];
    if (!r2) continue;
    Ee2(r2) || Fe2(254, r2.constructor.name, r2.getType());
    const l2 = t3[e3].reduce((e4, t4) => t4 ? 1 + e4 : e4, 0);
    if (l2 !== n2) for (let e4 = l2; e4 < n2; ++e4) {
      const e5 = ve2();
      e5.append($createParagraphNode2()), r2.append(e5);
    }
  }
}
function _n2(e2) {
  if (e2.detail < 3 || !isDOMNode2(e2.target)) return false;
  const t3 = $getNearestNodeFromDOMNode2(e2.target);
  if (null === t3) return false;
  const o2 = $findMatchingParent3(t3, (e3) => $isElementNode2(e3) && !e3.isInline());
  if (null === o2) return false;
  return !!Re2(o2.getParent()) && (o2.select(0), true);
}
function Sn2(e2) {
  return e2.registerNodeTransform(ye2, (e3) => {
    if (e3.getColSpan() > 1 || e3.getRowSpan() > 1) {
      const [, , t3] = dt5(e3), [n2] = ut4(t3, e3, e3), o2 = n2.length, r2 = n2[0].length;
      let l2 = t3.getFirstChild();
      Ee2(l2) || Fe2(175);
      const i2 = [];
      for (let e4 = 0; e4 < o2; e4++) {
        0 !== e4 && (l2 = l2.getNextSibling(), Ee2(l2) || Fe2(175));
        let t4 = null;
        for (let o3 = 0; o3 < r2; o3++) {
          const r3 = n2[e4][o3], c2 = r3.cell;
          if (r3.startRow === e4 && r3.startColumn === o3) t4 = c2, i2.push(c2);
          else if (c2.getColSpan() > 1 || c2.getRowSpan() > 1) {
            Re2(c2) || Fe2(176);
            const e5 = ve2(c2.__headerState);
            null !== t4 ? t4.insertAfter(e5) : $insertFirst2(l2, e5);
          }
        }
      }
      for (const e4 of i2) e4.setColSpan(1), e4.setRowSpan(1);
    }
  });
}
function wn2(e2, t3 = true) {
  const n2 = /* @__PURE__ */ new Map(), o2 = (o3, r3, l2) => {
    const s2 = Rt3(o3, l2), i2 = Et4(o3, s2, e2, t3);
    n2.set(r3, [i2, s2]);
  }, r2 = e2.registerMutationListener(an2, (t4) => {
    e2.getEditorState().read(() => {
      for (const [e3, r3] of t4) {
        const t5 = n2.get(e3);
        if ("created" === r3 || "updated" === r3) {
          const { tableNode: r4, tableElement: l2 } = bt3(e3);
          void 0 === t5 ? o2(r4, e3, l2) : l2 !== t5[1] && (t5[0].removeListeners(), n2.delete(e3), o2(r4, e3, l2));
        } else "destroyed" === r3 && void 0 !== t5 && (t5[0].removeListeners(), n2.delete(e3));
      }
    }, { editor: e2 });
  }, { skipInitialization: false });
  return () => {
    r2();
    for (const [, [e3]] of n2) e3.removeListeners();
  };
}
function bn2(e2) {
  return e2.hasNodes([an2]) || Fe2(255), mergeRegister2(e2.registerCommand(Te2, gn2, COMMAND_PRIORITY_EDITOR2), e2.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, ({ nodes: e3, selection: t3 }) => {
    if (!$isRangeSelection2(t3)) return false;
    return null !== Vt2(t3.anchor.getNode()) && e3.some(fn2);
  }, COMMAND_PRIORITY_EDITOR2), e2.registerCommand(CLICK_COMMAND2, _n2, COMMAND_PRIORITY_EDITOR2), e2.registerNodeTransform(an2, Cn2), e2.registerNodeTransform(Oe2, pn2), e2.registerNodeTransform(ye2, mn2));
}
var we2, be2, ye2, Te2, Oe2, ke2, Me2, $e2, Je2, qe2, Ge2, tt4, ot4, pt5, yt5, Nt4, xt4, Ot4, At4, Kt3, Pt4, ln2, an2;
var init_LexicalTable_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/table@0.32.1/node_modules/@lexical/table/LexicalTable.prod.mjs"() {
    await init_LexicalUtils_node();
    await init_Lexical_node();
    await init_LexicalClipboard_node();
    we2 = /^(\d+(?:\.\d+)?)px$/;
    be2 = { BOTH: 3, COLUMN: 2, NO_STATUS: 0, ROW: 1 };
    ye2 = class _ye extends ElementNode2 {
      static getType() {
        return "tablecell";
      }
      static clone(e2) {
        return new _ye(e2.__headerState, e2.__colSpan, e2.__width, e2.__key);
      }
      afterCloneFrom(e2) {
        super.afterCloneFrom(e2), this.__rowSpan = e2.__rowSpan, this.__backgroundColor = e2.__backgroundColor, this.__verticalAlign = e2.__verticalAlign;
      }
      static importDOM() {
        return { td: (e2) => ({ conversion: xe2, priority: 0 }), th: (e2) => ({ conversion: xe2, priority: 0 }) };
      }
      static importJSON(e2) {
        return ve2().updateFromJSON(e2);
      }
      updateFromJSON(e2) {
        return super.updateFromJSON(e2).setHeaderStyles(e2.headerState).setColSpan(e2.colSpan || 1).setRowSpan(e2.rowSpan || 1).setWidth(e2.width || void 0).setBackgroundColor(e2.backgroundColor || null).setVerticalAlign(e2.verticalAlign || void 0);
      }
      constructor(e2 = be2.NO_STATUS, t3 = 1, n2, o2) {
        super(o2), this.__colSpan = t3, this.__rowSpan = 1, this.__headerState = e2, this.__width = n2, this.__backgroundColor = null, this.__verticalAlign = void 0;
      }
      createDOM(t3) {
        const n2 = document.createElement(this.getTag());
        return this.__width && (n2.style.width = `${this.__width}px`), this.__colSpan > 1 && (n2.colSpan = this.__colSpan), this.__rowSpan > 1 && (n2.rowSpan = this.__rowSpan), null !== this.__backgroundColor && (n2.style.backgroundColor = this.__backgroundColor), Ne2(this.__verticalAlign) && (n2.style.verticalAlign = this.__verticalAlign), addClassNamesToElement2(n2, t3.theme.tableCell, this.hasHeader() && t3.theme.tableCellHeader), n2;
      }
      exportDOM(e2) {
        const t3 = super.exportDOM(e2);
        if (isHTMLElement2(t3.element)) {
          const e3 = t3.element;
          e3.setAttribute("data-temporary-table-cell-lexical-key", this.getKey()), e3.style.border = "1px solid black", this.__colSpan > 1 && (e3.colSpan = this.__colSpan), this.__rowSpan > 1 && (e3.rowSpan = this.__rowSpan), e3.style.width = `${this.getWidth() || 75}px`, e3.style.verticalAlign = this.getVerticalAlign() || "top", e3.style.textAlign = "start", null === this.__backgroundColor && this.hasHeader() && (e3.style.backgroundColor = "#f2f3f5");
        }
        return t3;
      }
      exportJSON() {
        return { ...super.exportJSON(), ...Ne2(this.__verticalAlign) && { verticalAlign: this.__verticalAlign }, backgroundColor: this.getBackgroundColor(), colSpan: this.__colSpan, headerState: this.__headerState, rowSpan: this.__rowSpan, width: this.getWidth() };
      }
      getColSpan() {
        return this.getLatest().__colSpan;
      }
      setColSpan(e2) {
        const t3 = this.getWritable();
        return t3.__colSpan = e2, t3;
      }
      getRowSpan() {
        return this.getLatest().__rowSpan;
      }
      setRowSpan(e2) {
        const t3 = this.getWritable();
        return t3.__rowSpan = e2, t3;
      }
      getTag() {
        return this.hasHeader() ? "th" : "td";
      }
      setHeaderStyles(e2, t3 = be2.BOTH) {
        const n2 = this.getWritable();
        return n2.__headerState = e2 & t3 | n2.__headerState & ~t3, n2;
      }
      getHeaderStyles() {
        return this.getLatest().__headerState;
      }
      setWidth(e2) {
        const t3 = this.getWritable();
        return t3.__width = e2, t3;
      }
      getWidth() {
        return this.getLatest().__width;
      }
      getBackgroundColor() {
        return this.getLatest().__backgroundColor;
      }
      setBackgroundColor(e2) {
        const t3 = this.getWritable();
        return t3.__backgroundColor = e2, t3;
      }
      getVerticalAlign() {
        return this.getLatest().__verticalAlign;
      }
      setVerticalAlign(e2) {
        const t3 = this.getWritable();
        return t3.__verticalAlign = e2 || void 0, t3;
      }
      toggleHeaderStyle(e2) {
        const t3 = this.getWritable();
        return (t3.__headerState & e2) === e2 ? t3.__headerState -= e2 : t3.__headerState += e2, t3;
      }
      hasHeaderState(e2) {
        return (this.getHeaderStyles() & e2) === e2;
      }
      hasHeader() {
        return this.getLatest().__headerState !== be2.NO_STATUS;
      }
      updateDOM(e2) {
        return e2.__headerState !== this.__headerState || e2.__width !== this.__width || e2.__colSpan !== this.__colSpan || e2.__rowSpan !== this.__rowSpan || e2.__backgroundColor !== this.__backgroundColor || e2.__verticalAlign !== this.__verticalAlign;
      }
      isShadowRoot() {
        return true;
      }
      collapseAtStart() {
        return true;
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
    };
    Te2 = createCommand2("INSERT_TABLE_COMMAND");
    Oe2 = class _Oe extends ElementNode2 {
      static getType() {
        return "tablerow";
      }
      static clone(e2) {
        return new _Oe(e2.__height, e2.__key);
      }
      static importDOM() {
        return { tr: (e2) => ({ conversion: Ae2, priority: 0 }) };
      }
      static importJSON(e2) {
        return Ke2().updateFromJSON(e2);
      }
      updateFromJSON(e2) {
        return super.updateFromJSON(e2).setHeight(e2.height);
      }
      constructor(e2, t3) {
        super(t3), this.__height = e2;
      }
      exportJSON() {
        const e2 = this.getHeight();
        return { ...super.exportJSON(), ...void 0 === e2 ? void 0 : { height: e2 } };
      }
      createDOM(t3) {
        const n2 = document.createElement("tr");
        return this.__height && (n2.style.height = `${this.__height}px`), addClassNamesToElement2(n2, t3.theme.tableRow), n2;
      }
      extractWithChild(e2, t3, n2) {
        return "html" === n2;
      }
      isShadowRoot() {
        return true;
      }
      setHeight(e2) {
        const t3 = this.getWritable();
        return t3.__height = e2, t3;
      }
      getHeight() {
        return this.getLatest().__height;
      }
      updateDOM(e2) {
        return e2.__height !== this.__height;
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
    };
    ke2 = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    Me2 = ke2 && "documentMode" in document ? document.documentMode : null;
    $e2 = ke2 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    ke2 && "InputEvent" in window && !Me2 && new window.InputEvent("input");
    Je2 = (e2, t3) => e2 === be2.BOTH || e2 === t3 ? t3 : be2.NO_STATUS;
    qe2 = Ye2;
    Ge2 = Ve2;
    tt4 = et4;
    ot4 = nt4;
    pt5 = class _pt {
      constructor(e2, t3, n2) {
        this.anchor = t3, this.focus = n2, t3._selection = this, n2._selection = this, this._cachedNodes = null, this.dirty = false, this.tableKey = e2;
      }
      getStartEndPoints() {
        return [this.anchor, this.focus];
      }
      isValid() {
        return "root" !== this.tableKey && "root" !== this.anchor.key && "element" === this.anchor.type && "root" !== this.focus.key && "element" === this.focus.type;
      }
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(e2) {
        this._cachedNodes = e2;
      }
      is(e2) {
        return Ct5(e2) && this.tableKey === e2.tableKey && this.anchor.is(e2.anchor) && this.focus.is(e2.focus);
      }
      set(e2, t3, n2) {
        this.dirty = this.dirty || e2 !== this.tableKey || t3 !== this.anchor.key || n2 !== this.focus.key, this.tableKey = e2, this.anchor.key = t3, this.focus.key = n2, this._cachedNodes = null;
      }
      clone() {
        return new _pt(this.tableKey, $createPoint2(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint2(this.focus.key, this.focus.offset, this.focus.type));
      }
      isCollapsed() {
        return false;
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(e2) {
      }
      insertText() {
      }
      hasFormat(e2) {
        let t3 = 0;
        this.getNodes().filter(Re2).forEach((e3) => {
          const n3 = e3.getFirstChild();
          $isParagraphNode2(n3) && (t3 |= n3.getTextFormat());
        });
        const n2 = TEXT_TYPE_TO_FORMAT2[e2];
        return !!(t3 & n2);
      }
      insertNodes(e2) {
        const t3 = this.focus.getNode();
        $isElementNode2(t3) || Fe2(151);
        $normalizeSelection__EXPERIMENTAL(t3.select(0, t3.getChildrenSize())).insertNodes(e2);
      }
      getShape() {
        const { anchorCell: e2, focusCell: t3 } = mt5(this), n2 = gt5(e2);
        null === n2 && Fe2(153);
        const o2 = gt5(t3);
        null === o2 && Fe2(155);
        const r2 = Math.min(n2.columnIndex, o2.columnIndex), l2 = Math.max(n2.columnIndex + n2.colSpan - 1, o2.columnIndex + o2.colSpan - 1), s2 = Math.min(n2.rowIndex, o2.rowIndex), i2 = Math.max(n2.rowIndex + n2.rowSpan - 1, o2.rowIndex + o2.rowSpan - 1);
        return { fromX: Math.min(r2, l2), fromY: Math.min(s2, i2), toX: Math.max(r2, l2), toY: Math.max(s2, i2) };
      }
      getNodes() {
        if (!this.isValid()) return [];
        const e2 = this._cachedNodes;
        if (null !== e2) return e2;
        const { anchorTable: t3, anchorCell: n2, focusCell: o2 } = mt5(this), r2 = o2.getParents()[1];
        if (r2 !== t3) {
          if (t3.isParentOf(o2)) {
            const e3 = r2.getParent();
            null == e3 && Fe2(159), this.set(this.tableKey, o2.getKey(), e3.getKey());
          } else {
            const e3 = t3.getParent();
            null == e3 && Fe2(158), this.set(this.tableKey, e3.getKey(), o2.getKey());
          }
          return this.getNodes();
        }
        const [l2, s2, i2] = ut4(t3, n2, o2), { minColumn: c2, maxColumn: a2, minRow: u2, maxRow: h4 } = ft5(l2, s2, i2), d3 = /* @__PURE__ */ new Map([[t3.getKey(), t3]]);
        let f3 = null;
        for (let e3 = u2; e3 <= h4; e3++) for (let t4 = c2; t4 <= a2; t4++) {
          const { cell: n3 } = l2[e3][t4], o3 = n3.getParent();
          Ee2(o3) || Fe2(160), o3 !== f3 && (d3.set(o3.getKey(), o3), f3 = o3), d3.has(n3.getKey()) || wt4(n3, (e4) => {
            d3.set(e4.getKey(), e4);
          });
        }
        const g4 = Array.from(d3.values());
        return isCurrentlyReadOnlyMode2() || (this._cachedNodes = g4), g4;
      }
      getTextContent() {
        const e2 = this.getNodes().filter((e3) => Re2(e3));
        let t3 = "";
        for (let n2 = 0; n2 < e2.length; n2++) {
          const o2 = e2[n2], r2 = o2.__parent, l2 = (e2[n2 + 1] || {}).__parent;
          t3 += o2.getTextContent() + (l2 !== r2 ? "\n" : "	");
        }
        return t3;
      }
    };
    yt5 = class {
      constructor(e2, t3) {
        this.isHighlightingCells = false, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = t3, this.editor = e2, this.table = { columns: 0, domRows: [], rows: 0 }, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = false, this.isSelecting = false, this.pointerType = null, this.shouldCheckSelection = false, this.abortController = new AbortController(), this.listenerOptions = { signal: this.abortController.signal }, this.nextFocus = null, this.trackTable();
      }
      getTable() {
        return this.table;
      }
      removeListeners() {
        this.abortController.abort("removeListeners"), Array.from(this.listenersToRemove).forEach((e2) => e2()), this.listenersToRemove.clear();
      }
      $lookup() {
        return bt3(this.tableNodeKey, this.editor);
      }
      trackTable() {
        const e2 = new MutationObserver((e3) => {
          this.editor.getEditorState().read(() => {
            let t3 = false;
            for (let n3 = 0; n3 < e3.length; n3++) {
              const o3 = e3[n3].target.nodeName;
              if ("TABLE" === o3 || "TBODY" === o3 || "THEAD" === o3 || "TR" === o3) {
                t3 = true;
                break;
              }
            }
            if (!t3) return;
            const { tableNode: n2, tableElement: o2 } = this.$lookup();
            this.table = Lt3(n2, o2);
          }, { editor: this.editor });
        });
        this.editor.getEditorState().read(() => {
          const { tableNode: t3, tableElement: n2 } = this.$lookup();
          this.table = Lt3(t3, n2), e2.observe(n2, { attributes: true, childList: true, subtree: true });
        }, { editor: this.editor });
      }
      $clearHighlight() {
        const e2 = this.editor;
        this.isHighlightingCells = false, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = false, this.$enableHighlightStyle();
        const { tableNode: t3, tableElement: n2 } = this.$lookup();
        Wt2(e2, Lt3(t3, n2), null), null !== $getSelection2() && ($setSelection2(null), e2.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0));
      }
      $enableHighlightStyle() {
        const e2 = this.editor, { tableElement: t3 } = this.$lookup();
        removeClassNamesFromElement2(t3, e2._config.theme.tableSelection), t3.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = false;
      }
      $disableHighlightStyle() {
        const { tableElement: t3 } = this.$lookup();
        addClassNamesToElement2(t3, this.editor._config.theme.tableSelection), this.hasHijackedSelectionStyles = true;
      }
      $updateTableTableSelection(e2) {
        if (null !== e2) {
          e2.tableKey !== this.tableNodeKey && Fe2(233, e2.tableKey, this.tableNodeKey);
          const t3 = this.editor;
          this.tableSelection = e2, this.isHighlightingCells = true, this.$disableHighlightStyle(), this.updateDOMSelection(), Wt2(t3, this.table, this.tableSelection);
        } else this.$clearHighlight();
      }
      setShouldCheckSelection() {
        this.shouldCheckSelection = true;
      }
      getAndClearShouldCheckSelection() {
        return !!this.shouldCheckSelection && (this.shouldCheckSelection = false, true);
      }
      setNextFocus(e2) {
        this.nextFocus = e2;
      }
      getAndClearNextFocus() {
        const { nextFocus: e2 } = this;
        return null !== e2 && (this.nextFocus = null), e2;
      }
      updateDOMSelection() {
        if (null !== this.anchorCell && null !== this.focusCell) {
          const e2 = getDOMSelection2(this.editor._window);
          e2 && e2.rangeCount > 0 && e2.removeAllRanges();
        }
      }
      $setFocusCellForSelection(e2, t3 = false) {
        const n2 = this.editor, { tableNode: o2 } = this.$lookup(), r2 = e2.x, l2 = e2.y;
        if (this.focusCell = e2, this.isHighlightingCells || this.anchorX === r2 && this.anchorY === l2 && !t3) {
          if (r2 === this.focusX && l2 === this.focusY) return false;
        } else this.isHighlightingCells = true, this.$disableHighlightStyle();
        if (this.focusX = r2, this.focusY = l2, this.isHighlightingCells) {
          const t4 = on2(o2, e2.elem);
          if (null != this.tableSelection && null != this.anchorCellNodeKey && null !== t4) return this.focusCellNodeKey = t4.getKey(), this.tableSelection = St4(o2, this.$getAnchorTableCellOrThrow(), t4), $setSelection2(this.tableSelection), n2.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0), Wt2(n2, this.table, this.tableSelection), true;
        }
        return false;
      }
      $getAnchorTableCell() {
        return this.anchorCellNodeKey ? $getNodeByKey2(this.anchorCellNodeKey) : null;
      }
      $getAnchorTableCellOrThrow() {
        const e2 = this.$getAnchorTableCell();
        return null === e2 && Fe2(234), e2;
      }
      $getFocusTableCell() {
        return this.focusCellNodeKey ? $getNodeByKey2(this.focusCellNodeKey) : null;
      }
      $getFocusTableCellOrThrow() {
        const e2 = this.$getFocusTableCell();
        return null === e2 && Fe2(235), e2;
      }
      $setAnchorCellForSelection(e2) {
        this.isHighlightingCells = false, this.anchorCell = e2, this.anchorX = e2.x, this.anchorY = e2.y;
        const { tableNode: t3 } = this.$lookup(), n2 = on2(t3, e2.elem);
        if (null !== n2) {
          const e3 = n2.getKey();
          this.tableSelection = null != this.tableSelection ? this.tableSelection.clone() : _t5(), this.anchorCellNodeKey = e3;
        }
      }
      $formatCells(e2) {
        const t3 = $getSelection2();
        Ct5(t3) || Fe2(236);
        const n2 = $createRangeSelection2(), o2 = n2.anchor, r2 = n2.focus, l2 = t3.getNodes().filter(Re2);
        l2.length > 0 || Fe2(237);
        const s2 = l2[0].getFirstChild(), i2 = $isParagraphNode2(s2) ? s2.getFormatFlags(e2, null) : null;
        l2.forEach((t4) => {
          o2.set(t4.getKey(), 0, "element"), r2.set(t4.getKey(), t4.getChildrenSize(), "element"), n2.formatText(e2, i2);
        }), $setSelection2(t3), this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
      $clearText() {
        const { editor: e2 } = this, t3 = $getNodeByKey2(this.tableNodeKey);
        if (!fn2(t3)) throw new Error("Expected TableNode.");
        const n2 = $getSelection2();
        Ct5(n2) || Fe2(253);
        const o2 = n2.getNodes().filter(Re2), r2 = t3.getFirstChild(), l2 = t3.getLastChild();
        if (o2.length > 0 && null !== r2 && null !== l2 && Ee2(r2) && Ee2(l2) && o2[0] === r2.getFirstChild() && o2[o2.length - 1] === l2.getLastChild()) {
          t3.selectPrevious();
          const n3 = t3.getParent();
          return t3.remove(), void ($isRootNode2(n3) && n3.isEmpty() && e2.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0));
        }
        o2.forEach((e3) => {
          if ($isElementNode2(e3)) {
            const t4 = $createParagraphNode2(), n3 = $createTextNode2();
            t4.append(n3), e3.append(t4), e3.getChildren().forEach((e4) => {
              e4 !== t4 && e4.remove();
            });
          }
        }), Wt2(e2, this.table, null), $setSelection2(null), e2.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
    };
    Nt4 = "__lexicalTableSelection";
    xt4 = (e2) => !(1 & ~e2.buttons);
    Ot4 = [[KEY_ARROW_DOWN_COMMAND2, "down"], [KEY_ARROW_UP_COMMAND2, "up"], [KEY_ARROW_LEFT_COMMAND2, "backward"], [KEY_ARROW_RIGHT_COMMAND2, "forward"]];
    At4 = [DELETE_WORD_COMMAND2, DELETE_LINE_COMMAND2, DELETE_CHARACTER_COMMAND2];
    Kt3 = [KEY_BACKSPACE_COMMAND2, KEY_DELETE_COMMAND2];
    Pt4 = (e2, t3, n2, o2, r2) => {
      const l2 = "forward" === r2;
      switch (r2) {
        case "backward":
        case "forward":
          return n2 !== (l2 ? e2.table.columns - 1 : 0) ? Yt2(t3.getCellNodeFromCordsOrThrow(n2 + (l2 ? 1 : -1), o2, e2.table), l2) : o2 !== (l2 ? e2.table.rows - 1 : 0) ? Yt2(t3.getCellNodeFromCordsOrThrow(l2 ? 0 : e2.table.columns - 1, o2 + (l2 ? 1 : -1), e2.table), l2) : l2 ? t3.selectNext() : t3.selectPrevious(), true;
        case "up":
          return 0 !== o2 ? Yt2(t3.getCellNodeFromCordsOrThrow(n2, o2 - 1, e2.table), false) : t3.selectPrevious(), true;
        case "down":
          return o2 !== e2.table.rows - 1 ? Yt2(t3.getCellNodeFromCordsOrThrow(n2, o2 + 1, e2.table), true) : t3.selectNext(), true;
        default:
          return false;
      }
    };
    ln2 = /* @__PURE__ */ new WeakSet();
    an2 = class _an extends ElementNode2 {
      static getType() {
        return "table";
      }
      getColWidths() {
        return this.getLatest().__colWidths;
      }
      setColWidths(e2) {
        const t3 = this.getWritable();
        return t3.__colWidths = e2, t3;
      }
      static clone(e2) {
        return new _an(e2.__key);
      }
      afterCloneFrom(e2) {
        super.afterCloneFrom(e2), this.__colWidths = e2.__colWidths, this.__rowStriping = e2.__rowStriping, this.__frozenColumnCount = e2.__frozenColumnCount, this.__frozenRowCount = e2.__frozenRowCount;
      }
      static importDOM() {
        return { table: (e2) => ({ conversion: hn2, priority: 1 }) };
      }
      static importJSON(e2) {
        return dn2().updateFromJSON(e2);
      }
      updateFromJSON(e2) {
        return super.updateFromJSON(e2).setRowStriping(e2.rowStriping || false).setFrozenColumns(e2.frozenColumnCount || 0).setFrozenRows(e2.frozenRowCount || 0).setColWidths(e2.colWidths);
      }
      constructor(e2) {
        super(e2), this.__rowStriping = false, this.__frozenColumnCount = 0, this.__frozenRowCount = 0;
      }
      exportJSON() {
        return { ...super.exportJSON(), colWidths: this.getColWidths(), frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : void 0, frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : void 0, rowStriping: this.__rowStriping ? this.__rowStriping : void 0 };
      }
      extractWithChild(e2, t3, n2) {
        return "html" === n2;
      }
      getDOMSlot(e2) {
        const t3 = vt4(e2) ? e2 : e2.querySelector("table");
        return vt4(t3) || Fe2(229), super.getDOMSlot(e2).withElement(t3).withAfter(t3.querySelector("colgroup"));
      }
      createDOM(t3, n2) {
        const o2 = document.createElement("table");
        this.__style && (o2.style.cssText = this.__style);
        const r2 = document.createElement("colgroup");
        if (o2.appendChild(r2), setDOMUnmanaged2(r2), addClassNamesToElement2(o2, t3.theme.table), this.updateTableElement(null, o2, t3), sn2(n2)) {
          const n3 = document.createElement("div"), r3 = t3.theme.tableScrollableWrapper;
          return r3 ? addClassNamesToElement2(n3, r3) : n3.style.cssText = "overflow-x: auto;", n3.appendChild(o2), this.updateTableWrapper(null, n3, o2, t3), n3;
        }
        return o2;
      }
      updateTableWrapper(t3, n2, r2, l2) {
        this.__frozenColumnCount !== (t3 ? t3.__frozenColumnCount : 0) && function(t4, n3, r3, l3) {
          l3 > 0 ? (addClassNamesToElement2(t4, r3.theme.tableFrozenColumn), n3.setAttribute("data-lexical-frozen-column", "true")) : (removeClassNamesFromElement2(t4, r3.theme.tableFrozenColumn), n3.removeAttribute("data-lexical-frozen-column"));
        }(n2, r2, l2, this.__frozenColumnCount), this.__frozenRowCount !== (t3 ? t3.__frozenRowCount : 0) && function(t4, n3, r3, l3) {
          l3 > 0 ? (addClassNamesToElement2(t4, r3.theme.tableFrozenRow), n3.setAttribute("data-lexical-frozen-row", "true")) : (removeClassNamesFromElement2(t4, r3.theme.tableFrozenRow), n3.removeAttribute("data-lexical-frozen-row"));
        }(n2, r2, l2, this.__frozenRowCount);
      }
      updateTableElement(t3, n2, r2) {
        this.__style !== (t3 ? t3.__style : "") && (n2.style.cssText = this.__style), this.__rowStriping !== (!!t3 && t3.__rowStriping) && function(t4, n3, r3) {
          r3 ? (addClassNamesToElement2(t4, n3.theme.tableRowStriping), t4.setAttribute("data-lexical-row-striping", "true")) : (removeClassNamesFromElement2(t4, n3.theme.tableRowStriping), t4.removeAttribute("data-lexical-row-striping"));
        }(n2, r2, this.__rowStriping), function(e2, t4, n3, o2) {
          const r3 = e2.querySelector("colgroup");
          if (!r3) return;
          const l2 = [];
          for (let e3 = 0; e3 < n3; e3++) {
            const t5 = document.createElement("col"), n4 = o2 && o2[e3];
            n4 && (t5.style.width = `${n4}px`), l2.push(t5);
          }
          r3.replaceChildren(...l2);
        }(n2, 0, this.getColumnCount(), this.getColWidths()), rn2(n2, r2, this.getFormatType());
      }
      updateDOM(e2, t3, n2) {
        const o2 = this.getDOMSlot(t3).element;
        return t3 === o2 === sn2() || (isHTMLElement3(r2 = t3) && "DIV" === r2.nodeName && this.updateTableWrapper(e2, t3, o2, n2), this.updateTableElement(e2, o2, n2), false);
        var r2;
      }
      exportDOM(e2) {
        const t3 = super.exportDOM(e2), { element: n2 } = t3;
        return { after: (n3) => {
          if (t3.after && (n3 = t3.after(n3)), !vt4(n3) && isHTMLElement3(n3) && (n3 = n3.querySelector("table")), !vt4(n3)) return null;
          rn2(n3, e2._config, this.getFormatType());
          const [o2] = ht5(this, null, null), r2 = /* @__PURE__ */ new Map();
          for (const e3 of o2) for (const t4 of e3) {
            const e4 = t4.cell.getKey();
            r2.has(e4) || r2.set(e4, { colSpan: t4.cell.getColSpan(), startColumn: t4.startColumn });
          }
          const s2 = /* @__PURE__ */ new Set();
          for (const e3 of n3.querySelectorAll(":scope > tr > [data-temporary-table-cell-lexical-key]")) {
            const t4 = e3.getAttribute("data-temporary-table-cell-lexical-key");
            if (t4) {
              const n4 = r2.get(t4);
              if (e3.removeAttribute("data-temporary-table-cell-lexical-key"), n4) {
                r2.delete(t4);
                for (let e4 = 0; e4 < n4.colSpan; e4++) s2.add(e4 + n4.startColumn);
              }
            }
          }
          const i2 = n3.querySelector(":scope > colgroup");
          if (i2) {
            const e3 = Array.from(n3.querySelectorAll(":scope > colgroup > col")).filter((e4, t4) => s2.has(t4));
            i2.replaceChildren(...e3);
          }
          const c2 = n3.querySelectorAll(":scope > tr");
          if (c2.length > 0) {
            const e3 = document.createElement("tbody");
            for (const t4 of c2) e3.appendChild(t4);
            n3.append(e3);
          }
          return n3;
        }, element: !vt4(n2) && isHTMLElement3(n2) ? n2.querySelector("table") : n2 };
      }
      canBeEmpty() {
        return false;
      }
      isShadowRoot() {
        return true;
      }
      getCordsFromCellNode(e2, t3) {
        const { rows: n2, domRows: o2 } = t3;
        for (let t4 = 0; t4 < n2; t4++) {
          const n3 = o2[t4];
          if (null != n3) for (let o3 = 0; o3 < n3.length; o3++) {
            const r2 = n3[o3];
            if (null == r2) continue;
            const { elem: l2 } = r2, s2 = on2(this, l2);
            if (null !== s2 && e2.is(s2)) return { x: o3, y: t4 };
          }
        }
        throw new Error("Cell not found in table.");
      }
      getDOMCellFromCords(e2, t3, n2) {
        const { domRows: o2 } = n2, r2 = o2[t3];
        if (null == r2) return null;
        const l2 = r2[e2 < r2.length ? e2 : r2.length - 1];
        return null == l2 ? null : l2;
      }
      getDOMCellFromCordsOrThrow(e2, t3, n2) {
        const o2 = this.getDOMCellFromCords(e2, t3, n2);
        if (!o2) throw new Error("Cell not found at cords.");
        return o2;
      }
      getCellNodeFromCords(e2, t3, n2) {
        const o2 = this.getDOMCellFromCords(e2, t3, n2);
        if (null == o2) return null;
        const r2 = $getNearestNodeFromDOMNode2(o2.elem);
        return Re2(r2) ? r2 : null;
      }
      getCellNodeFromCordsOrThrow(e2, t3, n2) {
        const o2 = this.getCellNodeFromCords(e2, t3, n2);
        if (!o2) throw new Error("Node at cords not TableCellNode.");
        return o2;
      }
      getRowStriping() {
        return Boolean(this.getLatest().__rowStriping);
      }
      setRowStriping(e2) {
        const t3 = this.getWritable();
        return t3.__rowStriping = e2, t3;
      }
      setFrozenColumns(e2) {
        const t3 = this.getWritable();
        return t3.__frozenColumnCount = e2, t3;
      }
      getFrozenColumns() {
        return this.getLatest().__frozenColumnCount;
      }
      setFrozenRows(e2) {
        const t3 = this.getWritable();
        return t3.__frozenRowCount = e2, t3;
      }
      getFrozenRows() {
        return this.getLatest().__frozenRowCount;
      }
      canSelectBefore() {
        return true;
      }
      canIndent() {
        return false;
      }
      getColumnCount() {
        const e2 = this.getFirstChild();
        if (!e2) return 0;
        let t3 = 0;
        return e2.getChildren().forEach((e3) => {
          Re2(e3) && (t3 += e3.getColSpan());
        }), t3;
      }
    };
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/headless@0.32.1/node_modules/@lexical/headless/LexicalHeadless.dev.mjs
var LexicalHeadless_dev_exports = {};
__export(LexicalHeadless_dev_exports, {
  createHeadlessEditor: () => createHeadlessEditor
});
function createHeadlessEditor(editorConfig) {
  const editor = createEditor2(editorConfig);
  editor._headless = true;
  const unsupportedMethods = ["registerDecoratorListener", "registerRootListener", "registerMutationListener", "getRootElement", "setRootElement", "getElementByKey", "focus", "blur"];
  unsupportedMethods.forEach((method) => {
    editor[method] = () => {
      throw new Error(`${method} is not supported in headless mode`);
    };
  });
  return editor;
}
var init_LexicalHeadless_dev = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/headless@0.32.1/node_modules/@lexical/headless/LexicalHeadless.dev.mjs"() {
    await init_Lexical_node();
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/headless@0.32.1/node_modules/@lexical/headless/LexicalHeadless.prod.mjs
var LexicalHeadless_prod_exports = {};
__export(LexicalHeadless_prod_exports, {
  createHeadlessEditor: () => t2
});
function t2(t3) {
  const r2 = createEditor2(t3);
  r2._headless = true;
  return ["registerDecoratorListener", "registerRootListener", "registerMutationListener", "getRootElement", "setRootElement", "getElementByKey", "focus", "blur"].forEach((e2) => {
    r2[e2] = () => {
      throw new Error(`${e2} is not supported in headless mode`);
    };
  }), r2;
}
var init_LexicalHeadless_prod = __esm({
  async "../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/headless@0.32.1/node_modules/@lexical/headless/LexicalHeadless.prod.mjs"() {
    await init_Lexical_node();
  }
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/symbols.js
var CHANGED = Symbol("changed");
var CLASS_LIST = Symbol("classList");
var CUSTOM_ELEMENTS = Symbol("CustomElements");
var CONTENT = Symbol("content");
var DATASET = Symbol("dataset");
var DOCTYPE = Symbol("doctype");
var DOM_PARSER = Symbol("DOMParser");
var END = Symbol("end");
var EVENT_TARGET = Symbol("EventTarget");
var GLOBALS = Symbol("globals");
var IMAGE = Symbol("image");
var MIME = Symbol("mime");
var MUTATION_OBSERVER = Symbol("MutationObserver");
var NEXT = Symbol("next");
var OWNER_ELEMENT = Symbol("ownerElement");
var PREV = Symbol("prev");
var PRIVATE = Symbol("private");
var SHEET = Symbol("sheet");
var START = Symbol("start");
var STYLE = Symbol("style");
var UPGRADE = Symbol("upgrade");
var VALUE = Symbol("value");

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/htmlparser2@10.0.0/node_modules/htmlparser2/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DefaultHandler: () => DomHandler,
  DomHandler: () => DomHandler,
  DomUtils: () => esm_exports2,
  ElementType: () => esm_exports,
  Parser: () => Parser,
  QuoteType: () => QuoteType,
  Tokenizer: () => Tokenizer,
  createDocumentStream: () => createDocumentStream,
  createDomStream: () => createDomStream,
  getFeed: () => getFeed,
  parseDOM: () => parseDOM,
  parseDocument: () => parseDocument,
  parseFeed: () => parseFeed
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@6.0.0/node_modules/entities/dist/esm/generated/decode-data-html.js
var htmlDecodeTree = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c2) => c2.charCodeAt(0))
);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@6.0.0/node_modules/entities/dist/esm/generated/decode-data-xml.js
var xmlDecodeTree = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0))
);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@6.0.0/node_modules/entities/dist/esm/decode-codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@6.0.0/node_modules/entities/dist/esm/decode.js
var CharCodes;
(function(CharCodes4) {
  CharCodes4[CharCodes4["NUM"] = 35] = "NUM";
  CharCodes4[CharCodes4["SEMI"] = 59] = "SEMI";
  CharCodes4[CharCodes4["EQUALS"] = 61] = "EQUALS";
  CharCodes4[CharCodes4["ZERO"] = 48] = "ZERO";
  CharCodes4[CharCodes4["NINE"] = 57] = "NINE";
  CharCodes4[CharCodes4["LOWER_A"] = 97] = "LOWER_A";
  CharCodes4[CharCodes4["LOWER_F"] = 102] = "LOWER_F";
  CharCodes4[CharCodes4["LOWER_X"] = 120] = "LOWER_X";
  CharCodes4[CharCodes4["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes4[CharCodes4["UPPER_A"] = 65] = "UPPER_A";
  CharCodes4[CharCodes4["UPPER_F"] = 70] = "UPPER_F";
  CharCodes4[CharCodes4["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags3) {
  BinTrieFlags3[BinTrieFlags3["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState3) {
  EntityDecoderState3[EntityDecoderState3["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState3[EntityDecoderState3["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState3[EntityDecoderState3["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState3[EntityDecoderState3["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState3[EntityDecoderState3["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode3) {
  DecodingMode3[DecodingMode3["Legacy"] = 0] = "Legacy";
  DecodingMode3[DecodingMode3["Strict"] = 1] = "Strict";
  DecodingMode3[DecodingMode3["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(input, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (input.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(input, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(input, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(input, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(input, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(input, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(input, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(input, offset) {
    if (offset >= input.length) {
      return -1;
    }
    if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(input, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(input, offset);
  }
  addToNumericResult(input, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + Number.parseInt(input.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(input, offset) {
    const startIndex = offset;
    while (offset < input.length) {
      const char = input.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(input, startIndex, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(input, startIndex, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(input, offset) {
    const startIndex = offset;
    while (offset < input.length) {
      const char = input.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(input, startIndex, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(input, startIndex, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(input, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < input.length; offset++, this.excess++) {
      const char = input.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function determineBranch(decodeTree, current, nodeIndex, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
  }
  let lo2 = nodeIndex;
  let hi2 = lo2 + branchCount - 1;
  while (lo2 <= hi2) {
    const mid = lo2 + hi2 >>> 1;
    const midValue = decodeTree[mid];
    if (midValue < char) {
      lo2 = mid + 1;
    } else if (midValue > char) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/htmlparser2@10.0.0/node_modules/htmlparser2/dist/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes4) {
  CharCodes4[CharCodes4["Tab"] = 9] = "Tab";
  CharCodes4[CharCodes4["NewLine"] = 10] = "NewLine";
  CharCodes4[CharCodes4["FormFeed"] = 12] = "FormFeed";
  CharCodes4[CharCodes4["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes4[CharCodes4["Space"] = 32] = "Space";
  CharCodes4[CharCodes4["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes4[CharCodes4["Number"] = 35] = "Number";
  CharCodes4[CharCodes4["Amp"] = 38] = "Amp";
  CharCodes4[CharCodes4["SingleQuote"] = 39] = "SingleQuote";
  CharCodes4[CharCodes4["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes4[CharCodes4["Dash"] = 45] = "Dash";
  CharCodes4[CharCodes4["Slash"] = 47] = "Slash";
  CharCodes4[CharCodes4["Zero"] = 48] = "Zero";
  CharCodes4[CharCodes4["Nine"] = 57] = "Nine";
  CharCodes4[CharCodes4["Semi"] = 59] = "Semi";
  CharCodes4[CharCodes4["Lt"] = 60] = "Lt";
  CharCodes4[CharCodes4["Eq"] = 61] = "Eq";
  CharCodes4[CharCodes4["Gt"] = 62] = "Gt";
  CharCodes4[CharCodes4["Questionmark"] = 63] = "Questionmark";
  CharCodes4[CharCodes4["UpperA"] = 65] = "UpperA";
  CharCodes4[CharCodes4["LowerA"] = 97] = "LowerA";
  CharCodes4[CharCodes4["UpperF"] = 70] = "UpperF";
  CharCodes4[CharCodes4["LowerF"] = 102] = "LowerF";
  CharCodes4[CharCodes4["UpperZ"] = 90] = "UpperZ";
  CharCodes4[CharCodes4["LowerZ"] = 122] = "LowerZ";
  CharCodes4[CharCodes4["LowerX"] = 120] = "LowerX";
  CharCodes4[CharCodes4["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["BeforeSpecialT"] = 23] = "BeforeSpecialT";
  State2[State2["SpecialStartSequence"] = 24] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 25] = "InSpecialTag";
  State2[State2["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace(c2) {
  return c2 === CharCodes2.Space || c2 === CharCodes2.NewLine || c2 === CharCodes2.Tab || c2 === CharCodes2.FormFeed || c2 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes2.Slash || c2 === CharCodes2.Gt || isWhitespace(c2);
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerZ || c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperZ;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `</script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ]),
  // `</textarea`
  XmpEnd: new Uint8Array([60, 47, 120, 109, 112])
  // `</xmp`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new EntityDecoder(xmlMode ? xmlDecodeTree : htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c2) {
    if (c2 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c2)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c2 | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes2.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (this.xmlMode) {
        this.state = State.InTagName;
      } else if (lower === Sequences.ScriptEnd[2]) {
        this.state = State.BeforeSpecialS;
      } else if (lower === Sequences.TitleEnd[2] || lower === Sequences.XmpEnd[2]) {
        this.state = State.BeforeSpecialT;
      } else {
        this.state = State.InTagName;
      }
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) {
    } else if (c2 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = this.index;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes2.Slash || c2 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeSpecialT(c2) {
    const lower = c2 | 32;
    switch (lower) {
      case Sequences.TitleEnd[3]: {
        this.startSpecial(Sequences.TitleEnd, 4);
        break;
      }
      case Sequences.TextareaEnd[3]: {
        this.startSpecial(Sequences.TextareaEnd, 4);
        break;
      }
      case Sequences.XmpEnd[3]: {
        this.startSpecial(Sequences.XmpEnd, 4);
        break;
      }
      default: {
        this.state = State.InTagName;
        this.stateInTagName(c2);
      }
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
  }
  stateInEntity() {
    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
    if (length >= 0) {
      this.state = this.baseState;
      if (length === 0) {
        this.index = this.entityStart;
      }
    } else {
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.BeforeSpecialT: {
          this.stateBeforeSpecialT(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp, this.sectionStart);
    }
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/htmlparser2@10.0.0/node_modules/htmlparser2/dist/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options = {}) {
    var _a3, _b, _c, _d, _e2, _f;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== void 0 ? _a3 : this.htmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
    this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
    this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_f = (_e2 = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e2, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a3, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp, endIndex) {
    var _a3, _b;
    this.endIndex = endIndex - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, fromCodePoint(cp));
    this.startIndex = endIndex;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(name) {
    return this.htmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a3, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = this.htmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.unshift(name);
      if (this.htmlMode) {
        if (foreignContextElements.has(name)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a3, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a3 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a3, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a3, _b, _c, _d, _e2, _f, _g, _h;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.indexOf(name);
      if (pos !== -1) {
        for (let index = 0; index <= pos; index++) {
          const element = this.stack.shift();
          (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, element, index !== pos);
        }
      } else if (this.htmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name === "br") {
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
      (_f = (_e2 = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e2, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a3, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[0] === name) {
      (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, name, !isOpenImplied);
      this.stack.shift();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a3, _b;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a3, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a3, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a3, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a3, _b, _c, _d, _e2, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b = (_a3 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a3);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e2 = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e2);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a3, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = 0; index < this.stack.length; index++) {
        this.cbs.onclosetag(this.stack[index], true);
      }
    }
    (_b = (_a3 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a3);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a3, _b, _c, _d;
    (_b = (_a3 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a3);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domelementtype@2.3.0/node_modules/domelementtype/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CDATA: () => CDATA,
  Comment: () => Comment,
  Directive: () => Directive,
  Doctype: () => Doctype,
  ElementType: () => ElementType,
  Root: () => Root,
  Script: () => Script,
  Style: () => Style,
  Tag: () => Tag,
  Text: () => Text2,
  isTag: () => isTag
});
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text2 = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domhandler@5.0.3/node_modules/domhandler/lib/esm/node.js
var Node2 = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node2 {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text3 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node2 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a3;
    return (_a3 = this.children[0]) !== null && _a3 !== void 0 ? _a3 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a3, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a3 = this["x-attribsNamespace"]) === null || _a3 === void 0 ? void 0 : _a3[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text3(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i2 = 1; i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domhandler@5.0.3/node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text3(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text3("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling2 = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling2) {
      node.prev = previousSibling2;
      previousSibling2.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByClassName: () => getElementsByClassName,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c2) => c2.charCodeAt(0))
);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0))
);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/decode_codepoint.js
var _a2;
var decodeMap2 = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint2(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap2.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/decode.js
var CharCodes3;
(function(CharCodes4) {
  CharCodes4[CharCodes4["NUM"] = 35] = "NUM";
  CharCodes4[CharCodes4["SEMI"] = 59] = "SEMI";
  CharCodes4[CharCodes4["EQUALS"] = 61] = "EQUALS";
  CharCodes4[CharCodes4["ZERO"] = 48] = "ZERO";
  CharCodes4[CharCodes4["NINE"] = 57] = "NINE";
  CharCodes4[CharCodes4["LOWER_A"] = 97] = "LOWER_A";
  CharCodes4[CharCodes4["LOWER_F"] = 102] = "LOWER_F";
  CharCodes4[CharCodes4["LOWER_X"] = 120] = "LOWER_X";
  CharCodes4[CharCodes4["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes4[CharCodes4["UPPER_A"] = 65] = "UPPER_A";
  CharCodes4[CharCodes4["UPPER_F"] = 70] = "UPPER_F";
  CharCodes4[CharCodes4["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes3 || (CharCodes3 = {}));
var TO_LOWER_BIT2 = 32;
var BinTrieFlags2;
(function(BinTrieFlags3) {
  BinTrieFlags3[BinTrieFlags3["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags2 || (BinTrieFlags2 = {}));
function isNumber2(code) {
  return code >= CharCodes3.ZERO && code <= CharCodes3.NINE;
}
function isHexadecimalCharacter2(code) {
  return code >= CharCodes3.UPPER_A && code <= CharCodes3.UPPER_F || code >= CharCodes3.LOWER_A && code <= CharCodes3.LOWER_F;
}
function isAsciiAlphaNumeric2(code) {
  return code >= CharCodes3.UPPER_A && code <= CharCodes3.UPPER_Z || code >= CharCodes3.LOWER_A && code <= CharCodes3.LOWER_Z || isNumber2(code);
}
function isEntityInAttributeInvalidEnd2(code) {
  return code === CharCodes3.EQUALS || isAsciiAlphaNumeric2(code);
}
var EntityDecoderState2;
(function(EntityDecoderState3) {
  EntityDecoderState3[EntityDecoderState3["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState3[EntityDecoderState3["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState3[EntityDecoderState3["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState3[EntityDecoderState3["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState3[EntityDecoderState3["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState2 || (EntityDecoderState2 = {}));
var DecodingMode2;
(function(DecodingMode3) {
  DecodingMode3[DecodingMode3["Legacy"] = 0] = "Legacy";
  DecodingMode3[DecodingMode3["Strict"] = 1] = "Strict";
  DecodingMode3[DecodingMode3["Attribute"] = 2] = "Attribute";
})(DecodingMode2 || (DecodingMode2 = {}));
var EntityDecoder2 = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState2.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode2.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState2.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState2.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes3.NUM) {
          this.state = EntityDecoderState2.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState2.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState2.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState2.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState2.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState2.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT2) === CharCodes3.LOWER_X) {
      this.state = EntityDecoderState2.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState2.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber2(char) || isHexadecimalCharacter2(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber2(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes3.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode2.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint2(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes3.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch2(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode2.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes3.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode2.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags2.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags2.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState2.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode2.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState2.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState2.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState2.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState2.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder2(decodeTree, (str) => ret += fromCodePoint2(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch2(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags2.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags2.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo2 = nodeIdx;
  let hi2 = lo2 + branchCount - 1;
  while (lo2 <= hi2) {
    const mid = lo2 + hi2 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo2 = mid + 1;
    } else if (midVal > char) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c2, index) => (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i2 = match.index;
    const char = str.charCodeAt(i2);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i2) + next;
      lastIdx = i2 + 1;
    } else {
      ret += `${str.substring(lastIdx, i2)}&#x${getCodePoint(str, i2).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map) {
  return function escape3(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/entities@4.5.0/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a3;
  if (!attributes2)
    return;
  const encode = ((_a3 = opts.encodeEntities) !== null && _a3 !== void 0 ? _a3 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key2) => {
    var _a4, _b;
    const value = (_a4 = attributes2[key2]) !== null && _a4 !== void 0 ? _a4 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return `${key2}="${encode(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode(nodes[i2], options);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text2:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a3;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a3 = elementNames.get(elem.name)) !== null && _a3 !== void 0 ? _a3 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a3;
  let data = elem.data || "";
  if (((_a3 = opts.encodeEntities) !== null && _a3 !== void 0 ? _a3 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue(elem, name) {
  var _a3;
  return (_a3 = elem.attribs) === null || _a3 === void 0 ? void 0 : _a3[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag2(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag2(prev))
    ({ prev } = prev);
  return prev;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/querying.js
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
  for (let i2 = 0; i2 < searchedNodes.length; i2++) {
    const node = searchedNodes[i2];
    if (isTag2(node) && test(node)) {
      return node;
    }
    if (recurse && hasChildren(node) && node.children.length > 0) {
      const found = findOne(test, node.children, true);
      if (found)
        return found;
    }
  }
  return null;
}
function existsOne(test, nodes) {
  return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => isTag2(node) && test(node) || hasChildren(node) && existsOne(test, node.children));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (isTag2(elem) && test(elem))
      result.push(elem);
    if (hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a2, b3) {
  return (elem) => a2(elem) || b3(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key2) => {
    const value = options[key2];
    return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName19, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName19), nodes, recurse, limit);
}
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
  return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i2, arr) => !arr.includes(node, i2 + 1));
  nodes.sort((a2, b3) => {
    const relative = compareDocumentPosition(a2, b3);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/domutils@3.2.2/node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a3;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a4;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a4 = getOneElement("link", children)) === null || _a4 === void 0 ? void 0 : _a4.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a3 = getOneElement("link", childs)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a3, _b;
  const childs = (_b = (_a3 = getOneElement("channel", feedRoot.children)) === null || _a3 === void 0 ? void 0 : _a3.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch("pubDate", children) || fetch("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName19, node) {
  return getElementsByTagName(tagName19, node, true, 1)[0];
}
function fetch(tagName19, where, recurse = false) {
  return textContent(getElementsByTagName(tagName19, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName19, where, recurse = false) {
  const val = fetch(tagName19, where, recurse);
  if (val)
    obj[prop2] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/htmlparser2@10.0.0/node_modules/htmlparser2/dist/esm/index.js
function parseDocument(data, options) {
  const handler4 = new DomHandler(void 0, options);
  new Parser(handler4, options).end(data);
  return handler4.root;
}
function parseDOM(data, options) {
  return parseDocument(data, options).children;
}
function createDocumentStream(callback, options, elementCallback) {
  const handler4 = new DomHandler((error) => callback(error, handler4.root), options, elementCallback);
  return new Parser(handler4, options);
}
function createDomStream(callback, options, elementCallback) {
  const handler4 = new DomHandler(callback, options, elementCallback);
  return new Parser(handler4, options);
}
var parseFeedDefaultOptions = { xmlMode: true };
function parseFeed(feed, options = parseFeedDefaultOptions) {
  return getFeed(parseDOM(feed, options));
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/constants.js
var NODE_END = -1;
var ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = 2;
var TEXT_NODE = 3;
var CDATA_SECTION_NODE = 4;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = 11;
var BLOCK_ELEMENTS = /* @__PURE__ */ new Set(["ARTICLE", "ASIDE", "BLOCKQUOTE", "BODY", "BR", "BUTTON", "CANVAS", "CAPTION", "COL", "COLGROUP", "DD", "DIV", "DL", "DT", "EMBED", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "LI", "UL", "OL", "P"]);
var SHOW_ALL = -1;
var SHOW_ELEMENT = 1;
var SHOW_TEXT = 4;
var SHOW_CDATA_SECTION = 8;
var SHOW_COMMENT = 128;
var DOCUMENT_POSITION_DISCONNECTED = 1;
var DOCUMENT_POSITION_PRECEDING = 2;
var DOCUMENT_POSITION_FOLLOWING = 4;
var DOCUMENT_POSITION_CONTAINS = 8;
var DOCUMENT_POSITION_CONTAINED_BY = 16;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/object.js
var {
  assign,
  create,
  defineProperties,
  entries,
  getOwnPropertyDescriptors,
  keys,
  setPrototypeOf
} = Object;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/utils.js
var $String = String;
var getEnd = (node) => node.nodeType === ELEMENT_NODE ? node[END] : node;
var ignoreCase = ({ ownerDocument }) => ownerDocument[MIME].ignoreCase;
var knownAdjacent = (prev, next) => {
  prev[NEXT] = next;
  next[PREV] = prev;
};
var knownBoundaries = (prev, current, next) => {
  knownAdjacent(prev, current);
  knownAdjacent(getEnd(current), next);
};
var knownSegment = (prev, start, end, next) => {
  knownAdjacent(prev, start);
  knownAdjacent(getEnd(end), next);
};
var knownSiblings = (prev, current, next) => {
  knownAdjacent(prev, current);
  knownAdjacent(current, next);
};
var localCase = ({ localName, ownerDocument }) => {
  return ownerDocument[MIME].ignoreCase ? localName.toUpperCase() : localName;
};
var setAdjacent = (prev, next) => {
  if (prev)
    prev[NEXT] = next;
  if (next)
    next[PREV] = prev;
};
var htmlToFragment = (ownerDocument, html) => {
  const fragment = ownerDocument.createDocumentFragment();
  const elem = ownerDocument.createElement("");
  elem.innerHTML = html;
  const { firstChild, lastChild } = elem;
  if (firstChild) {
    knownSegment(fragment, firstChild, lastChild, fragment[END]);
    let child = firstChild;
    do {
      child.parentNode = fragment;
    } while (child !== lastChild && (child = getEnd(child)[NEXT]));
  }
  return fragment;
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/shadow-roots.js
var shadowRoots = /* @__PURE__ */ new WeakMap();

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/custom-element-registry.js
var reactive = false;
var Classes = /* @__PURE__ */ new WeakMap();
var customElements = /* @__PURE__ */ new WeakMap();
var attributeChangedCallback = (element, attributeName, oldValue, newValue) => {
  if (reactive && customElements.has(element) && element.attributeChangedCallback && element.constructor.observedAttributes.includes(attributeName)) {
    element.attributeChangedCallback(attributeName, oldValue, newValue);
  }
};
var createTrigger = (method, isConnected2) => (element) => {
  if (customElements.has(element)) {
    const info = customElements.get(element);
    if (info.connected !== isConnected2 && element.isConnected === isConnected2) {
      info.connected = isConnected2;
      if (method in element)
        element[method]();
    }
  }
};
var triggerConnected = createTrigger("connectedCallback", true);
var connectedCallback = (element) => {
  if (reactive) {
    triggerConnected(element);
    if (shadowRoots.has(element))
      element = shadowRoots.get(element).shadowRoot;
    let { [NEXT]: next, [END]: end } = element;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE)
        triggerConnected(next);
      next = next[NEXT];
    }
  }
};
var triggerDisconnected = createTrigger("disconnectedCallback", false);
var disconnectedCallback = (element) => {
  if (reactive) {
    triggerDisconnected(element);
    if (shadowRoots.has(element))
      element = shadowRoots.get(element).shadowRoot;
    let { [NEXT]: next, [END]: end } = element;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE)
        triggerDisconnected(next);
      next = next[NEXT];
    }
  }
};
var CustomElementRegistry = class {
  /**
   * @param {Document} ownerDocument
   */
  constructor(ownerDocument) {
    this.ownerDocument = ownerDocument;
    this.registry = /* @__PURE__ */ new Map();
    this.waiting = /* @__PURE__ */ new Map();
    this.active = false;
  }
  /**
   * @param {string} localName the custom element definition name
   * @param {Function} Class the custom element **Class** definition
   * @param {object?} options the optional object with an `extends` property
   */
  define(localName, Class, options = {}) {
    const { ownerDocument, registry, waiting } = this;
    if (registry.has(localName))
      throw new Error("unable to redefine " + localName);
    if (Classes.has(Class))
      throw new Error("unable to redefine the same class: " + Class);
    this.active = reactive = true;
    const { extends: extend } = options;
    Classes.set(Class, {
      ownerDocument,
      options: { is: extend ? localName : "" },
      localName: extend || localName
    });
    const check = extend ? (element) => {
      return element.localName === extend && element.getAttribute("is") === localName;
    } : (element) => element.localName === localName;
    registry.set(localName, { Class, check });
    if (waiting.has(localName)) {
      for (const resolve of waiting.get(localName))
        resolve(Class);
      waiting.delete(localName);
    }
    ownerDocument.querySelectorAll(
      extend ? `${extend}[is="${localName}"]` : localName
    ).forEach(this.upgrade, this);
  }
  /**
   * @param {Element} element
   */
  upgrade(element) {
    if (customElements.has(element))
      return;
    const { ownerDocument, registry } = this;
    const ce2 = element.getAttribute("is") || element.localName;
    if (registry.has(ce2)) {
      const { Class, check } = registry.get(ce2);
      if (check(element)) {
        const { attributes: attributes2, isConnected: isConnected2 } = element;
        for (const attr of attributes2)
          element.removeAttributeNode(attr);
        const values = entries(element);
        for (const [key2] of values)
          delete element[key2];
        setPrototypeOf(element, Class.prototype);
        ownerDocument[UPGRADE] = { element, values };
        new Class(ownerDocument, ce2);
        customElements.set(element, { connected: isConnected2 });
        for (const attr of attributes2)
          element.setAttributeNode(attr);
        if (isConnected2 && element.connectedCallback)
          element.connectedCallback();
      }
    }
  }
  /**
   * @param {string} localName the custom element definition name
   */
  whenDefined(localName) {
    const { registry, waiting } = this;
    return new Promise((resolve) => {
      if (registry.has(localName))
        resolve(registry.get(localName).Class);
      else {
        if (!waiting.has(localName))
          waiting.set(localName, []);
        waiting.get(localName).push(resolve);
      }
    });
  }
  /**
   * @param {string} localName the custom element definition name
   * @returns {Function?} the custom element **Class**, if any
   */
  get(localName) {
    const info = this.registry.get(localName);
    return info && info.Class;
  }
  /**
   * @param {Function} Class **Class** of custom element
   * @returns {string?} found tag name or null
   */
  getName(Class) {
    if (Classes.has(Class)) {
      const { localName } = Classes.get(Class);
      return localName;
    }
    return null;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/parse-from-string.js
var { Parser: Parser2 } = esm_exports3;
var notParsing = true;
var append2 = (self, node, active) => {
  const end = self[END];
  node.parentNode = self;
  knownBoundaries(end[PREV], node, end);
  if (active && node.nodeType === ELEMENT_NODE)
    connectedCallback(node);
  return node;
};
var attribute = (element, end, attribute2, value, active) => {
  attribute2[VALUE] = value;
  attribute2.ownerElement = element;
  knownSiblings(end[PREV], attribute2, end);
  if (attribute2.name === "class")
    element.className = value;
  if (active)
    attributeChangedCallback(element, attribute2.name, null, value);
};
var parseFromString = (document2, isHTML, markupLanguage) => {
  const { active, registry } = document2[CUSTOM_ELEMENTS];
  let node = document2;
  let ownerSVGElement = null;
  let parsingCData = false;
  notParsing = false;
  const content = new Parser2({
    // <!DOCTYPE ...>
    onprocessinginstruction(name, data) {
      if (name.toLowerCase() === "!doctype")
        document2.doctype = data.slice(name.length).trim();
    },
    // <tagName>
    onopentag(name, attributes2) {
      let create3 = true;
      if (isHTML) {
        if (ownerSVGElement) {
          node = append2(node, document2.createElementNS(SVG_NAMESPACE, name), active);
          node.ownerSVGElement = ownerSVGElement;
          create3 = false;
        } else if (name === "svg" || name === "SVG") {
          ownerSVGElement = document2.createElementNS(SVG_NAMESPACE, name);
          node = append2(node, ownerSVGElement, active);
          create3 = false;
        } else if (active) {
          const ce2 = name.includes("-") ? name : attributes2.is || "";
          if (ce2 && registry.has(ce2)) {
            const { Class } = registry.get(ce2);
            node = append2(node, new Class(), active);
            delete attributes2.is;
            create3 = false;
          }
        }
      }
      if (create3)
        node = append2(node, document2.createElement(name), false);
      let end = node[END];
      for (const name2 of keys(attributes2))
        attribute(node, end, document2.createAttribute(name2), attributes2[name2], active);
    },
    // #text, #comment
    oncomment(data) {
      append2(node, document2.createComment(data), active);
    },
    ontext(text) {
      if (parsingCData) {
        append2(node, document2.createCDATASection(text), active);
      } else {
        append2(node, document2.createTextNode(text), active);
      }
    },
    // #cdata
    oncdatastart() {
      parsingCData = true;
    },
    oncdataend() {
      parsingCData = false;
    },
    // </tagName>
    onclosetag() {
      if (isHTML && node === ownerSVGElement)
        ownerSVGElement = null;
      node = node.parentNode;
    }
  }, {
    lowerCaseAttributeNames: false,
    decodeEntities: true,
    xmlMode: !isHTML
  });
  content.write(markupLanguage);
  content.end();
  notParsing = true;
  return document2;
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/register-html-class.js
var htmlClasses = /* @__PURE__ */ new Map();
var registerHTMLClass = (names, Class) => {
  for (const name of [].concat(names)) {
    htmlClasses.set(name, Class);
    htmlClasses.set(name.toUpperCase(), Class);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/document.js
var import_perf_hooks = __toESM(require_perf_hooks(), 1);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/jsdon.js
var loopSegment = ({ [NEXT]: next, [END]: end }, json) => {
  while (next !== end) {
    switch (next.nodeType) {
      case ATTRIBUTE_NODE:
        attrAsJSON(next, json);
        break;
      case TEXT_NODE:
      case COMMENT_NODE:
      case CDATA_SECTION_NODE:
        characterDataAsJSON(next, json);
        break;
      case ELEMENT_NODE:
        elementAsJSON(next, json);
        next = getEnd(next);
        break;
      case DOCUMENT_TYPE_NODE:
        documentTypeAsJSON(next, json);
        break;
    }
    next = next[NEXT];
  }
  const last = json.length - 1;
  const value = json[last];
  if (typeof value === "number" && value < 0)
    json[last] += NODE_END;
  else
    json.push(NODE_END);
};
var attrAsJSON = (attr, json) => {
  json.push(ATTRIBUTE_NODE, attr.name);
  const value = attr[VALUE].trim();
  if (value)
    json.push(value);
};
var characterDataAsJSON = (node, json) => {
  const value = node[VALUE];
  if (value.trim())
    json.push(node.nodeType, value);
};
var nonElementAsJSON = (node, json) => {
  json.push(node.nodeType);
  loopSegment(node, json);
};
var documentTypeAsJSON = ({ name, publicId, systemId }, json) => {
  json.push(DOCUMENT_TYPE_NODE, name);
  if (publicId)
    json.push(publicId);
  if (systemId)
    json.push(systemId);
};
var elementAsJSON = (element, json) => {
  json.push(ELEMENT_NODE, element.localName);
  loopSegment(element, json);
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/mutation-observer.js
var createRecord = (type, target, element, addedNodes, removedNodes, attributeName, oldValue) => ({
  type,
  target,
  addedNodes,
  removedNodes,
  attributeName,
  oldValue,
  previousSibling: element?.previousSibling || null,
  nextSibling: element?.nextSibling || null
});
var queueAttribute = (observer, target, attributeName, attributeFilter, attributeOldValue, oldValue) => {
  if (!attributeFilter || attributeFilter.includes(attributeName)) {
    const { callback, records, scheduled } = observer;
    records.push(createRecord(
      "attributes",
      target,
      null,
      [],
      [],
      attributeName,
      attributeOldValue ? oldValue : void 0
    ));
    if (!scheduled) {
      observer.scheduled = true;
      Promise.resolve().then(() => {
        observer.scheduled = false;
        callback(records.splice(0), observer);
      });
    }
  }
};
var attributeChangedCallback2 = (element, attributeName, oldValue) => {
  const { ownerDocument } = element;
  const { active, observers } = ownerDocument[MUTATION_OBSERVER];
  if (active) {
    for (const observer of observers) {
      for (const [
        target,
        {
          childList,
          subtree,
          attributes: attributes2,
          attributeFilter,
          attributeOldValue
        }
      ] of observer.nodes) {
        if (childList) {
          if (subtree && (target === ownerDocument || target.contains(element)) || !subtree && target.children.includes(element)) {
            queueAttribute(
              observer,
              element,
              attributeName,
              attributeFilter,
              attributeOldValue,
              oldValue
            );
            break;
          }
        } else if (attributes2 && target === element) {
          queueAttribute(
            observer,
            element,
            attributeName,
            attributeFilter,
            attributeOldValue,
            oldValue
          );
          break;
        }
      }
    }
  }
};
var moCallback = (element, parentNode) => {
  const { ownerDocument } = element;
  const { active, observers } = ownerDocument[MUTATION_OBSERVER];
  if (active) {
    for (const observer of observers) {
      for (const [target, { subtree, childList, characterData }] of observer.nodes) {
        if (childList) {
          if (parentNode && (target === parentNode || /* c8 ignore next */
          subtree && target.contains(parentNode)) || !parentNode && (subtree && (target === ownerDocument || /* c8 ignore next */
          target.contains(element)) || !subtree && target[characterData ? "childNodes" : "children"].includes(element))) {
            const { callback, records, scheduled } = observer;
            records.push(createRecord(
              "childList",
              target,
              element,
              parentNode ? [] : [element],
              parentNode ? [element] : []
            ));
            if (!scheduled) {
              observer.scheduled = true;
              Promise.resolve().then(() => {
                observer.scheduled = false;
                callback(records.splice(0), observer);
              });
            }
            break;
          }
        }
      }
    }
  }
};
var MutationObserverClass = class {
  constructor(ownerDocument) {
    const observers = /* @__PURE__ */ new Set();
    this.observers = observers;
    this.active = false;
    this.class = class MutationObserver {
      constructor(callback) {
        this.callback = callback;
        this.nodes = /* @__PURE__ */ new Map();
        this.records = [];
        this.scheduled = false;
      }
      disconnect() {
        this.records.splice(0);
        this.nodes.clear();
        observers.delete(this);
        ownerDocument[MUTATION_OBSERVER].active = !!observers.size;
      }
      /**
       * @param {Element} target
       * @param {MutationObserverInit} options
       */
      observe(target, options = {
        subtree: false,
        childList: false,
        attributes: false,
        attributeFilter: null,
        attributeOldValue: false,
        characterData: false
        // TODO: not implemented yet
        // characterDataOldValue: false
      }) {
        if ("attributeOldValue" in options || "attributeFilter" in options)
          options.attributes = true;
        options.childList = !!options.childList;
        options.subtree = !!options.subtree;
        this.nodes.set(target, options);
        observers.add(this);
        ownerDocument[MUTATION_OBSERVER].active = true;
      }
      /**
       * @returns {MutationRecord[]}
       */
      takeRecords() {
        return this.records.splice(0);
      }
    };
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/attributes.js
var emptyAttributes = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "class",
  "contenteditable",
  "controls",
  "default",
  "defer",
  "disabled",
  "draggable",
  "formnovalidate",
  "hidden",
  "id",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "style",
  "truespeed"
]);
var setAttribute = (element, attribute2) => {
  const { [VALUE]: value, name } = attribute2;
  attribute2.ownerElement = element;
  knownSiblings(element, attribute2, element[NEXT]);
  if (name === "class")
    element.className = value;
  attributeChangedCallback2(element, name, null);
  attributeChangedCallback(element, name, null, value);
};
var removeAttribute = (element, attribute2) => {
  const { [VALUE]: value, name } = attribute2;
  knownAdjacent(attribute2[PREV], attribute2[NEXT]);
  attribute2.ownerElement = attribute2[PREV] = attribute2[NEXT] = null;
  if (name === "class")
    element[CLASS_LIST] = null;
  attributeChangedCallback2(element, name, value);
  attributeChangedCallback(element, name, value, null);
};
var booleanAttribute = {
  get(element, name) {
    return element.hasAttribute(name);
  },
  set(element, name, value) {
    if (value)
      element.setAttribute(name, "");
    else
      element.removeAttribute(name);
  }
};
var numericAttribute = {
  get(element, name) {
    return parseFloat(element.getAttribute(name) || 0);
  },
  set(element, name, value) {
    element.setAttribute(name, value);
  }
};
var stringAttribute = {
  get(element, name) {
    return element.getAttribute(name) || "";
  },
  set(element, name, value) {
    element.setAttribute(name, value);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/event-target.js
var wm = /* @__PURE__ */ new WeakMap();
function dispatch(event, listener) {
  if (typeof listener === "function")
    listener.call(event.target, event);
  else
    listener.handleEvent(event);
  return event._stopImmediatePropagationFlag;
}
function invokeListeners({ currentTarget, target }) {
  const map = wm.get(currentTarget);
  if (map && map.has(this.type)) {
    const listeners = map.get(this.type);
    if (currentTarget === target) {
      this.eventPhase = this.AT_TARGET;
    } else {
      this.eventPhase = this.BUBBLING_PHASE;
    }
    this.currentTarget = currentTarget;
    this.target = target;
    for (const [listener, options] of listeners) {
      if (options && options.once)
        listeners.delete(listener);
      if (dispatch(this, listener))
        break;
    }
    delete this.currentTarget;
    delete this.target;
    return this.cancelBubble;
  }
}
var DOMEventTarget = class {
  constructor() {
    wm.set(this, /* @__PURE__ */ new Map());
  }
  /**
   * @protected
   */
  _getParent() {
    return null;
  }
  addEventListener(type, listener, options) {
    const map = wm.get(this);
    if (!map.has(type))
      map.set(type, /* @__PURE__ */ new Map());
    map.get(type).set(listener, options);
  }
  removeEventListener(type, listener) {
    const map = wm.get(this);
    if (map.has(type)) {
      const listeners = map.get(type);
      if (listeners.delete(listener) && !listeners.size)
        map.delete(type);
    }
  }
  dispatchEvent(event) {
    let node = this;
    event.eventPhase = event.CAPTURING_PHASE;
    while (node) {
      if (node.dispatchEvent)
        event._path.push({ currentTarget: node, target: this });
      node = event.bubbles && node._getParent && node._getParent();
    }
    event._path.some(invokeListeners, event);
    event._path = [];
    event.eventPhase = event.NONE;
    return !event.defaultPrevented;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/node-list.js
var NodeList = class extends Array {
  item(i2) {
    return i2 < this.length ? this[i2] : null;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/node.js
var getParentNodeCount = ({ parentNode }) => {
  let count = 0;
  while (parentNode) {
    count++;
    parentNode = parentNode.parentNode;
  }
  return count;
};
var Node3 = class extends DOMEventTarget {
  static get ELEMENT_NODE() {
    return ELEMENT_NODE;
  }
  static get ATTRIBUTE_NODE() {
    return ATTRIBUTE_NODE;
  }
  static get TEXT_NODE() {
    return TEXT_NODE;
  }
  static get CDATA_SECTION_NODE() {
    return CDATA_SECTION_NODE;
  }
  static get COMMENT_NODE() {
    return COMMENT_NODE;
  }
  static get DOCUMENT_NODE() {
    return DOCUMENT_NODE;
  }
  static get DOCUMENT_FRAGMENT_NODE() {
    return DOCUMENT_FRAGMENT_NODE;
  }
  static get DOCUMENT_TYPE_NODE() {
    return DOCUMENT_TYPE_NODE;
  }
  constructor(ownerDocument, localName, nodeType) {
    super();
    this.ownerDocument = ownerDocument;
    this.localName = localName;
    this.nodeType = nodeType;
    this.parentNode = null;
    this[NEXT] = null;
    this[PREV] = null;
  }
  get ELEMENT_NODE() {
    return ELEMENT_NODE;
  }
  get ATTRIBUTE_NODE() {
    return ATTRIBUTE_NODE;
  }
  get TEXT_NODE() {
    return TEXT_NODE;
  }
  get CDATA_SECTION_NODE() {
    return CDATA_SECTION_NODE;
  }
  get COMMENT_NODE() {
    return COMMENT_NODE;
  }
  get DOCUMENT_NODE() {
    return DOCUMENT_NODE;
  }
  get DOCUMENT_FRAGMENT_NODE() {
    return DOCUMENT_FRAGMENT_NODE;
  }
  get DOCUMENT_TYPE_NODE() {
    return DOCUMENT_TYPE_NODE;
  }
  get baseURI() {
    const ownerDocument = this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument;
    if (ownerDocument) {
      const base = ownerDocument.querySelector("base");
      if (base)
        return base.getAttribute("href");
      const { location } = ownerDocument.defaultView;
      if (location)
        return location.href;
    }
    return null;
  }
  /* c8 ignore start */
  // mixin: node
  get isConnected() {
    return false;
  }
  get nodeName() {
    return this.localName;
  }
  get parentElement() {
    return null;
  }
  get previousSibling() {
    return null;
  }
  get previousElementSibling() {
    return null;
  }
  get nextSibling() {
    return null;
  }
  get nextElementSibling() {
    return null;
  }
  get childNodes() {
    return new NodeList();
  }
  get firstChild() {
    return null;
  }
  get lastChild() {
    return null;
  }
  // default values
  get nodeValue() {
    return null;
  }
  set nodeValue(value) {
  }
  get textContent() {
    return null;
  }
  set textContent(value) {
  }
  normalize() {
  }
  cloneNode() {
    return null;
  }
  contains() {
    return false;
  }
  /**
   * Inserts a node before a reference node as a child of this parent node.
   * @param {Node} newNode The node to be inserted.
   * @param {Node} referenceNode The node before which newNode is inserted. If this is null, then newNode is inserted at the end of node's child nodes.
   * @returns The added child
   */
  // eslint-disable-next-line no-unused-vars
  insertBefore(newNode, referenceNode) {
    return newNode;
  }
  /**
   * Adds a node to the end of the list of children of this node.
   * @param {Node} child The node to append to the given parent node.
   * @returns The appended child.
   */
  appendChild(child) {
    return child;
  }
  /**
   * Replaces a child node within this node
   * @param {Node} newChild The new node to replace oldChild.
   * @param {Node} oldChild The child to be replaced.
   * @returns The replaced Node. This is the same node as oldChild.
   */
  replaceChild(newChild, oldChild) {
    return oldChild;
  }
  /**
   * Removes a child node from the DOM.
   * @param {Node} child A Node that is the child node to be removed from the DOM.
   * @returns The removed node.
   */
  removeChild(child) {
    return child;
  }
  toString() {
    return "";
  }
  /* c8 ignore stop */
  hasChildNodes() {
    return !!this.lastChild;
  }
  isSameNode(node) {
    return this === node;
  }
  // TODO: attributes?
  compareDocumentPosition(target) {
    let result = 0;
    if (this !== target) {
      let self = getParentNodeCount(this);
      let other = getParentNodeCount(target);
      if (self < other) {
        result += DOCUMENT_POSITION_FOLLOWING;
        if (this.contains(target))
          result += DOCUMENT_POSITION_CONTAINED_BY;
      } else if (other < self) {
        result += DOCUMENT_POSITION_PRECEDING;
        if (target.contains(this))
          result += DOCUMENT_POSITION_CONTAINS;
      } else if (self && other) {
        const { childNodes } = this.parentNode;
        if (childNodes.indexOf(this) < childNodes.indexOf(target))
          result += DOCUMENT_POSITION_FOLLOWING;
        else
          result += DOCUMENT_POSITION_PRECEDING;
      }
      if (!self || !other) {
        result += DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
        result += DOCUMENT_POSITION_DISCONNECTED;
      }
    }
    return result;
  }
  isEqualNode(node) {
    if (this === node)
      return true;
    if (this.nodeType === node.nodeType) {
      switch (this.nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE: {
          const aNodes = this.childNodes;
          const bNodes = node.childNodes;
          return aNodes.length === bNodes.length && aNodes.every((node2, i2) => node2.isEqualNode(bNodes[i2]));
        }
      }
      return this.toString() === node.toString();
    }
    return false;
  }
  /**
   * @protected
   */
  _getParent() {
    return this.parentNode;
  }
  /**
   * Calling it on an element inside a standard web page will return an HTMLDocument object representing the entire page (or <iframe>).
   * Calling it on an element inside a shadow DOM will return the associated ShadowRoot.
   * @return {ShadowRoot | HTMLDocument}
   */
  getRootNode() {
    let root = this;
    while (root.parentNode)
      root = root.parentNode;
    return root;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/text-escaper.js
var { replace } = "";
var ca = /[<>&\xA0]/g;
var esca = {
  "\xA0": "&#160;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
var pe = (m4) => esca[m4];
var escape2 = (es2) => replace.call(es2, ca, pe);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/attr.js
var QUOTE = /"/g;
var Attr = class _Attr extends Node3 {
  constructor(ownerDocument, name, value = "") {
    super(ownerDocument, name, ATTRIBUTE_NODE);
    this.ownerElement = null;
    this.name = $String(name);
    this[VALUE] = $String(value);
    this[CHANGED] = false;
  }
  get value() {
    return this[VALUE];
  }
  set value(newValue) {
    const { [VALUE]: oldValue, name, ownerElement } = this;
    this[VALUE] = $String(newValue);
    this[CHANGED] = true;
    if (ownerElement) {
      attributeChangedCallback2(ownerElement, name, oldValue);
      attributeChangedCallback(ownerElement, name, oldValue, this[VALUE]);
    }
  }
  cloneNode() {
    const { ownerDocument, name, [VALUE]: value } = this;
    return new _Attr(ownerDocument, name, value);
  }
  toString() {
    const { name, [VALUE]: value } = this;
    if (emptyAttributes.has(name) && !value) {
      return ignoreCase(this) ? name : `${name}=""`;
    }
    const escapedValue = (ignoreCase(this) ? value : escape2(value)).replace(QUOTE, "&quot;");
    return `${name}="${escapedValue}"`;
  }
  toJSON() {
    const json = [];
    attrAsJSON(this, json);
    return json;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/node.js
var isConnected = ({ ownerDocument, parentNode }) => {
  while (parentNode) {
    if (parentNode === ownerDocument)
      return true;
    parentNode = parentNode.parentNode || parentNode.host;
  }
  return false;
};
var parentElement = ({ parentNode }) => {
  if (parentNode) {
    switch (parentNode.nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        return null;
    }
  }
  return parentNode;
};
var previousSibling = ({ [PREV]: prev }) => {
  switch (prev ? prev.nodeType : 0) {
    case NODE_END:
      return prev[START];
    case TEXT_NODE:
    case COMMENT_NODE:
    case CDATA_SECTION_NODE:
      return prev;
  }
  return null;
};
var nextSibling = (node) => {
  const next = getEnd(node)[NEXT];
  return next && (next.nodeType === NODE_END ? null : next);
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/mixin/non-document-type-child-node.js
var nextElementSibling2 = (node) => {
  let next = nextSibling(node);
  while (next && next.nodeType !== ELEMENT_NODE)
    next = nextSibling(next);
  return next;
};
var previousElementSibling = (node) => {
  let prev = previousSibling(node);
  while (prev && prev.nodeType !== ELEMENT_NODE)
    prev = previousSibling(prev);
  return prev;
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/mixin/child-node.js
var asFragment = (ownerDocument, nodes) => {
  const fragment = ownerDocument.createDocumentFragment();
  fragment.append(...nodes);
  return fragment;
};
var before = (node, nodes) => {
  const { ownerDocument, parentNode } = node;
  if (parentNode)
    parentNode.insertBefore(
      asFragment(ownerDocument, nodes),
      node
    );
};
var after = (node, nodes) => {
  const { ownerDocument, parentNode } = node;
  if (parentNode)
    parentNode.insertBefore(
      asFragment(ownerDocument, nodes),
      getEnd(node)[NEXT]
    );
};
var replaceWith = (node, nodes) => {
  const { ownerDocument, parentNode } = node;
  if (parentNode) {
    if (nodes.includes(node))
      replaceWith(node, [node = node.cloneNode()]);
    parentNode.insertBefore(
      asFragment(ownerDocument, nodes),
      node
    );
    node.remove();
  }
};
var remove = (prev, current, next) => {
  const { parentNode, nodeType } = current;
  if (prev || next) {
    setAdjacent(prev, next);
    current[PREV] = null;
    getEnd(current)[NEXT] = null;
  }
  if (parentNode) {
    current.parentNode = null;
    moCallback(current, parentNode);
    if (nodeType === ELEMENT_NODE)
      disconnectedCallback(current);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/character-data.js
var CharacterData = class extends Node3 {
  constructor(ownerDocument, localName, nodeType, data) {
    super(ownerDocument, localName, nodeType);
    this[VALUE] = $String(data);
  }
  // <Mixins>
  get isConnected() {
    return isConnected(this);
  }
  get parentElement() {
    return parentElement(this);
  }
  get previousSibling() {
    return previousSibling(this);
  }
  get nextSibling() {
    return nextSibling(this);
  }
  get previousElementSibling() {
    return previousElementSibling(this);
  }
  get nextElementSibling() {
    return nextElementSibling2(this);
  }
  before(...nodes) {
    before(this, nodes);
  }
  after(...nodes) {
    after(this, nodes);
  }
  replaceWith(...nodes) {
    replaceWith(this, nodes);
  }
  remove() {
    remove(this[PREV], this, this[NEXT]);
  }
  // </Mixins>
  // CharacterData only
  /* c8 ignore start */
  get data() {
    return this[VALUE];
  }
  set data(value) {
    this[VALUE] = $String(value);
    moCallback(this, this.parentNode);
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(value) {
    this.data = value;
  }
  get textContent() {
    return this.data;
  }
  set textContent(value) {
    this.data = value;
  }
  get length() {
    return this.data.length;
  }
  substringData(offset, count) {
    return this.data.substr(offset, count);
  }
  appendData(data) {
    this.data += data;
  }
  insertData(offset, data) {
    const { data: t3 } = this;
    this.data = t3.slice(0, offset) + data + t3.slice(offset);
  }
  deleteData(offset, count) {
    const { data: t3 } = this;
    this.data = t3.slice(0, offset) + t3.slice(offset + count);
  }
  replaceData(offset, count, data) {
    const { data: t3 } = this;
    this.data = t3.slice(0, offset) + data + t3.slice(offset + count);
  }
  /* c8 ignore stop */
  toJSON() {
    const json = [];
    characterDataAsJSON(this, json);
    return json;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/cdata-section.js
var CDATASection = class _CDATASection extends CharacterData {
  constructor(ownerDocument, data = "") {
    super(ownerDocument, "#cdatasection", CDATA_SECTION_NODE, data);
  }
  cloneNode() {
    const { ownerDocument, [VALUE]: data } = this;
    return new _CDATASection(ownerDocument, data);
  }
  toString() {
    return `<![CDATA[${this[VALUE]}]]>`;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/comment.js
var Comment3 = class _Comment extends CharacterData {
  constructor(ownerDocument, data = "") {
    super(ownerDocument, "#comment", COMMENT_NODE, data);
  }
  cloneNode() {
    const { ownerDocument, [VALUE]: data } = this;
    return new _Comment(ownerDocument, data);
  }
  toString() {
    return `<!--${this[VALUE]}-->`;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/index.js
var import_boolbase6 = __toESM(require_boolbase());

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/compile.js
var import_css_what4 = __toESM(require_commonjs(), 1);
var import_boolbase5 = __toESM(require_boolbase(), 1);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/sort.js
var import_css_what = __toESM(require_commonjs(), 1);
var procedure = /* @__PURE__ */ new Map([
  [import_css_what.SelectorType.Universal, 50],
  [import_css_what.SelectorType.Tag, 30],
  [import_css_what.SelectorType.Attribute, 1],
  [import_css_what.SelectorType.Pseudo, 0]
]);
function isTraversal(token) {
  return !procedure.has(token.type);
}
var attributes = /* @__PURE__ */ new Map([
  [import_css_what.AttributeAction.Exists, 10],
  [import_css_what.AttributeAction.Equals, 8],
  [import_css_what.AttributeAction.Not, 7],
  [import_css_what.AttributeAction.Start, 6],
  [import_css_what.AttributeAction.End, 6],
  [import_css_what.AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i2 = 1; i2 < arr.length; i2++) {
    const procNew = procs[i2];
    if (procNew < 0)
      continue;
    for (let j5 = i2 - 1; j5 >= 0 && procNew < procs[j5]; j5--) {
      const token = arr[j5 + 1];
      arr[j5 + 1] = arr[j5];
      arr[j5] = token;
      procs[j5 + 1] = procs[j5];
      procs[j5] = procNew;
    }
  }
}
function getProcedure(token) {
  var _a3, _b;
  let proc = (_a3 = procedure.get(token.type)) !== null && _a3 !== void 0 ? _a3 : -1;
  if (token.type === import_css_what.SelectorType.Attribute) {
    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === import_css_what.AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === import_css_what.SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d3) => Math.min(...d3.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/attributes.js
var import_boolbase = __toESM(require_boolbase(), 1);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
var attributeRules = {
  equals(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name) === value && next(elem);
  },
  hyphen(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    const len = value.length;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function hyphen(elem) {
      const attr = adapter2.getAttributeValue(elem, name);
      return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
    };
  },
  element(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name, value } = data;
    if (/\s/.test(value)) {
      return import_boolbase.default.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data, options) ? "i" : "");
    return function element(elem) {
      const attr = adapter2.getAttributeValue(elem, name);
      return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
    };
  },
  exists(next, { name }, { adapter: adapter2 }) {
    return (elem) => adapter2.hasAttrib(elem, name) && next(elem);
  },
  start(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    const len = value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return (elem) => {
      var _a3;
      return !!((_a3 = adapter2.getAttributeValue(elem, name)) === null || _a3 === void 0 ? void 0 : _a3.startsWith(value)) && next(elem);
    };
  },
  end(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    const len = -value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a3;
        return ((_a3 = adapter2.getAttributeValue(elem, name)) === null || _a3 === void 0 ? void 0 : _a3.substr(len).toLowerCase()) === value && next(elem);
      };
    }
    return (elem) => {
      var _a3;
      return !!((_a3 = adapter2.getAttributeValue(elem, name)) === null || _a3 === void 0 ? void 0 : _a3.endsWith(value)) && next(elem);
    };
  },
  any(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name, value } = data;
    if (value === "") {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
      };
    }
    return (elem) => {
      var _a3;
      return !!((_a3 = adapter2.getAttributeValue(elem, name)) === null || _a3 === void 0 ? void 0 : _a3.includes(value)) && next(elem);
    };
  },
  not(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    if (value === "") {
      return (elem) => !!adapter2.getAttributeValue(elem, name) && next(elem);
    } else if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter2.getAttributeValue(elem, name);
        return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name) !== value && next(elem);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/index.js
var import_css_what2 = __toESM(require_commonjs(), 1);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/nth-check@2.1.1/node_modules/nth-check/lib/esm/parse.js
var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a2 = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a2 = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a2, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/nth-check@2.1.1/node_modules/nth-check/lib/esm/compile.js
var import_boolbase2 = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a2 = parsed[0];
  const b3 = parsed[1] - 1;
  if (b3 < 0 && a2 <= 0)
    return import_boolbase2.default.falseFunc;
  if (a2 === -1)
    return (index) => index <= b3;
  if (a2 === 0)
    return (index) => index === b3;
  if (a2 === 1)
    return b3 < 0 ? import_boolbase2.default.trueFunc : (index) => index >= b3;
  const absA = Math.abs(a2);
  const bMod = (b3 % absA + absA) % absA;
  return a2 > 1 ? (index) => index >= b3 && index % absA === bMod : (index) => index <= b3 && index % absA === bMod;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/nth-check@2.1.1/node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse(formula));
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/filters.js
var import_boolbase3 = __toESM(require_boolbase(), 1);
function getChildFunc(next, adapter2) {
  return (elem) => {
    const parent = adapter2.getParent(elem);
    return parent != null && adapter2.isTag(parent) && next(elem);
  };
}
var filters = {
  contains(next, text, { adapter: adapter2 }) {
    return function contains(elem) {
      return next(elem) && adapter2.getText(elem).includes(text);
    };
  },
  icontains(next, text, { adapter: adapter2 }) {
    const itext = text.toLowerCase();
    return function icontains(elem) {
      return next(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthChild(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = 0; i2 < siblings.length; i2++) {
        if (equals(elem, siblings[i2]))
          break;
        if (adapter2.isTag(siblings[i2])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthLastChild(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = siblings.length - 1; i2 >= 0; i2--) {
        if (equals(elem, siblings[i2]))
          break;
        if (adapter2.isTag(siblings[i2])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthOfType(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = 0; i2 < siblings.length; i2++) {
        const currentSibling = siblings[i2];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthLastOfType(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = siblings.length - 1; i2 >= 0; i2--) {
        const currentSibling = siblings[i2];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root(next, _rule, { adapter: adapter2 }) {
    return (elem) => {
      const parent = adapter2.getParent(elem);
      return (parent == null || !adapter2.isTag(parent)) && next(elem);
    };
  },
  scope(next, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next(elem);
    }
    return (elem) => context.includes(elem) && next(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next, _rule, { adapter: adapter2 }) {
    const func = adapter2[name];
    if (typeof func !== "function") {
      return import_boolbase3.default.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/pseudos.js
var pseudos = {
  empty(elem, { adapter: adapter2 }) {
    return !adapter2.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter2.isTag(elem2) || adapter2.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter: adapter2, equals }) {
    if (adapter2.prevElementSibling) {
      return adapter2.prevElementSibling(elem) == null;
    }
    const firstChild = adapter2.getSiblings(elem).find((elem2) => adapter2.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter: adapter2, equals }) {
    const siblings = adapter2.getSiblings(elem);
    for (let i2 = siblings.length - 1; i2 >= 0; i2--) {
      if (equals(elem, siblings[i2]))
        return true;
      if (adapter2.isTag(siblings[i2]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i2 = 0; i2 < siblings.length; i2++) {
      const currentSibling = siblings[i2];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i2 = siblings.length - 1; i2 >= 0; i2--) {
      const currentSibling = siblings[i2];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter: adapter2, equals }) {
    const elemName = adapter2.getName(elem);
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling) || adapter2.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter: adapter2, equals }) {
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
  }
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/aliases.js
var aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/subselects.js
var import_boolbase4 = __toESM(require_boolbase(), 1);
var PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter2) {
  if (next === import_boolbase4.default.falseFunc)
    return import_boolbase4.default.falseFunc;
  return (elem) => adapter2.isTag(elem) && next(elem);
}
function getNextSiblings(elem, adapter2) {
  const siblings = adapter2.getSiblings(elem);
  if (siblings.length <= 1)
    return [];
  const elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1)
    return [];
  return siblings.slice(elemIndex + 1).filter(adapter2.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is = (next, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === import_boolbase4.default.trueFunc ? next : func === import_boolbase4.default.falseFunc ? import_boolbase4.default.falseFunc : (elem) => func(elem) && next(elem);
};
var subselects = {
  is,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is,
  where: is,
  not(next, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === import_boolbase4.default.falseFunc ? next : func === import_boolbase4.default.trueFunc ? import_boolbase4.default.falseFunc : (elem) => !func(elem) && next(elem);
  },
  has(next, subselect, options, _context, compileToken2) {
    const { adapter: adapter2 } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s2) => s2.some(isTraversal)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === import_boolbase4.default.falseFunc)
      return import_boolbase4.default.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter2);
    if (context && compiled !== import_boolbase4.default.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next(elem))
          return false;
        context[0] = elem;
        const childs = adapter2.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter2)] : childs;
        return adapter2.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/index.js
function compilePseudoSelector(next, selector, options, context, compileToken2) {
  var _a3;
  const { name, data } = selector;
  if (Array.isArray(data)) {
    if (!(name in subselects)) {
      throw new Error(`Unknown pseudo-class :${name}(${data})`);
    }
    return subselects[name](next, data, options, context, compileToken2);
  }
  const userPseudo = (_a3 = options.pseudos) === null || _a3 === void 0 ? void 0 : _a3[name];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
  if (typeof stringPseudo === "string") {
    if (data != null) {
      throw new Error(`Pseudo ${name} doesn't have any arguments`);
    }
    const alias = (0, import_css_what2.parse)(stringPseudo);
    return subselects["is"](next, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name, data, 1);
    return (elem) => userPseudo(elem, data) && next(elem);
  }
  if (name in filters) {
    return filters[name](next, data, options, context);
  }
  if (name in pseudos) {
    const pseudo = pseudos[name];
    verifyPseudoArgs(pseudo, name, data, 2);
    return (elem) => pseudo(elem, options, data) && next(elem);
  }
  throw new Error(`Unknown pseudo-class :${name}`);
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/general.js
var import_css_what3 = __toESM(require_commonjs(), 1);
function getElementParent(node, adapter2) {
  const parent = adapter2.getParent(node);
  if (parent && adapter2.isTag(parent)) {
    return parent;
  }
  return null;
}
function compileGeneralSelector(next, selector, options, context, compileToken2) {
  const { adapter: adapter2, equals } = options;
  switch (selector.type) {
    case import_css_what3.SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case import_css_what3.SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case import_css_what3.SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next, selector, options);
    }
    case import_css_what3.SelectorType.Pseudo: {
      return compilePseudoSelector(next, selector, options, context, compileToken2);
    }
    // Tags
    case import_css_what3.SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name = name.toLowerCase();
      }
      return function tag(elem) {
        return adapter2.getName(elem) === name && next(elem);
      };
    }
    // Traversal
    case import_css_what3.SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter2)) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter2)) {
          if (!isFalseCache.has(current)) {
            if (adapter2.isTag(current) && next(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next(current))
            return true;
        } while (current = getElementParent(current, adapter2));
        return false;
      };
    }
    case import_css_what3.SelectorType.Parent: {
      return function parent(elem) {
        return adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) && next(elem2));
      };
    }
    case import_css_what3.SelectorType.Child: {
      return function child(elem) {
        const parent = adapter2.getParent(elem);
        return parent != null && adapter2.isTag(parent) && next(parent);
      };
    }
    case import_css_what3.SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings = adapter2.getSiblings(elem);
        for (let i2 = 0; i2 < siblings.length; i2++) {
          const currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case import_css_what3.SelectorType.Adjacent: {
      if (adapter2.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter2.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        const siblings = adapter2.getSiblings(elem);
        let lastElement;
        for (let i2 = 0; i2 < siblings.length; i2++) {
          const currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case import_css_what3.SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next;
    }
  }
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/compile.js
function compile2(selector, options, context) {
  const next = compileUnsafe(selector, options, context);
  return ensureIsTag(next, options.adapter);
}
function compileUnsafe(selector, options, context) {
  const token = typeof selector === "string" ? (0, import_css_what4.parse)(selector) : selector;
  return compileToken(token, options, context);
}
function includesScopePseudo(t3) {
  return t3.type === import_css_what4.SelectorType.Pseudo && (t3.name === "scope" || Array.isArray(t3.data) && t3.data.some((data) => data.some(includesScopePseudo)));
}
var DESCENDANT_TOKEN = { type: import_css_what4.SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: import_css_what4.SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter: adapter2 }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e2) => {
    const parent = adapter2.isTag(e2) && adapter2.getParent(e2);
    return e2 === PLACEHOLDER_ELEMENT || parent && adapter2.isTag(parent);
  }));
  for (const t3 of token) {
    if (t3.length > 0 && isTraversal(t3[0]) && t3[0].type !== import_css_what4.SelectorType.Descendant) {
    } else if (hasContext && !t3.some(includesScopePseudo)) {
      t3.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t3.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a3;
  token.forEach(sortByProcedure);
  context = (_a3 = options.context) !== null && _a3 !== void 0 ? _a3 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t3) => t3.length > 0 && isTraversal(t3[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query2 = token.map((rules) => {
    if (rules.length >= 2) {
      const [first, second] = rules;
      if (first.type !== import_css_what4.SelectorType.Pseudo || first.name !== "scope") {
      } else if (isArrayContext && second.type === import_css_what4.SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === import_css_what4.SelectorType.Adjacent || second.type === import_css_what4.SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, import_boolbase5.default.falseFunc);
  query2.shouldTestNextSiblings = shouldTestNextSiblings;
  return query2;
}
function compileRules(rules, options, context) {
  var _a3;
  return rules.reduce((previous, rule) => previous === import_boolbase5.default.falseFunc ? import_boolbase5.default.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a3 = options.rootFunc) !== null && _a3 !== void 0 ? _a3 : import_boolbase5.default.trueFunc);
}
function reduceRules(a2, b3) {
  if (b3 === import_boolbase5.default.falseFunc || a2 === import_boolbase5.default.trueFunc) {
    return a2;
  }
  if (a2 === import_boolbase5.default.falseFunc || b3 === import_boolbase5.default.trueFunc) {
    return b3;
  }
  return function combine(elem) {
    return a2(elem) || b3(elem);
  };
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/css-select@5.1.0/node_modules/css-select/lib/esm/index.js
var defaultEquals = (a2, b3) => a2 === b3;
var defaultOptions = {
  adapter: esm_exports2,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a3, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a3 = opts.adapter) !== null && _a3 !== void 0 ? _a3 : opts.adapter = esm_exports2;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
var compile3 = wrapCompile(compile2);
var _compileUnsafe = wrapCompile(compileUnsafe);
var _compileToken = wrapCompile(compileToken);
function getSelectorFunc(searchFunc) {
  return function select(query2, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query2 !== "function") {
      query2 = compileUnsafe(query2, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query2.shouldTestNextSiblings);
    return searchFunc(query2, filteredElements, opts);
  };
}
function prepareContext(elems, adapter2, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter2);
  }
  return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
}
function appendNextSiblings(elem, adapter2) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i2 = 0; i2 < elemsLength; i2++) {
    const nextSiblings = getNextSiblings(elems[i2], adapter2);
    elems.push(...nextSiblings);
  }
  return elems;
}
var selectAll = getSelectorFunc((query2, elems, options) => query2 === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query2, elems));
var selectOne = getSelectorFunc((query2, elems, options) => query2 === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query2, elems));
function is2(elem, query2, options) {
  const opts = convertOptionFormats(options);
  return (typeof query2 === "function" ? query2 : compile2(query2, opts))(elem);
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/matches.js
var { isArray } = Array;
var isTag3 = ({ nodeType }) => nodeType === ELEMENT_NODE;
var existsOne2 = (test, elements) => elements.some(
  (element) => isTag3(element) && (test(element) || existsOne2(test, getChildren2(element)))
);
var getAttributeValue2 = (element, name) => name === "class" ? element.classList.value : element.getAttribute(name);
var getChildren2 = ({ childNodes }) => childNodes;
var getName2 = (element) => {
  const { localName } = element;
  return ignoreCase(element) ? localName.toLowerCase() : localName;
};
var getParent2 = ({ parentNode }) => parentNode;
var getSiblings2 = (element) => {
  const { parentNode } = element;
  return parentNode ? getChildren2(parentNode) : element;
};
var getText2 = (node) => {
  if (isArray(node))
    return node.map(getText2).join("");
  if (isTag3(node))
    return getText2(getChildren2(node));
  if (node.nodeType === TEXT_NODE)
    return node.data;
  return "";
};
var hasAttrib2 = (element, name) => element.hasAttribute(name);
var removeSubsets2 = (nodes) => {
  let { length } = nodes;
  while (length--) {
    const node = nodes[length];
    if (length && -1 < nodes.lastIndexOf(node, length - 1)) {
      nodes.splice(length, 1);
      continue;
    }
    for (let { parentNode } = node; parentNode; parentNode = parentNode.parentNode) {
      if (nodes.includes(parentNode)) {
        nodes.splice(length, 1);
        break;
      }
    }
  }
  return nodes;
};
var findAll2 = (test, nodes) => {
  const matches2 = [];
  for (const node of nodes) {
    if (isTag3(node)) {
      if (test(node))
        matches2.push(node);
      matches2.push(...findAll2(test, getChildren2(node)));
    }
  }
  return matches2;
};
var findOne2 = (test, nodes) => {
  for (let node of nodes)
    if (test(node) || (node = findOne2(test, getChildren2(node))))
      return node;
  return null;
};
var adapter = {
  isTag: isTag3,
  existsOne: existsOne2,
  getAttributeValue: getAttributeValue2,
  getChildren: getChildren2,
  getName: getName2,
  getParent: getParent2,
  getSiblings: getSiblings2,
  getText: getText2,
  hasAttrib: hasAttrib2,
  removeSubsets: removeSubsets2,
  findAll: findAll2,
  findOne: findOne2
};
var prepareMatch = (element, selectors) => compile3(
  selectors,
  {
    context: selectors.includes(":scope") ? element : void 0,
    xmlMode: !ignoreCase(element),
    adapter
  }
);
var matches = (element, selectors) => is2(
  element,
  selectors,
  {
    strict: true,
    context: selectors.includes(":scope") ? element : void 0,
    xmlMode: !ignoreCase(element),
    adapter
  }
);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/text.js
var Text4 = class _Text extends CharacterData {
  constructor(ownerDocument, data = "") {
    super(ownerDocument, "#text", TEXT_NODE, data);
  }
  get wholeText() {
    const text = [];
    let { previousSibling: previousSibling2, nextSibling: nextSibling2 } = this;
    while (previousSibling2) {
      if (previousSibling2.nodeType === TEXT_NODE)
        text.unshift(previousSibling2[VALUE]);
      else
        break;
      previousSibling2 = previousSibling2.previousSibling;
    }
    text.push(this[VALUE]);
    while (nextSibling2) {
      if (nextSibling2.nodeType === TEXT_NODE)
        text.push(nextSibling2[VALUE]);
      else
        break;
      nextSibling2 = nextSibling2.nextSibling;
    }
    return text.join("");
  }
  cloneNode() {
    const { ownerDocument, [VALUE]: data } = this;
    return new _Text(ownerDocument, data);
  }
  toString() {
    return escape2(this[VALUE]);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/mixin/parent-node.js
var isNode = (node) => node instanceof Node3;
var insert = (parentNode, child, nodes) => {
  const { ownerDocument } = parentNode;
  for (const node of nodes)
    parentNode.insertBefore(
      isNode(node) ? node : new Text4(ownerDocument, node),
      child
    );
};
var ParentNode = class extends Node3 {
  constructor(ownerDocument, localName, nodeType) {
    super(ownerDocument, localName, nodeType);
    this[PRIVATE] = null;
    this[NEXT] = this[END] = {
      [NEXT]: null,
      [PREV]: this,
      [START]: this,
      nodeType: NODE_END,
      ownerDocument: this.ownerDocument,
      parentNode: null
    };
  }
  get childNodes() {
    const childNodes = new NodeList();
    let { firstChild } = this;
    while (firstChild) {
      childNodes.push(firstChild);
      firstChild = nextSibling(firstChild);
    }
    return childNodes;
  }
  get children() {
    const children = new NodeList();
    let { firstElementChild } = this;
    while (firstElementChild) {
      children.push(firstElementChild);
      firstElementChild = nextElementSibling2(firstElementChild);
    }
    return children;
  }
  /**
   * @returns {NodeStruct | null}
   */
  get firstChild() {
    let { [NEXT]: next, [END]: end } = this;
    while (next.nodeType === ATTRIBUTE_NODE)
      next = next[NEXT];
    return next === end ? null : next;
  }
  /**
   * @returns {NodeStruct | null}
   */
  get firstElementChild() {
    let { firstChild } = this;
    while (firstChild) {
      if (firstChild.nodeType === ELEMENT_NODE)
        return firstChild;
      firstChild = nextSibling(firstChild);
    }
    return null;
  }
  get lastChild() {
    const prev = this[END][PREV];
    switch (prev.nodeType) {
      case NODE_END:
        return prev[START];
      case ATTRIBUTE_NODE:
        return null;
    }
    return prev === this ? null : prev;
  }
  get lastElementChild() {
    let { lastChild } = this;
    while (lastChild) {
      if (lastChild.nodeType === ELEMENT_NODE)
        return lastChild;
      lastChild = previousSibling(lastChild);
    }
    return null;
  }
  get childElementCount() {
    return this.children.length;
  }
  prepend(...nodes) {
    insert(this, this.firstChild, nodes);
  }
  append(...nodes) {
    insert(this, this[END], nodes);
  }
  replaceChildren(...nodes) {
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end && next.nodeType === ATTRIBUTE_NODE)
      next = next[NEXT];
    while (next !== end) {
      const after2 = getEnd(next)[NEXT];
      next.remove();
      next = after2;
    }
    if (nodes.length)
      insert(this, end, nodes);
  }
  getElementsByClassName(className) {
    const elements = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && next.hasAttribute("class") && next.classList.has(className))
        elements.push(next);
      next = next[NEXT];
    }
    return elements;
  }
  getElementsByTagName(tagName19) {
    const elements = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && (next.localName === tagName19 || localCase(next) === tagName19))
        elements.push(next);
      next = next[NEXT];
    }
    return elements;
  }
  querySelector(selectors) {
    const matches2 = prepareMatch(this, selectors);
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && matches2(next))
        return next;
      next = next.nodeType === ELEMENT_NODE && next.localName === "template" ? next[END] : next[NEXT];
    }
    return null;
  }
  querySelectorAll(selectors) {
    const matches2 = prepareMatch(this, selectors);
    const elements = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && matches2(next))
        elements.push(next);
      next = next.nodeType === ELEMENT_NODE && next.localName === "template" ? next[END] : next[NEXT];
    }
    return elements;
  }
  appendChild(node) {
    return this.insertBefore(node, this[END]);
  }
  contains(node) {
    let parentNode = node;
    while (parentNode && parentNode !== this)
      parentNode = parentNode.parentNode;
    return parentNode === this;
  }
  insertBefore(node, before2 = null) {
    if (node === before2)
      return node;
    if (node === this)
      throw new Error("unable to append a node to itself");
    const next = before2 || this[END];
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node.remove();
        node.parentNode = this;
        knownBoundaries(next[PREV], node, next);
        moCallback(node, null);
        connectedCallback(node);
        break;
      case DOCUMENT_FRAGMENT_NODE: {
        let { [PRIVATE]: parentNode, firstChild, lastChild } = node;
        if (firstChild) {
          knownSegment(next[PREV], firstChild, lastChild, next);
          knownAdjacent(node, node[END]);
          if (parentNode)
            parentNode.replaceChildren();
          do {
            firstChild.parentNode = this;
            moCallback(firstChild, null);
            if (firstChild.nodeType === ELEMENT_NODE)
              connectedCallback(firstChild);
          } while (firstChild !== lastChild && (firstChild = nextSibling(firstChild)));
        }
        break;
      }
      case TEXT_NODE:
      case COMMENT_NODE:
      case CDATA_SECTION_NODE:
        node.remove();
      /* eslint no-fallthrough:0 */
      // this covers DOCUMENT_TYPE_NODE too
      default:
        node.parentNode = this;
        knownSiblings(next[PREV], node, next);
        moCallback(node, null);
        break;
    }
    return node;
  }
  normalize() {
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      const { [NEXT]: $next, [PREV]: $prev, nodeType } = next;
      if (nodeType === TEXT_NODE) {
        if (!next[VALUE])
          next.remove();
        else if ($prev && $prev.nodeType === TEXT_NODE) {
          $prev.textContent += next.textContent;
          next.remove();
        }
      }
      next = $next;
    }
  }
  removeChild(node) {
    if (node.parentNode !== this)
      throw new Error("node is not a child");
    node.remove();
    return node;
  }
  replaceChild(node, replaced) {
    const next = getEnd(replaced)[NEXT];
    replaced.remove();
    this.insertBefore(node, next);
    return replaced;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/mixin/non-element-parent-node.js
var NonElementParentNode = class extends ParentNode {
  getElementById(id) {
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && next.id === id)
        return next;
      next = next[NEXT];
    }
    return null;
  }
  cloneNode(deep) {
    const { ownerDocument, constructor } = this;
    const nonEPN = new constructor(ownerDocument);
    if (deep) {
      const { [END]: end } = nonEPN;
      for (const node of this.childNodes)
        nonEPN.insertBefore(node.cloneNode(deep), end);
    }
    return nonEPN;
  }
  toString() {
    const { childNodes, localName } = this;
    return `<${localName}>${childNodes.join("")}</${localName}>`;
  }
  toJSON() {
    const json = [];
    nonElementAsJSON(this, json);
    return json;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/document-fragment.js
var DocumentFragment = class extends NonElementParentNode {
  constructor(ownerDocument) {
    super(ownerDocument, "#document-fragment", DOCUMENT_FRAGMENT_NODE);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/document-type.js
var DocumentType = class _DocumentType extends Node3 {
  constructor(ownerDocument, name, publicId = "", systemId = "") {
    super(ownerDocument, "#document-type", DOCUMENT_TYPE_NODE);
    this.name = name;
    this.publicId = publicId;
    this.systemId = systemId;
  }
  cloneNode() {
    const { ownerDocument, name, publicId, systemId } = this;
    return new _DocumentType(ownerDocument, name, publicId, systemId);
  }
  toString() {
    const { name, publicId, systemId } = this;
    const hasPublic = 0 < publicId.length;
    const str = [name];
    if (hasPublic)
      str.push("PUBLIC", `"${publicId}"`);
    if (systemId.length) {
      if (!hasPublic)
        str.push("SYSTEM");
      str.push(`"${systemId}"`);
    }
    return `<!DOCTYPE ${str.join(" ")}>`;
  }
  toJSON() {
    const json = [];
    documentTypeAsJSON(this, json);
    return json;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/mixin/inner-html.js
var getInnerHtml = (node) => node.childNodes.join("");
var setInnerHtml = (node, html) => {
  const { ownerDocument } = node;
  const { constructor } = ownerDocument;
  const document2 = new constructor();
  document2[CUSTOM_ELEMENTS] = ownerDocument[CUSTOM_ELEMENTS];
  const { childNodes } = parseFromString(document2, ignoreCase(node), html);
  node.replaceChildren(...childNodes.map(setOwnerDocument, ownerDocument));
};
function setOwnerDocument(node) {
  node.ownerDocument = this;
  switch (node.nodeType) {
    case ELEMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      node.childNodes.forEach(setOwnerDocument, this);
      break;
  }
  return node;
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/uhyphen@0.2.0/node_modules/uhyphen/esm/index.js
var esm_default2 = (camel) => camel.replace(/(([A-Z0-9])([A-Z0-9][a-z]))|(([a-z0-9]+)([A-Z]))/g, "$2$5-$3$6").toLowerCase();

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/dom/string-map.js
var refs = /* @__PURE__ */ new WeakMap();
var key = (name) => `data-${esm_default2(name)}`;
var prop = (name) => name.slice(5).replace(/-([a-z])/g, (_5, $1) => $1.toUpperCase());
var handler = {
  get(dataset, name) {
    if (name in dataset)
      return refs.get(dataset).getAttribute(key(name));
  },
  set(dataset, name, value) {
    dataset[name] = value;
    refs.get(dataset).setAttribute(key(name), value);
    return true;
  },
  deleteProperty(dataset, name) {
    if (name in dataset)
      refs.get(dataset).removeAttribute(key(name));
    return delete dataset[name];
  }
};
var DOMStringMap = class {
  /**
   * @param {Element} ref
   */
  constructor(ref) {
    for (const { name, value } of ref.attributes) {
      if (/^data-/.test(name))
        this[prop(name)] = value;
    }
    refs.set(this, ref);
    return new Proxy(this, handler);
  }
};
setPrototypeOf(DOMStringMap.prototype, null);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/dom/token-list.js
var { add } = Set.prototype;
var addTokens = (self, tokens) => {
  for (const token of tokens) {
    if (token)
      add.call(self, token);
  }
};
var update = ({ [OWNER_ELEMENT]: ownerElement, value }) => {
  const attribute2 = ownerElement.getAttributeNode("class");
  if (attribute2)
    attribute2.value = value;
  else
    setAttribute(
      ownerElement,
      new Attr(ownerElement.ownerDocument, "class", value)
    );
};
var DOMTokenList = class extends Set {
  constructor(ownerElement) {
    super();
    this[OWNER_ELEMENT] = ownerElement;
    const attribute2 = ownerElement.getAttributeNode("class");
    if (attribute2)
      addTokens(this, attribute2.value.split(/\s+/));
  }
  get length() {
    return this.size;
  }
  get value() {
    return [...this].join(" ");
  }
  /**
   * @param  {...string} tokens
   */
  add(...tokens) {
    addTokens(this, tokens);
    update(this);
  }
  /**
   * @param {string} token
   */
  contains(token) {
    return this.has(token);
  }
  /**
   * @param  {...string} tokens
   */
  remove(...tokens) {
    for (const token of tokens)
      this.delete(token);
    update(this);
  }
  /**
   * @param {string} token
   * @param {boolean?} force
   */
  toggle(token, force) {
    if (this.has(token)) {
      if (force)
        return true;
      this.delete(token);
      update(this);
    } else if (force || arguments.length === 1) {
      super.add(token);
      update(this);
      return true;
    }
    return false;
  }
  /**
   * @param {string} token
   * @param {string} newToken
   */
  replace(token, newToken) {
    if (this.has(token)) {
      this.delete(token);
      super.add(newToken);
      update(this);
      return true;
    }
    return false;
  }
  /**
   * @param {string} token
   */
  supports() {
    return true;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/css-style-declaration.js
var refs2 = /* @__PURE__ */ new WeakMap();
var getKeys = (style) => [...style.keys()].filter((key2) => key2 !== PRIVATE);
var updateKeys = (style) => {
  const attr = refs2.get(style).getAttributeNode("style");
  if (!attr || attr[CHANGED] || style.get(PRIVATE) !== attr) {
    style.clear();
    if (attr) {
      style.set(PRIVATE, attr);
      for (const rule of attr[VALUE].split(/\s*;\s*/)) {
        let [key2, ...rest] = rule.split(":");
        if (rest.length > 0) {
          key2 = key2.trim();
          const value = rest.join(":").trim();
          if (key2 && value)
            style.set(key2, value);
        }
      }
    }
  }
  return attr;
};
var handler2 = {
  get(style, name) {
    if (name in prototype)
      return style[name];
    updateKeys(style);
    if (name === "length")
      return getKeys(style).length;
    if (/^\d+$/.test(name))
      return getKeys(style)[name];
    return style.get(esm_default2(name));
  },
  set(style, name, value) {
    if (name === "cssText")
      style[name] = value;
    else {
      let attr = updateKeys(style);
      if (value == null)
        style.delete(esm_default2(name));
      else
        style.set(esm_default2(name), value);
      if (!attr) {
        const element = refs2.get(style);
        attr = element.ownerDocument.createAttribute("style");
        element.setAttributeNode(attr);
        style.set(PRIVATE, attr);
      }
      attr[CHANGED] = false;
      attr[VALUE] = style.toString();
    }
    return true;
  }
};
var CSSStyleDeclaration = class extends Map {
  constructor(element) {
    super();
    refs2.set(this, element);
    return new Proxy(this, handler2);
  }
  get cssText() {
    return this.toString();
  }
  set cssText(value) {
    refs2.get(this).setAttribute("style", value);
  }
  getPropertyValue(name) {
    const self = this[PRIVATE];
    return handler2.get(self, name);
  }
  setProperty(name, value) {
    const self = this[PRIVATE];
    handler2.set(self, name, value);
  }
  removeProperty(name) {
    const self = this[PRIVATE];
    handler2.set(self, name, null);
  }
  [Symbol.iterator]() {
    const self = this[PRIVATE];
    updateKeys(self);
    const keys2 = getKeys(self);
    const { length } = keys2;
    let i2 = 0;
    return {
      next() {
        const done = i2 === length;
        return { done, value: done ? null : keys2[i2++] };
      }
    };
  }
  get [PRIVATE]() {
    return this;
  }
  toString() {
    const self = this[PRIVATE];
    updateKeys(self);
    const cssText = [];
    self.forEach(push, cssText);
    return cssText.join(";");
  }
};
var { prototype } = CSSStyleDeclaration;
function push(value, key2) {
  if (key2 !== PRIVATE)
    this.push(`${key2}:${value}`);
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/event.js
var BUBBLING_PHASE = 3;
var AT_TARGET = 2;
var CAPTURING_PHASE = 1;
var NONE = 0;
function getCurrentTarget(ev) {
  return ev.currentTarget;
}
var GlobalEvent = class {
  static get BUBBLING_PHASE() {
    return BUBBLING_PHASE;
  }
  static get AT_TARGET() {
    return AT_TARGET;
  }
  static get CAPTURING_PHASE() {
    return CAPTURING_PHASE;
  }
  static get NONE() {
    return NONE;
  }
  constructor(type, eventInitDict = {}) {
    this.type = type;
    this.bubbles = !!eventInitDict.bubbles;
    this.cancelBubble = false;
    this._stopImmediatePropagationFlag = false;
    this.cancelable = !!eventInitDict.cancelable;
    this.eventPhase = this.NONE;
    this.timeStamp = Date.now();
    this.defaultPrevented = false;
    this.originalTarget = null;
    this.returnValue = null;
    this.srcElement = null;
    this.target = null;
    this._path = [];
  }
  get BUBBLING_PHASE() {
    return BUBBLING_PHASE;
  }
  get AT_TARGET() {
    return AT_TARGET;
  }
  get CAPTURING_PHASE() {
    return CAPTURING_PHASE;
  }
  get NONE() {
    return NONE;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  // simplified implementation, should be https://dom.spec.whatwg.org/#dom-event-composedpath
  composedPath() {
    return this._path.map(getCurrentTarget);
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.stopPropagation();
    this._stopImmediatePropagationFlag = true;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/named-node-map.js
var NamedNodeMap = class extends Array {
  constructor(ownerElement) {
    super();
    this.ownerElement = ownerElement;
  }
  getNamedItem(name) {
    return this.ownerElement.getAttributeNode(name);
  }
  setNamedItem(attr) {
    this.ownerElement.setAttributeNode(attr);
    this.unshift(attr);
  }
  removeNamedItem(name) {
    const item = this.getNamedItem(name);
    this.ownerElement.removeAttribute(name);
    this.splice(this.indexOf(item), 1);
  }
  item(index) {
    return index < this.length ? this[index] : null;
  }
  /* c8 ignore start */
  getNamedItemNS(_5, name) {
    return this.getNamedItem(name);
  }
  setNamedItemNS(_5, attr) {
    return this.setNamedItem(attr);
  }
  removeNamedItemNS(_5, name) {
    return this.removeNamedItem(name);
  }
  /* c8 ignore stop */
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/shadow-root.js
var ShadowRoot = class extends NonElementParentNode {
  constructor(host) {
    super(host.ownerDocument, "#shadow-root", DOCUMENT_FRAGMENT_NODE);
    this.host = host;
  }
  get innerHTML() {
    return getInnerHtml(this);
  }
  set innerHTML(html) {
    setInnerHtml(this, html);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/element.js
var attributesHandler = {
  get(target, key2) {
    return key2 in target ? target[key2] : target.find(({ name }) => name === key2);
  }
};
var create2 = (ownerDocument, element, localName) => {
  if ("ownerSVGElement" in element) {
    const svg = ownerDocument.createElementNS(SVG_NAMESPACE, localName);
    svg.ownerSVGElement = element.ownerSVGElement;
    return svg;
  }
  return ownerDocument.createElement(localName);
};
var isVoid = ({ localName, ownerDocument }) => {
  return ownerDocument[MIME].voidElements.test(localName);
};
var Element2 = class extends ParentNode {
  constructor(ownerDocument, localName) {
    super(ownerDocument, localName, ELEMENT_NODE);
    this[CLASS_LIST] = null;
    this[DATASET] = null;
    this[STYLE] = null;
  }
  // <Mixins>
  get isConnected() {
    return isConnected(this);
  }
  get parentElement() {
    return parentElement(this);
  }
  get previousSibling() {
    return previousSibling(this);
  }
  get nextSibling() {
    return nextSibling(this);
  }
  get namespaceURI() {
    return "http://www.w3.org/1999/xhtml";
  }
  get previousElementSibling() {
    return previousElementSibling(this);
  }
  get nextElementSibling() {
    return nextElementSibling2(this);
  }
  before(...nodes) {
    before(this, nodes);
  }
  after(...nodes) {
    after(this, nodes);
  }
  replaceWith(...nodes) {
    replaceWith(this, nodes);
  }
  remove() {
    remove(this[PREV], this, this[END][NEXT]);
  }
  // </Mixins>
  // <specialGetters>
  get id() {
    return stringAttribute.get(this, "id");
  }
  set id(value) {
    stringAttribute.set(this, "id", value);
  }
  get className() {
    return this.classList.value;
  }
  set className(value) {
    const { classList } = this;
    classList.clear();
    classList.add(...$String(value).split(/\s+/));
  }
  get nodeName() {
    return localCase(this);
  }
  get tagName() {
    return localCase(this);
  }
  get classList() {
    return this[CLASS_LIST] || (this[CLASS_LIST] = new DOMTokenList(this));
  }
  get dataset() {
    return this[DATASET] || (this[DATASET] = new DOMStringMap(this));
  }
  getBoundingClientRect() {
    return {
      x: 0,
      y: 0,
      bottom: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0,
      width: 0
    };
  }
  get nonce() {
    return stringAttribute.get(this, "nonce");
  }
  set nonce(value) {
    stringAttribute.set(this, "nonce", value);
  }
  get style() {
    return this[STYLE] || (this[STYLE] = new CSSStyleDeclaration(this));
  }
  get tabIndex() {
    return numericAttribute.get(this, "tabindex") || -1;
  }
  set tabIndex(value) {
    numericAttribute.set(this, "tabindex", value);
  }
  get slot() {
    return stringAttribute.get(this, "slot");
  }
  set slot(value) {
    stringAttribute.set(this, "slot", value);
  }
  // </specialGetters>
  // <contentRelated>
  get innerText() {
    const text = [];
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === TEXT_NODE) {
        text.push(next.textContent.replace(/\s+/g, " "));
      } else if (text.length && next[NEXT] != end && BLOCK_ELEMENTS.has(next.tagName)) {
        text.push("\n");
      }
      next = next[NEXT];
    }
    return text.join("");
  }
  /**
   * @returns {String}
   */
  get textContent() {
    const text = [];
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      const nodeType = next.nodeType;
      if (nodeType === TEXT_NODE || nodeType === CDATA_SECTION_NODE)
        text.push(next.textContent);
      next = next[NEXT];
    }
    return text.join("");
  }
  set textContent(text) {
    this.replaceChildren();
    if (text != null && text !== "")
      this.appendChild(new Text4(this.ownerDocument, text));
  }
  get innerHTML() {
    return getInnerHtml(this);
  }
  set innerHTML(html) {
    setInnerHtml(this, html);
  }
  get outerHTML() {
    return this.toString();
  }
  set outerHTML(html) {
    const template = this.ownerDocument.createElement("");
    template.innerHTML = html;
    this.replaceWith(...template.childNodes);
  }
  // </contentRelated>
  // <attributes>
  get attributes() {
    const attributes2 = new NamedNodeMap(this);
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      attributes2.push(next);
      next = next[NEXT];
    }
    return new Proxy(attributes2, attributesHandler);
  }
  focus() {
    this.dispatchEvent(new GlobalEvent("focus"));
  }
  getAttribute(name) {
    if (name === "class")
      return this.className;
    const attribute2 = this.getAttributeNode(name);
    return attribute2 && (ignoreCase(this) ? attribute2.value : escape2(attribute2.value));
  }
  getAttributeNode(name) {
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      if (next.name === name)
        return next;
      next = next[NEXT];
    }
    return null;
  }
  getAttributeNames() {
    const attributes2 = new NodeList();
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      attributes2.push(next.name);
      next = next[NEXT];
    }
    return attributes2;
  }
  hasAttribute(name) {
    return !!this.getAttributeNode(name);
  }
  hasAttributes() {
    return this[NEXT].nodeType === ATTRIBUTE_NODE;
  }
  removeAttribute(name) {
    if (name === "class" && this[CLASS_LIST])
      this[CLASS_LIST].clear();
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      if (next.name === name) {
        removeAttribute(this, next);
        return;
      }
      next = next[NEXT];
    }
  }
  removeAttributeNode(attribute2) {
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      if (next === attribute2) {
        removeAttribute(this, next);
        return;
      }
      next = next[NEXT];
    }
  }
  setAttribute(name, value) {
    if (name === "class")
      this.className = value;
    else {
      const attribute2 = this.getAttributeNode(name);
      if (attribute2)
        attribute2.value = value;
      else
        setAttribute(this, new Attr(this.ownerDocument, name, value));
    }
  }
  setAttributeNode(attribute2) {
    const { name } = attribute2;
    const previously = this.getAttributeNode(name);
    if (previously !== attribute2) {
      if (previously)
        this.removeAttributeNode(previously);
      const { ownerElement } = attribute2;
      if (ownerElement)
        ownerElement.removeAttributeNode(attribute2);
      setAttribute(this, attribute2);
    }
    return previously;
  }
  toggleAttribute(name, force) {
    if (this.hasAttribute(name)) {
      if (!force) {
        this.removeAttribute(name);
        return false;
      }
      return true;
    } else if (force || arguments.length === 1) {
      this.setAttribute(name, "");
      return true;
    }
    return false;
  }
  // </attributes>
  // <ShadowDOM>
  get shadowRoot() {
    if (shadowRoots.has(this)) {
      const { mode, shadowRoot } = shadowRoots.get(this);
      if (mode === "open")
        return shadowRoot;
    }
    return null;
  }
  attachShadow(init) {
    if (shadowRoots.has(this))
      throw new Error("operation not supported");
    const shadowRoot = new ShadowRoot(this);
    shadowRoots.set(this, {
      mode: init.mode,
      shadowRoot
    });
    return shadowRoot;
  }
  // </ShadowDOM>
  // <selectors>
  matches(selectors) {
    return matches(this, selectors);
  }
  closest(selectors) {
    let parentElement2 = this;
    const matches2 = prepareMatch(parentElement2, selectors);
    while (parentElement2 && !matches2(parentElement2))
      parentElement2 = parentElement2.parentElement;
    return parentElement2;
  }
  // </selectors>
  // <insertAdjacent>
  insertAdjacentElement(position, element) {
    const { parentElement: parentElement2 } = this;
    switch (position) {
      case "beforebegin":
        if (parentElement2) {
          parentElement2.insertBefore(element, this);
          break;
        }
        return null;
      case "afterbegin":
        this.insertBefore(element, this.firstChild);
        break;
      case "beforeend":
        this.insertBefore(element, null);
        break;
      case "afterend":
        if (parentElement2) {
          parentElement2.insertBefore(element, this.nextSibling);
          break;
        }
        return null;
    }
    return element;
  }
  insertAdjacentHTML(position, html) {
    this.insertAdjacentElement(position, htmlToFragment(this.ownerDocument, html));
  }
  insertAdjacentText(position, text) {
    const node = this.ownerDocument.createTextNode(text);
    this.insertAdjacentElement(position, node);
  }
  // </insertAdjacent>
  cloneNode(deep = false) {
    const { ownerDocument, localName } = this;
    const addNext = (next2) => {
      next2.parentNode = parentNode;
      knownAdjacent($next, next2);
      $next = next2;
    };
    const clone = create2(ownerDocument, this, localName);
    let parentNode = clone, $next = clone;
    let { [NEXT]: next, [END]: prev } = this;
    while (next !== prev && (deep || next.nodeType === ATTRIBUTE_NODE)) {
      switch (next.nodeType) {
        case NODE_END:
          knownAdjacent($next, parentNode[END]);
          $next = parentNode[END];
          parentNode = parentNode.parentNode;
          break;
        case ELEMENT_NODE: {
          const node = create2(ownerDocument, next, next.localName);
          addNext(node);
          parentNode = node;
          break;
        }
        case ATTRIBUTE_NODE: {
          const attr = next.cloneNode(deep);
          attr.ownerElement = parentNode;
          addNext(attr);
          break;
        }
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          addNext(next.cloneNode(deep));
          break;
      }
      next = next[NEXT];
    }
    knownAdjacent($next, clone[END]);
    return clone;
  }
  // <custom>
  toString() {
    const out = [];
    const { [END]: end } = this;
    let next = { [NEXT]: this };
    let isOpened = false;
    do {
      next = next[NEXT];
      switch (next.nodeType) {
        case ATTRIBUTE_NODE: {
          const attr = " " + next;
          switch (attr) {
            case " id":
            case " class":
            case " style":
              break;
            default:
              out.push(attr);
          }
          break;
        }
        case NODE_END: {
          const start = next[START];
          if (isOpened) {
            if ("ownerSVGElement" in start)
              out.push(" />");
            else if (isVoid(start))
              out.push(ignoreCase(start) ? ">" : " />");
            else
              out.push(`></${start.localName}>`);
            isOpened = false;
          } else
            out.push(`</${start.localName}>`);
          break;
        }
        case ELEMENT_NODE:
          if (isOpened)
            out.push(">");
          if (next.toString !== this.toString) {
            out.push(next.toString());
            next = next[END];
            isOpened = false;
          } else {
            out.push(`<${next.localName}`);
            isOpened = true;
          }
          break;
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          out.push((isOpened ? ">" : "") + next);
          isOpened = false;
          break;
      }
    } while (next !== end);
    return out.join("");
  }
  toJSON() {
    const json = [];
    elementAsJSON(this, json);
    return json;
  }
  // </custom>
  /* c8 ignore start */
  getAttributeNS(_5, name) {
    return this.getAttribute(name);
  }
  getElementsByTagNameNS(_5, name) {
    return this.getElementsByTagName(name);
  }
  hasAttributeNS(_5, name) {
    return this.hasAttribute(name);
  }
  removeAttributeNS(_5, name) {
    this.removeAttribute(name);
  }
  setAttributeNS(_5, name, value) {
    this.setAttribute(name, value);
  }
  setAttributeNodeNS(attr) {
    return this.setAttributeNode(attr);
  }
  /* c8 ignore stop */
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/svg/element.js
var classNames = /* @__PURE__ */ new WeakMap();
var handler3 = {
  get(target, name) {
    return target[name];
  },
  set(target, name, value) {
    target[name] = value;
    return true;
  }
};
var SVGElement = class extends Element2 {
  constructor(ownerDocument, localName, ownerSVGElement = null) {
    super(ownerDocument, localName);
    this.ownerSVGElement = ownerSVGElement;
  }
  get className() {
    if (!classNames.has(this))
      classNames.set(this, new Proxy({ baseVal: "", animVal: "" }, handler3));
    return classNames.get(this);
  }
  /* c8 ignore start */
  set className(value) {
    const { classList } = this;
    classList.clear();
    classList.add(...$String(value).split(/\s+/));
  }
  /* c8 ignore stop */
  get namespaceURI() {
    return "http://www.w3.org/2000/svg";
  }
  getAttribute(name) {
    return name === "class" ? [...this.classList].join(" ") : super.getAttribute(name);
  }
  setAttribute(name, value) {
    if (name === "class")
      this.className = value;
    else if (name === "style") {
      const { className } = this;
      className.baseVal = className.animVal = value;
    }
    super.setAttribute(name, value);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/facades.js
var illegalConstructor = () => {
  throw new TypeError("Illegal constructor");
};
function Attr2() {
  illegalConstructor();
}
setPrototypeOf(Attr2, Attr);
Attr2.prototype = Attr.prototype;
function CDATASection2() {
  illegalConstructor();
}
setPrototypeOf(CDATASection2, CDATASection);
CDATASection2.prototype = CDATASection.prototype;
function CharacterData2() {
  illegalConstructor();
}
setPrototypeOf(CharacterData2, CharacterData);
CharacterData2.prototype = CharacterData.prototype;
function Comment4() {
  illegalConstructor();
}
setPrototypeOf(Comment4, Comment3);
Comment4.prototype = Comment3.prototype;
function DocumentFragment2() {
  illegalConstructor();
}
setPrototypeOf(DocumentFragment2, DocumentFragment);
DocumentFragment2.prototype = DocumentFragment.prototype;
function DocumentType2() {
  illegalConstructor();
}
setPrototypeOf(DocumentType2, DocumentType);
DocumentType2.prototype = DocumentType.prototype;
function Element3() {
  illegalConstructor();
}
setPrototypeOf(Element3, Element2);
Element3.prototype = Element2.prototype;
function Node4() {
  illegalConstructor();
}
setPrototypeOf(Node4, Node3);
Node4.prototype = Node3.prototype;
function ShadowRoot2() {
  illegalConstructor();
}
setPrototypeOf(ShadowRoot2, ShadowRoot);
ShadowRoot2.prototype = ShadowRoot.prototype;
function Text5() {
  illegalConstructor();
}
setPrototypeOf(Text5, Text4);
Text5.prototype = Text4.prototype;
function SVGElement2() {
  illegalConstructor();
}
setPrototypeOf(SVGElement2, SVGElement);
SVGElement2.prototype = SVGElement.prototype;
var Facades = {
  Attr: Attr2,
  CDATASection: CDATASection2,
  CharacterData: CharacterData2,
  Comment: Comment4,
  DocumentFragment: DocumentFragment2,
  DocumentType: DocumentType2,
  Element: Element3,
  Node: Node4,
  ShadowRoot: ShadowRoot2,
  Text: Text5,
  SVGElement: SVGElement2
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/element.js
var Level0 = /* @__PURE__ */ new WeakMap();
var level0 = {
  get(element, name) {
    return Level0.has(element) && Level0.get(element)[name] || null;
  },
  set(element, name, value) {
    if (!Level0.has(element))
      Level0.set(element, {});
    const handlers = Level0.get(element);
    const type = name.slice(2);
    if (handlers[name])
      element.removeEventListener(type, handlers[name], false);
    if (handlers[name] = value)
      element.addEventListener(type, value, false);
  }
};
var HTMLElement = class extends Element2 {
  static get observedAttributes() {
    return [];
  }
  constructor(ownerDocument = null, localName = "") {
    super(ownerDocument, localName);
    const ownerLess = !ownerDocument;
    let options;
    if (ownerLess) {
      const { constructor: Class } = this;
      if (!Classes.has(Class))
        throw new Error("unable to initialize this Custom Element");
      ({ ownerDocument, localName, options } = Classes.get(Class));
    }
    if (ownerDocument[UPGRADE]) {
      const { element, values } = ownerDocument[UPGRADE];
      ownerDocument[UPGRADE] = null;
      for (const [key2, value] of values)
        element[key2] = value;
      return element;
    }
    if (ownerLess) {
      this.ownerDocument = this[END].ownerDocument = ownerDocument;
      this.localName = localName;
      customElements.set(this, { connected: false });
      if (options.is)
        this.setAttribute("is", options.is);
    }
  }
  /* c8 ignore start */
  /* TODO: what about these?
  offsetHeight
  offsetLeft
  offsetParent
  offsetTop
  offsetWidth
  */
  blur() {
    this.dispatchEvent(new GlobalEvent("blur"));
  }
  click() {
    const clickEvent = new GlobalEvent("click", { bubbles: true, cancelable: true });
    clickEvent.button = 0;
    this.dispatchEvent(clickEvent);
  }
  // Boolean getters
  get accessKeyLabel() {
    const { accessKey } = this;
    return accessKey && `Alt+Shift+${accessKey}`;
  }
  get isContentEditable() {
    return this.hasAttribute("contenteditable");
  }
  // Boolean Accessors
  get contentEditable() {
    return booleanAttribute.get(this, "contenteditable");
  }
  set contentEditable(value) {
    booleanAttribute.set(this, "contenteditable", value);
  }
  get draggable() {
    return booleanAttribute.get(this, "draggable");
  }
  set draggable(value) {
    booleanAttribute.set(this, "draggable", value);
  }
  get hidden() {
    return booleanAttribute.get(this, "hidden");
  }
  set hidden(value) {
    booleanAttribute.set(this, "hidden", value);
  }
  get spellcheck() {
    return booleanAttribute.get(this, "spellcheck");
  }
  set spellcheck(value) {
    booleanAttribute.set(this, "spellcheck", value);
  }
  // String Accessors
  get accessKey() {
    return stringAttribute.get(this, "accesskey");
  }
  set accessKey(value) {
    stringAttribute.set(this, "accesskey", value);
  }
  get dir() {
    return stringAttribute.get(this, "dir");
  }
  set dir(value) {
    stringAttribute.set(this, "dir", value);
  }
  get lang() {
    return stringAttribute.get(this, "lang");
  }
  set lang(value) {
    stringAttribute.set(this, "lang", value);
  }
  get title() {
    return stringAttribute.get(this, "title");
  }
  set title(value) {
    stringAttribute.set(this, "title", value);
  }
  // DOM Level 0
  get onabort() {
    return level0.get(this, "onabort");
  }
  set onabort(value) {
    level0.set(this, "onabort", value);
  }
  get onblur() {
    return level0.get(this, "onblur");
  }
  set onblur(value) {
    level0.set(this, "onblur", value);
  }
  get oncancel() {
    return level0.get(this, "oncancel");
  }
  set oncancel(value) {
    level0.set(this, "oncancel", value);
  }
  get oncanplay() {
    return level0.get(this, "oncanplay");
  }
  set oncanplay(value) {
    level0.set(this, "oncanplay", value);
  }
  get oncanplaythrough() {
    return level0.get(this, "oncanplaythrough");
  }
  set oncanplaythrough(value) {
    level0.set(this, "oncanplaythrough", value);
  }
  get onchange() {
    return level0.get(this, "onchange");
  }
  set onchange(value) {
    level0.set(this, "onchange", value);
  }
  get onclick() {
    return level0.get(this, "onclick");
  }
  set onclick(value) {
    level0.set(this, "onclick", value);
  }
  get onclose() {
    return level0.get(this, "onclose");
  }
  set onclose(value) {
    level0.set(this, "onclose", value);
  }
  get oncontextmenu() {
    return level0.get(this, "oncontextmenu");
  }
  set oncontextmenu(value) {
    level0.set(this, "oncontextmenu", value);
  }
  get oncuechange() {
    return level0.get(this, "oncuechange");
  }
  set oncuechange(value) {
    level0.set(this, "oncuechange", value);
  }
  get ondblclick() {
    return level0.get(this, "ondblclick");
  }
  set ondblclick(value) {
    level0.set(this, "ondblclick", value);
  }
  get ondrag() {
    return level0.get(this, "ondrag");
  }
  set ondrag(value) {
    level0.set(this, "ondrag", value);
  }
  get ondragend() {
    return level0.get(this, "ondragend");
  }
  set ondragend(value) {
    level0.set(this, "ondragend", value);
  }
  get ondragenter() {
    return level0.get(this, "ondragenter");
  }
  set ondragenter(value) {
    level0.set(this, "ondragenter", value);
  }
  get ondragleave() {
    return level0.get(this, "ondragleave");
  }
  set ondragleave(value) {
    level0.set(this, "ondragleave", value);
  }
  get ondragover() {
    return level0.get(this, "ondragover");
  }
  set ondragover(value) {
    level0.set(this, "ondragover", value);
  }
  get ondragstart() {
    return level0.get(this, "ondragstart");
  }
  set ondragstart(value) {
    level0.set(this, "ondragstart", value);
  }
  get ondrop() {
    return level0.get(this, "ondrop");
  }
  set ondrop(value) {
    level0.set(this, "ondrop", value);
  }
  get ondurationchange() {
    return level0.get(this, "ondurationchange");
  }
  set ondurationchange(value) {
    level0.set(this, "ondurationchange", value);
  }
  get onemptied() {
    return level0.get(this, "onemptied");
  }
  set onemptied(value) {
    level0.set(this, "onemptied", value);
  }
  get onended() {
    return level0.get(this, "onended");
  }
  set onended(value) {
    level0.set(this, "onended", value);
  }
  get onerror() {
    return level0.get(this, "onerror");
  }
  set onerror(value) {
    level0.set(this, "onerror", value);
  }
  get onfocus() {
    return level0.get(this, "onfocus");
  }
  set onfocus(value) {
    level0.set(this, "onfocus", value);
  }
  get oninput() {
    return level0.get(this, "oninput");
  }
  set oninput(value) {
    level0.set(this, "oninput", value);
  }
  get oninvalid() {
    return level0.get(this, "oninvalid");
  }
  set oninvalid(value) {
    level0.set(this, "oninvalid", value);
  }
  get onkeydown() {
    return level0.get(this, "onkeydown");
  }
  set onkeydown(value) {
    level0.set(this, "onkeydown", value);
  }
  get onkeypress() {
    return level0.get(this, "onkeypress");
  }
  set onkeypress(value) {
    level0.set(this, "onkeypress", value);
  }
  get onkeyup() {
    return level0.get(this, "onkeyup");
  }
  set onkeyup(value) {
    level0.set(this, "onkeyup", value);
  }
  get onload() {
    return level0.get(this, "onload");
  }
  set onload(value) {
    level0.set(this, "onload", value);
  }
  get onloadeddata() {
    return level0.get(this, "onloadeddata");
  }
  set onloadeddata(value) {
    level0.set(this, "onloadeddata", value);
  }
  get onloadedmetadata() {
    return level0.get(this, "onloadedmetadata");
  }
  set onloadedmetadata(value) {
    level0.set(this, "onloadedmetadata", value);
  }
  get onloadstart() {
    return level0.get(this, "onloadstart");
  }
  set onloadstart(value) {
    level0.set(this, "onloadstart", value);
  }
  get onmousedown() {
    return level0.get(this, "onmousedown");
  }
  set onmousedown(value) {
    level0.set(this, "onmousedown", value);
  }
  get onmouseenter() {
    return level0.get(this, "onmouseenter");
  }
  set onmouseenter(value) {
    level0.set(this, "onmouseenter", value);
  }
  get onmouseleave() {
    return level0.get(this, "onmouseleave");
  }
  set onmouseleave(value) {
    level0.set(this, "onmouseleave", value);
  }
  get onmousemove() {
    return level0.get(this, "onmousemove");
  }
  set onmousemove(value) {
    level0.set(this, "onmousemove", value);
  }
  get onmouseout() {
    return level0.get(this, "onmouseout");
  }
  set onmouseout(value) {
    level0.set(this, "onmouseout", value);
  }
  get onmouseover() {
    return level0.get(this, "onmouseover");
  }
  set onmouseover(value) {
    level0.set(this, "onmouseover", value);
  }
  get onmouseup() {
    return level0.get(this, "onmouseup");
  }
  set onmouseup(value) {
    level0.set(this, "onmouseup", value);
  }
  get onmousewheel() {
    return level0.get(this, "onmousewheel");
  }
  set onmousewheel(value) {
    level0.set(this, "onmousewheel", value);
  }
  get onpause() {
    return level0.get(this, "onpause");
  }
  set onpause(value) {
    level0.set(this, "onpause", value);
  }
  get onplay() {
    return level0.get(this, "onplay");
  }
  set onplay(value) {
    level0.set(this, "onplay", value);
  }
  get onplaying() {
    return level0.get(this, "onplaying");
  }
  set onplaying(value) {
    level0.set(this, "onplaying", value);
  }
  get onprogress() {
    return level0.get(this, "onprogress");
  }
  set onprogress(value) {
    level0.set(this, "onprogress", value);
  }
  get onratechange() {
    return level0.get(this, "onratechange");
  }
  set onratechange(value) {
    level0.set(this, "onratechange", value);
  }
  get onreset() {
    return level0.get(this, "onreset");
  }
  set onreset(value) {
    level0.set(this, "onreset", value);
  }
  get onresize() {
    return level0.get(this, "onresize");
  }
  set onresize(value) {
    level0.set(this, "onresize", value);
  }
  get onscroll() {
    return level0.get(this, "onscroll");
  }
  set onscroll(value) {
    level0.set(this, "onscroll", value);
  }
  get onseeked() {
    return level0.get(this, "onseeked");
  }
  set onseeked(value) {
    level0.set(this, "onseeked", value);
  }
  get onseeking() {
    return level0.get(this, "onseeking");
  }
  set onseeking(value) {
    level0.set(this, "onseeking", value);
  }
  get onselect() {
    return level0.get(this, "onselect");
  }
  set onselect(value) {
    level0.set(this, "onselect", value);
  }
  get onshow() {
    return level0.get(this, "onshow");
  }
  set onshow(value) {
    level0.set(this, "onshow", value);
  }
  get onstalled() {
    return level0.get(this, "onstalled");
  }
  set onstalled(value) {
    level0.set(this, "onstalled", value);
  }
  get onsubmit() {
    return level0.get(this, "onsubmit");
  }
  set onsubmit(value) {
    level0.set(this, "onsubmit", value);
  }
  get onsuspend() {
    return level0.get(this, "onsuspend");
  }
  set onsuspend(value) {
    level0.set(this, "onsuspend", value);
  }
  get ontimeupdate() {
    return level0.get(this, "ontimeupdate");
  }
  set ontimeupdate(value) {
    level0.set(this, "ontimeupdate", value);
  }
  get ontoggle() {
    return level0.get(this, "ontoggle");
  }
  set ontoggle(value) {
    level0.set(this, "ontoggle", value);
  }
  get onvolumechange() {
    return level0.get(this, "onvolumechange");
  }
  set onvolumechange(value) {
    level0.set(this, "onvolumechange", value);
  }
  get onwaiting() {
    return level0.get(this, "onwaiting");
  }
  set onwaiting(value) {
    level0.set(this, "onwaiting", value);
  }
  get onauxclick() {
    return level0.get(this, "onauxclick");
  }
  set onauxclick(value) {
    level0.set(this, "onauxclick", value);
  }
  get ongotpointercapture() {
    return level0.get(this, "ongotpointercapture");
  }
  set ongotpointercapture(value) {
    level0.set(this, "ongotpointercapture", value);
  }
  get onlostpointercapture() {
    return level0.get(this, "onlostpointercapture");
  }
  set onlostpointercapture(value) {
    level0.set(this, "onlostpointercapture", value);
  }
  get onpointercancel() {
    return level0.get(this, "onpointercancel");
  }
  set onpointercancel(value) {
    level0.set(this, "onpointercancel", value);
  }
  get onpointerdown() {
    return level0.get(this, "onpointerdown");
  }
  set onpointerdown(value) {
    level0.set(this, "onpointerdown", value);
  }
  get onpointerenter() {
    return level0.get(this, "onpointerenter");
  }
  set onpointerenter(value) {
    level0.set(this, "onpointerenter", value);
  }
  get onpointerleave() {
    return level0.get(this, "onpointerleave");
  }
  set onpointerleave(value) {
    level0.set(this, "onpointerleave", value);
  }
  get onpointermove() {
    return level0.get(this, "onpointermove");
  }
  set onpointermove(value) {
    level0.set(this, "onpointermove", value);
  }
  get onpointerout() {
    return level0.get(this, "onpointerout");
  }
  set onpointerout(value) {
    level0.set(this, "onpointerout", value);
  }
  get onpointerover() {
    return level0.get(this, "onpointerover");
  }
  set onpointerover(value) {
    level0.set(this, "onpointerover", value);
  }
  get onpointerup() {
    return level0.get(this, "onpointerup");
  }
  set onpointerup(value) {
    level0.set(this, "onpointerup", value);
  }
  /* c8 ignore stop */
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/template-element.js
var tagName = "template";
var HTMLTemplateElement = class extends HTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, tagName);
    const content = this.ownerDocument.createDocumentFragment();
    (this[CONTENT] = content)[PRIVATE] = this;
  }
  get content() {
    if (this.hasChildNodes() && !this[CONTENT].hasChildNodes()) {
      for (const node of this.childNodes)
        this[CONTENT].appendChild(node.cloneNode(true));
    }
    return this[CONTENT];
  }
};
registerHTMLClass(tagName, HTMLTemplateElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/html-element.js
var HTMLHtmlElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "html") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/text-element.js
var { toString } = HTMLElement.prototype;
var TextElement = class extends HTMLElement {
  get innerHTML() {
    return this.textContent;
  }
  set innerHTML(html) {
    this.textContent = html;
  }
  toString() {
    const outerHTML = toString.call(this.cloneNode());
    return outerHTML.replace("><", () => `>${this.textContent}<`);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/script-element.js
var tagName2 = "script";
var HTMLScriptElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName2) {
    super(ownerDocument, localName);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get defer() {
    return booleanAttribute.get(this, "defer");
  }
  set defer(value) {
    booleanAttribute.set(this, "defer", value);
  }
  get crossOrigin() {
    return stringAttribute.get(this, "crossorigin");
  }
  set crossOrigin(value) {
    stringAttribute.set(this, "crossorigin", value);
  }
  get nomodule() {
    return booleanAttribute.get(this, "nomodule");
  }
  set nomodule(value) {
    booleanAttribute.set(this, "nomodule", value);
  }
  get referrerPolicy() {
    return stringAttribute.get(this, "referrerpolicy");
  }
  set referrerPolicy(value) {
    stringAttribute.set(this, "referrerpolicy", value);
  }
  get nonce() {
    return stringAttribute.get(this, "nonce");
  }
  set nonce(value) {
    stringAttribute.set(this, "nonce", value);
  }
  get async() {
    return booleanAttribute.get(this, "async");
  }
  set async(value) {
    booleanAttribute.set(this, "async", value);
  }
  get text() {
    return this.textContent;
  }
  set text(content) {
    this.textContent = content;
  }
};
registerHTMLClass(tagName2, HTMLScriptElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/frame-element.js
var HTMLFrameElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "frame") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/i-frame-element.js
var tagName3 = "iframe";
var HTMLIFrameElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName3) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get srcdoc() {
    return stringAttribute.get(this, "srcdoc");
  }
  set srcdoc(value) {
    stringAttribute.set(this, "srcdoc", value);
  }
  get name() {
    return stringAttribute.get(this, "name");
  }
  set name(value) {
    stringAttribute.set(this, "name", value);
  }
  get allow() {
    return stringAttribute.get(this, "allow");
  }
  set allow(value) {
    stringAttribute.set(this, "allow", value);
  }
  get allowFullscreen() {
    return booleanAttribute.get(this, "allowfullscreen");
  }
  set allowFullscreen(value) {
    booleanAttribute.set(this, "allowfullscreen", value);
  }
  get referrerPolicy() {
    return stringAttribute.get(this, "referrerpolicy");
  }
  set referrerPolicy(value) {
    stringAttribute.set(this, "referrerpolicy", value);
  }
  get loading() {
    return stringAttribute.get(this, "loading");
  }
  set loading(value) {
    stringAttribute.set(this, "loading", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName3, HTMLIFrameElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/object-element.js
var HTMLObjectElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "object") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/head-element.js
var HTMLHeadElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "head") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/body-element.js
var HTMLBodyElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "body") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/style-element.js
var import_cssom = __toESM(require_lib(), 1);
var tagName4 = "style";
var HTMLStyleElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName4) {
    super(ownerDocument, localName);
    this[SHEET] = null;
  }
  get sheet() {
    const sheet = this[SHEET];
    if (sheet !== null) {
      return sheet;
    }
    return this[SHEET] = (0, import_cssom.parse)(this.textContent);
  }
  get innerHTML() {
    return super.innerHTML || "";
  }
  set innerHTML(value) {
    super.textContent = value;
    this[SHEET] = null;
  }
  get innerText() {
    return super.innerText || "";
  }
  set innerText(value) {
    super.textContent = value;
    this[SHEET] = null;
  }
  get textContent() {
    return super.textContent || "";
  }
  set textContent(value) {
    super.textContent = value;
    this[SHEET] = null;
  }
};
registerHTMLClass(tagName4, HTMLStyleElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/time-element.js
var HTMLTimeElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "time") {
    super(ownerDocument, localName);
  }
  /**
   * @type {string}
   */
  get dateTime() {
    return stringAttribute.get(this, "datetime");
  }
  set dateTime(value) {
    stringAttribute.set(this, "datetime", value);
  }
};
registerHTMLClass("time", HTMLTimeElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/field-set-element.js
var HTMLFieldSetElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "fieldset") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/embed-element.js
var HTMLEmbedElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "embed") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/hr-element.js
var HTMLHRElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "hr") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/progress-element.js
var HTMLProgressElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "progress") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/paragraph-element.js
var HTMLParagraphElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "p") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/table-element.js
var HTMLTableElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "table") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/frame-set-element.js
var HTMLFrameSetElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "frameset") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/li-element.js
var HTMLLIElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "li") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/base-element.js
var HTMLBaseElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "base") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/data-list-element.js
var HTMLDataListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "datalist") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/input-element.js
var tagName5 = "input";
var HTMLInputElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName5) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get autofocus() {
    return booleanAttribute.get(this, "autofocus") || -1;
  }
  set autofocus(value) {
    booleanAttribute.set(this, "autofocus", value);
  }
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  get placeholder() {
    return this.getAttribute("placeholder");
  }
  set placeholder(value) {
    this.setAttribute("placeholder", value);
  }
  get type() {
    return this.getAttribute("type");
  }
  set type(value) {
    this.setAttribute("type", value);
  }
  get value() {
    return stringAttribute.get(this, "value");
  }
  set value(value) {
    stringAttribute.set(this, "value", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName5, HTMLInputElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/param-element.js
var HTMLParamElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "param") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/media-element.js
var HTMLMediaElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "media") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/audio-element.js
var HTMLAudioElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "audio") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/heading-element.js
var tagName6 = "h1";
var HTMLHeadingElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName6) {
    super(ownerDocument, localName);
  }
};
registerHTMLClass([tagName6, "h2", "h3", "h4", "h5", "h6"], HTMLHeadingElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/directory-element.js
var HTMLDirectoryElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "dir") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/quote-element.js
var HTMLQuoteElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "quote") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/canvas-element.js
var import_canvas = __toESM(require_canvas(), 1);
var { createCanvas } = import_canvas.default;
var tagName7 = "canvas";
var HTMLCanvasElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName7) {
    super(ownerDocument, localName);
    this[IMAGE] = createCanvas(300, 150);
  }
  get width() {
    return this[IMAGE].width;
  }
  set width(value) {
    numericAttribute.set(this, "width", value);
    this[IMAGE].width = value;
  }
  get height() {
    return this[IMAGE].height;
  }
  set height(value) {
    numericAttribute.set(this, "height", value);
    this[IMAGE].height = value;
  }
  getContext(type) {
    return this[IMAGE].getContext(type);
  }
  toDataURL(...args) {
    return this[IMAGE].toDataURL(...args);
  }
};
registerHTMLClass(tagName7, HTMLCanvasElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/legend-element.js
var HTMLLegendElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "legend") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/option-element.js
var tagName8 = "option";
var HTMLOptionElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName8) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get value() {
    return stringAttribute.get(this, "value");
  }
  set value(value) {
    stringAttribute.set(this, "value", value);
  }
  /* c8 ignore stop */
  get selected() {
    return booleanAttribute.get(this, "selected");
  }
  set selected(value) {
    const option = this.parentElement?.querySelector("option[selected]");
    if (option && option !== this)
      option.selected = false;
    booleanAttribute.set(this, "selected", value);
  }
};
registerHTMLClass(tagName8, HTMLOptionElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/span-element.js
var HTMLSpanElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "span") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/meter-element.js
var HTMLMeterElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "meter") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/video-element.js
var HTMLVideoElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "video") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/table-cell-element.js
var HTMLTableCellElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "td") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/title-element.js
var tagName9 = "title";
var HTMLTitleElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName9) {
    super(ownerDocument, localName);
  }
};
registerHTMLClass(tagName9, HTMLTitleElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/output-element.js
var HTMLOutputElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "output") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/table-row-element.js
var HTMLTableRowElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "tr") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/data-element.js
var HTMLDataElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "data") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/menu-element.js
var HTMLMenuElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "menu") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/select-element.js
var tagName10 = "select";
var HTMLSelectElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName10) {
    super(ownerDocument, localName);
  }
  get options() {
    let children = new NodeList();
    let { firstElementChild } = this;
    while (firstElementChild) {
      if (firstElementChild.tagName === "OPTGROUP")
        children.push(...firstElementChild.children);
      else
        children.push(firstElementChild);
      firstElementChild = firstElementChild.nextElementSibling;
    }
    return children;
  }
  /* c8 ignore start */
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  /* c8 ignore stop */
  get value() {
    return this.querySelector("option[selected]")?.value;
  }
};
registerHTMLClass(tagName10, HTMLSelectElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/br-element.js
var HTMLBRElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "br") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/button-element.js
var tagName11 = "button";
var HTMLButtonElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName11) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  get type() {
    return this.getAttribute("type");
  }
  set type(value) {
    this.setAttribute("type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName11, HTMLButtonElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/map-element.js
var HTMLMapElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "map") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/opt-group-element.js
var HTMLOptGroupElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "optgroup") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/d-list-element.js
var HTMLDListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "dl") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/text-area-element.js
var tagName12 = "textarea";
var HTMLTextAreaElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName12) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  get placeholder() {
    return this.getAttribute("placeholder");
  }
  set placeholder(value) {
    this.setAttribute("placeholder", value);
  }
  get type() {
    return this.getAttribute("type");
  }
  set type(value) {
    this.setAttribute("type", value);
  }
  get value() {
    return this.textContent;
  }
  set value(content) {
    this.textContent = content;
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName12, HTMLTextAreaElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/font-element.js
var HTMLFontElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "font") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/div-element.js
var HTMLDivElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "div") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/link-element.js
var tagName13 = "link";
var HTMLLinkElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName13) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  // copy paste from img.src, already covered
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get href() {
    return stringAttribute.get(this, "href").trim();
  }
  set href(value) {
    stringAttribute.set(this, "href", value);
  }
  get hreflang() {
    return stringAttribute.get(this, "hreflang");
  }
  set hreflang(value) {
    stringAttribute.set(this, "hreflang", value);
  }
  get media() {
    return stringAttribute.get(this, "media");
  }
  set media(value) {
    stringAttribute.set(this, "media", value);
  }
  get rel() {
    return stringAttribute.get(this, "rel");
  }
  set rel(value) {
    stringAttribute.set(this, "rel", value);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName13, HTMLLinkElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/slot-element.js
var tagName14 = "slot";
var HTMLSlotElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName14) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  assign() {
  }
  assignedNodes(options) {
    const isNamedSlot = !!this.name;
    const hostChildNodes = this.getRootNode().host?.childNodes ?? [];
    let slottables;
    if (isNamedSlot) {
      slottables = [...hostChildNodes].filter((node) => node.slot === this.name);
    } else {
      slottables = [...hostChildNodes].filter((node) => !node.slot);
    }
    if (options?.flatten) {
      const result = [];
      for (let slottable of slottables) {
        if (slottable.localName === "slot") {
          result.push(...slottable.assignedNodes({ flatten: true }));
        } else {
          result.push(slottable);
        }
      }
      slottables = result;
    }
    return slottables.length ? slottables : [...this.childNodes];
  }
  assignedElements(options) {
    const slottables = this.assignedNodes(options).filter((n2) => n2.nodeType === 1);
    return slottables.length ? slottables : [...this.children];
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName14, HTMLSlotElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/form-element.js
var HTMLFormElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "form") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/image-element.js
var tagName15 = "img";
var HTMLImageElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName15) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get alt() {
    return stringAttribute.get(this, "alt");
  }
  set alt(value) {
    stringAttribute.set(this, "alt", value);
  }
  get sizes() {
    return stringAttribute.get(this, "sizes");
  }
  set sizes(value) {
    stringAttribute.set(this, "sizes", value);
  }
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get srcset() {
    return stringAttribute.get(this, "srcset");
  }
  set srcset(value) {
    stringAttribute.set(this, "srcset", value);
  }
  get title() {
    return stringAttribute.get(this, "title");
  }
  set title(value) {
    stringAttribute.set(this, "title", value);
  }
  get width() {
    return numericAttribute.get(this, "width");
  }
  set width(value) {
    numericAttribute.set(this, "width", value);
  }
  get height() {
    return numericAttribute.get(this, "height");
  }
  set height(value) {
    numericAttribute.set(this, "height", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName15, HTMLImageElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/pre-element.js
var HTMLPreElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "pre") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/u-list-element.js
var HTMLUListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "ul") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/meta-element.js
var tagName16 = "meta";
var HTMLMetaElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName16) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get name() {
    return stringAttribute.get(this, "name");
  }
  set name(value) {
    stringAttribute.set(this, "name", value);
  }
  get httpEquiv() {
    return stringAttribute.get(this, "http-equiv");
  }
  set httpEquiv(value) {
    stringAttribute.set(this, "http-equiv", value);
  }
  get content() {
    return stringAttribute.get(this, "content");
  }
  set content(value) {
    stringAttribute.set(this, "content", value);
  }
  get charset() {
    return stringAttribute.get(this, "charset");
  }
  set charset(value) {
    stringAttribute.set(this, "charset", value);
  }
  get media() {
    return stringAttribute.get(this, "media");
  }
  set media(value) {
    stringAttribute.set(this, "media", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName16, HTMLMetaElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/picture-element.js
var HTMLPictureElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "picture") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/area-element.js
var HTMLAreaElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "area") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/o-list-element.js
var HTMLOListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "ol") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/table-caption-element.js
var HTMLTableCaptionElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "caption") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/anchor-element.js
var tagName17 = "a";
var HTMLAnchorElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName17) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  // copy paste from img.src, already covered
  get href() {
    return encodeURI(decodeURI(stringAttribute.get(this, "href"))).trim();
  }
  set href(value) {
    stringAttribute.set(this, "href", decodeURI(value));
  }
  get download() {
    return encodeURI(decodeURI(stringAttribute.get(this, "download")));
  }
  set download(value) {
    stringAttribute.set(this, "download", decodeURI(value));
  }
  get target() {
    return stringAttribute.get(this, "target");
  }
  set target(value) {
    stringAttribute.set(this, "target", value);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  get rel() {
    return stringAttribute.get(this, "rel");
  }
  set rel(value) {
    stringAttribute.set(this, "rel", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName17, HTMLAnchorElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/label-element.js
var HTMLLabelElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "label") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/unknown-element.js
var HTMLUnknownElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "unknown") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/mod-element.js
var HTMLModElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "mod") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/details-element.js
var HTMLDetailsElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "details") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/source-element.js
var tagName18 = "source";
var HTMLSourceElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName18) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get srcset() {
    return stringAttribute.get(this, "srcset");
  }
  set srcset(value) {
    stringAttribute.set(this, "srcset", value);
  }
  get sizes() {
    return stringAttribute.get(this, "sizes");
  }
  set sizes(value) {
    stringAttribute.set(this, "sizes", value);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName18, HTMLSourceElement);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/track-element.js
var HTMLTrackElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "track") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/marquee-element.js
var HTMLMarqueeElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "marquee") {
    super(ownerDocument, localName);
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/html-classes.js
var HTMLClasses = {
  HTMLElement,
  HTMLTemplateElement,
  HTMLHtmlElement,
  HTMLScriptElement,
  HTMLFrameElement,
  HTMLIFrameElement,
  HTMLObjectElement,
  HTMLHeadElement,
  HTMLBodyElement,
  HTMLStyleElement,
  HTMLTimeElement,
  HTMLFieldSetElement,
  HTMLEmbedElement,
  HTMLHRElement,
  HTMLProgressElement,
  HTMLParagraphElement,
  HTMLTableElement,
  HTMLFrameSetElement,
  HTMLLIElement,
  HTMLBaseElement,
  HTMLDataListElement,
  HTMLInputElement,
  HTMLParamElement,
  HTMLMediaElement,
  HTMLAudioElement,
  HTMLHeadingElement,
  HTMLDirectoryElement,
  HTMLQuoteElement,
  HTMLCanvasElement,
  HTMLLegendElement,
  HTMLOptionElement,
  HTMLSpanElement,
  HTMLMeterElement,
  HTMLVideoElement,
  HTMLTableCellElement,
  HTMLTitleElement,
  HTMLOutputElement,
  HTMLTableRowElement,
  HTMLDataElement,
  HTMLMenuElement,
  HTMLSelectElement,
  HTMLBRElement,
  HTMLButtonElement,
  HTMLMapElement,
  HTMLOptGroupElement,
  HTMLDListElement,
  HTMLTextAreaElement,
  HTMLFontElement,
  HTMLDivElement,
  HTMLLinkElement,
  HTMLSlotElement,
  HTMLFormElement,
  HTMLImageElement,
  HTMLPreElement,
  HTMLUListElement,
  HTMLMetaElement,
  HTMLPictureElement,
  HTMLAreaElement,
  HTMLOListElement,
  HTMLTableCaptionElement,
  HTMLAnchorElement,
  HTMLLabelElement,
  HTMLUnknownElement,
  HTMLModElement,
  HTMLDetailsElement,
  HTMLSourceElement,
  HTMLTrackElement,
  HTMLMarqueeElement
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/mime.js
var voidElements2 = { test: () => true };
var Mime = {
  "text/html": {
    docType: "<!DOCTYPE html>",
    ignoreCase: true,
    voidElements: /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i
  },
  "image/svg+xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  },
  "text/xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  },
  "application/xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  },
  "application/xhtml+xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/custom-event.js
var CustomEvent = class extends GlobalEvent {
  constructor(type, eventInitDict = {}) {
    super(type, eventInitDict);
    this.detail = eventInitDict.detail;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/input-event.js
var InputEvent2 = class extends GlobalEvent {
  constructor(type, inputEventInit = {}) {
    super(type, inputEventInit);
    this.inputType = inputEventInit.inputType;
    this.data = inputEventInit.data;
    this.dataTransfer = inputEventInit.dataTransfer;
    this.isComposing = inputEventInit.isComposing || false;
    this.ranges = inputEventInit.ranges;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/image.js
var ImageClass = (ownerDocument) => (
  /**
   * @implements globalThis.Image
   */
  class Image extends HTMLImageElement {
    constructor(width, height) {
      super(ownerDocument);
      switch (arguments.length) {
        case 1:
          this.height = width;
          this.width = width;
          break;
        case 2:
          this.height = height;
          this.width = width;
          break;
      }
    }
  }
);

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/range.js
var deleteContents = ({ [START]: start, [END]: end }, fragment = null) => {
  setAdjacent(start[PREV], end[NEXT]);
  do {
    const after2 = getEnd(start);
    const next = after2 === end ? after2 : after2[NEXT];
    if (fragment)
      fragment.insertBefore(start, fragment[END]);
    else
      start.remove();
    start = next;
  } while (start !== end);
};
var Range2 = class _Range {
  constructor() {
    this[START] = null;
    this[END] = null;
    this.commonAncestorContainer = null;
  }
  /* TODO: this is more complicated than it looks
    setStart(node, offset) {
      this[START] = node.childNodes[offset];
    }
  
    setEnd(node, offset) {
      this[END] = getEnd(node.childNodes[offset]);
    }
    //*/
  insertNode(newNode) {
    this[END].parentNode.insertBefore(newNode, this[START]);
  }
  selectNode(node) {
    this[START] = node;
    this[END] = getEnd(node);
  }
  // TODO: SVG elements should then create contextual fragments
  //       that return SVG nodes
  selectNodeContents(node) {
    this.selectNode(node);
    this.commonAncestorContainer = node;
  }
  surroundContents(parentNode) {
    parentNode.replaceChildren(this.extractContents());
  }
  setStartBefore(node) {
    this[START] = node;
  }
  setStartAfter(node) {
    this[START] = node.nextSibling;
  }
  setEndBefore(node) {
    this[END] = getEnd(node.previousSibling);
  }
  setEndAfter(node) {
    this[END] = getEnd(node);
  }
  cloneContents() {
    let { [START]: start, [END]: end } = this;
    const fragment = start.ownerDocument.createDocumentFragment();
    while (start !== end) {
      fragment.insertBefore(start.cloneNode(true), fragment[END]);
      start = getEnd(start);
      if (start !== end)
        start = start[NEXT];
    }
    return fragment;
  }
  deleteContents() {
    deleteContents(this);
  }
  extractContents() {
    const fragment = this[START].ownerDocument.createDocumentFragment();
    deleteContents(this, fragment);
    return fragment;
  }
  createContextualFragment(html) {
    const { commonAncestorContainer: doc } = this;
    const isSVG = "ownerSVGElement" in doc;
    const document2 = isSVG ? doc.ownerDocument : doc;
    let content = htmlToFragment(document2, html);
    if (isSVG) {
      const childNodes = [...content.childNodes];
      content = document2.createDocumentFragment();
      Object.setPrototypeOf(content, SVGElement.prototype);
      content.ownerSVGElement = document2;
      for (const child of childNodes) {
        Object.setPrototypeOf(child, SVGElement.prototype);
        child.ownerSVGElement = document2;
        content.appendChild(child);
      }
    } else
      this.selectNode(content);
    return content;
  }
  cloneRange() {
    const range = new _Range();
    range[START] = this[START];
    range[END] = this[END];
    return range;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/tree-walker.js
var isOK = ({ nodeType }, mask) => {
  switch (nodeType) {
    case ELEMENT_NODE:
      return mask & SHOW_ELEMENT;
    case TEXT_NODE:
      return mask & SHOW_TEXT;
    case COMMENT_NODE:
      return mask & SHOW_COMMENT;
    case CDATA_SECTION_NODE:
      return mask & SHOW_CDATA_SECTION;
  }
  return 0;
};
var TreeWalker = class {
  constructor(root, whatToShow = SHOW_ALL) {
    this.root = root;
    this.currentNode = root;
    this.whatToShow = whatToShow;
    let { [NEXT]: next, [END]: end } = root;
    if (root.nodeType === DOCUMENT_NODE) {
      const { documentElement } = root;
      next = documentElement;
      end = documentElement[END];
    }
    const nodes = [];
    while (next && next !== end) {
      if (isOK(next, whatToShow))
        nodes.push(next);
      next = next[NEXT];
    }
    this[PRIVATE] = { i: 0, nodes };
  }
  nextNode() {
    const $5 = this[PRIVATE];
    this.currentNode = $5.i < $5.nodes.length ? $5.nodes[$5.i++] : null;
    return this.currentNode;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/interface/document.js
var query = (method, ownerDocument, selectors) => {
  let { [NEXT]: next, [END]: end } = ownerDocument;
  return method.call({ ownerDocument, [NEXT]: next, [END]: end }, selectors);
};
var globalExports = assign(
  {},
  Facades,
  HTMLClasses,
  {
    CustomEvent,
    Event: GlobalEvent,
    EventTarget: DOMEventTarget,
    InputEvent: InputEvent2,
    NamedNodeMap,
    NodeList
  }
);
var window2 = /* @__PURE__ */ new WeakMap();
var Document2 = class extends NonElementParentNode {
  constructor(type) {
    super(null, "#document", DOCUMENT_NODE);
    this[CUSTOM_ELEMENTS] = { active: false, registry: null };
    this[MUTATION_OBSERVER] = { active: false, class: null };
    this[MIME] = Mime[type];
    this[DOCTYPE] = null;
    this[DOM_PARSER] = null;
    this[GLOBALS] = null;
    this[IMAGE] = null;
    this[UPGRADE] = null;
  }
  /**
   * @type {globalThis.Document['defaultView']}
   */
  get defaultView() {
    if (!window2.has(this))
      window2.set(this, new Proxy(globalThis, {
        set: (target, name, value) => {
          switch (name) {
            case "addEventListener":
            case "removeEventListener":
            case "dispatchEvent":
              this[EVENT_TARGET][name] = value;
              break;
            default:
              target[name] = value;
              break;
          }
          return true;
        },
        get: (globalThis2, name) => {
          switch (name) {
            case "addEventListener":
            case "removeEventListener":
            case "dispatchEvent":
              if (!this[EVENT_TARGET]) {
                const et5 = this[EVENT_TARGET] = new DOMEventTarget();
                et5.dispatchEvent = et5.dispatchEvent.bind(et5);
                et5.addEventListener = et5.addEventListener.bind(et5);
                et5.removeEventListener = et5.removeEventListener.bind(et5);
              }
              return this[EVENT_TARGET][name];
            case "document":
              return this;
            /* c8 ignore start */
            case "navigator":
              return {
                userAgent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
              };
            /* c8 ignore stop */
            case "window":
              return window2.get(this);
            case "customElements":
              if (!this[CUSTOM_ELEMENTS].registry)
                this[CUSTOM_ELEMENTS] = new CustomElementRegistry(this);
              return this[CUSTOM_ELEMENTS];
            case "performance":
              return import_perf_hooks.performance;
            case "DOMParser":
              return this[DOM_PARSER];
            case "Image":
              if (!this[IMAGE])
                this[IMAGE] = ImageClass(this);
              return this[IMAGE];
            case "MutationObserver":
              if (!this[MUTATION_OBSERVER].class)
                this[MUTATION_OBSERVER] = new MutationObserverClass(this);
              return this[MUTATION_OBSERVER].class;
          }
          return this[GLOBALS] && this[GLOBALS][name] || globalExports[name] || globalThis2[name];
        }
      }));
    return window2.get(this);
  }
  get doctype() {
    const docType = this[DOCTYPE];
    if (docType)
      return docType;
    const { firstChild } = this;
    if (firstChild && firstChild.nodeType === DOCUMENT_TYPE_NODE)
      return this[DOCTYPE] = firstChild;
    return null;
  }
  set doctype(value) {
    if (/^([a-z:]+)(\s+system|\s+public(\s+"([^"]+)")?)?(\s+"([^"]+)")?/i.test(value)) {
      const { $1: name, $4: publicId, $6: systemId } = RegExp;
      this[DOCTYPE] = new DocumentType(this, name, publicId, systemId);
      knownSiblings(this, this[DOCTYPE], this[NEXT]);
    }
  }
  get documentElement() {
    return this.firstElementChild;
  }
  get isConnected() {
    return true;
  }
  /**
   * @protected
   */
  _getParent() {
    return this[EVENT_TARGET];
  }
  createAttribute(name) {
    return new Attr(this, name);
  }
  createCDATASection(data) {
    return new CDATASection(this, data);
  }
  createComment(textContent2) {
    return new Comment3(this, textContent2);
  }
  createDocumentFragment() {
    return new DocumentFragment(this);
  }
  createDocumentType(name, publicId, systemId) {
    return new DocumentType(this, name, publicId, systemId);
  }
  createElement(localName) {
    return new Element2(this, localName);
  }
  createRange() {
    const range = new Range2();
    range.commonAncestorContainer = this;
    return range;
  }
  createTextNode(textContent2) {
    return new Text4(this, textContent2);
  }
  createTreeWalker(root, whatToShow = -1) {
    return new TreeWalker(root, whatToShow);
  }
  createNodeIterator(root, whatToShow = -1) {
    return this.createTreeWalker(root, whatToShow);
  }
  createEvent(name) {
    const event = create(name === "Event" ? new GlobalEvent("") : new CustomEvent(""));
    event.initEvent = event.initCustomEvent = (type, canBubble = false, cancelable = false, detail) => {
      event.bubbles = !!canBubble;
      defineProperties(event, {
        type: { value: type },
        canBubble: { value: canBubble },
        cancelable: { value: cancelable },
        detail: { value: detail }
      });
    };
    return event;
  }
  cloneNode(deep = false) {
    const {
      constructor,
      [CUSTOM_ELEMENTS]: customElements2,
      [DOCTYPE]: doctype
    } = this;
    const document2 = new constructor();
    document2[CUSTOM_ELEMENTS] = customElements2;
    if (deep) {
      const end = document2[END];
      const { childNodes } = this;
      for (let { length } = childNodes, i2 = 0; i2 < length; i2++)
        document2.insertBefore(childNodes[i2].cloneNode(true), end);
      if (doctype)
        document2[DOCTYPE] = childNodes[0];
    }
    return document2;
  }
  importNode(externalNode) {
    const deep = 1 < arguments.length && !!arguments[1];
    const node = externalNode.cloneNode(deep);
    const { [CUSTOM_ELEMENTS]: customElements2 } = this;
    const { active } = customElements2;
    const upgrade = (element) => {
      const { ownerDocument, nodeType } = element;
      element.ownerDocument = this;
      if (active && ownerDocument !== this && nodeType === ELEMENT_NODE)
        customElements2.upgrade(element);
    };
    upgrade(node);
    if (deep) {
      switch (node.nodeType) {
        case ELEMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE: {
          let { [NEXT]: next, [END]: end } = node;
          while (next !== end) {
            if (next.nodeType === ELEMENT_NODE)
              upgrade(next);
            next = next[NEXT];
          }
          break;
        }
      }
    }
    return node;
  }
  toString() {
    return this.childNodes.join("");
  }
  querySelector(selectors) {
    return query(super.querySelector, this, selectors);
  }
  querySelectorAll(selectors) {
    return query(super.querySelectorAll, this, selectors);
  }
  /* c8 ignore start */
  getElementsByTagNameNS(_5, name) {
    return this.getElementsByTagName(name);
  }
  createAttributeNS(_5, name) {
    return this.createAttribute(name);
  }
  createElementNS(nsp, localName, options) {
    return nsp === SVG_NAMESPACE ? new SVGElement(this, localName, null) : this.createElement(localName, options);
  }
  /* c8 ignore stop */
};
setPrototypeOf(
  globalExports.Document = function Document3() {
    illegalConstructor();
  },
  Document2
).prototype = Document2.prototype;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/html/document.js
var createHTMLElement = (ownerDocument, builtin, localName, options) => {
  if (!builtin && htmlClasses.has(localName)) {
    const Class = htmlClasses.get(localName);
    return new Class(ownerDocument, localName);
  }
  const { [CUSTOM_ELEMENTS]: { active, registry } } = ownerDocument;
  if (active) {
    const ce2 = builtin ? options.is : localName;
    if (registry.has(ce2)) {
      const { Class } = registry.get(ce2);
      const element = new Class(ownerDocument, localName);
      customElements.set(element, { connected: false });
      return element;
    }
  }
  return new HTMLElement(ownerDocument, localName);
};
var HTMLDocument = class extends Document2 {
  constructor() {
    super("text/html");
  }
  get all() {
    const nodeList = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      switch (next.nodeType) {
        case ELEMENT_NODE:
          nodeList.push(next);
          break;
      }
      next = next[NEXT];
    }
    return nodeList;
  }
  /**
   * @type HTMLHeadElement
   */
  get head() {
    const { documentElement } = this;
    let { firstElementChild } = documentElement;
    if (!firstElementChild || firstElementChild.tagName !== "HEAD") {
      firstElementChild = this.createElement("head");
      documentElement.prepend(firstElementChild);
    }
    return firstElementChild;
  }
  /**
   * @type HTMLBodyElement
   */
  get body() {
    const { head } = this;
    let { nextElementSibling: nextElementSibling3 } = head;
    if (!nextElementSibling3 || nextElementSibling3.tagName !== "BODY") {
      nextElementSibling3 = this.createElement("body");
      head.after(nextElementSibling3);
    }
    return nextElementSibling3;
  }
  /**
   * @type HTMLTitleElement
   */
  get title() {
    const { head } = this;
    return head.getElementsByTagName("title").at(0)?.textContent || "";
  }
  set title(textContent2) {
    const { head } = this;
    let title = head.getElementsByTagName("title").at(0);
    if (title)
      title.textContent = textContent2;
    else {
      head.insertBefore(
        this.createElement("title"),
        head.firstChild
      ).textContent = textContent2;
    }
  }
  createElement(localName, options) {
    const builtin = !!(options && options.is);
    const element = createHTMLElement(this, builtin, localName, options);
    if (builtin)
      element.setAttribute("is", options.is);
    return element;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/svg/document.js
var SVGDocument = class extends Document2 {
  constructor() {
    super("image/svg+xml");
  }
  toString() {
    return this[MIME].docType + super.toString();
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/xml/document.js
var XMLDocument = class extends Document2 {
  constructor() {
    super("text/xml");
  }
  toString() {
    return this[MIME].docType + super.toString();
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/dom/parser.js
var DOMParser2 = class _DOMParser {
  /** @typedef {{ "text/html": HTMLDocument, "image/svg+xml": SVGDocument, "text/xml": XMLDocument }} MimeToDoc */
  /**
   * @template {keyof MimeToDoc} MIME
   * @param {string} markupLanguage
   * @param {MIME} mimeType
   * @returns {MimeToDoc[MIME]}
   */
  parseFromString(markupLanguage, mimeType, globals = null) {
    let isHTML = false, document2;
    if (mimeType === "text/html") {
      isHTML = true;
      document2 = new HTMLDocument();
    } else if (mimeType === "image/svg+xml")
      document2 = new SVGDocument();
    else
      document2 = new XMLDocument();
    document2[DOM_PARSER] = _DOMParser;
    if (globals)
      document2[GLOBALS] = globals;
    if (isHTML && markupLanguage === "...")
      markupLanguage = "<!doctype html><html><head></head><body></body></html>";
    return markupLanguage ? parseFromString(document2, isHTML, markupLanguage) : document2;
  }
};

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/shared/parse-json.js
var { parse: parse5 } = JSON;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/linkedom@0.18.11/node_modules/linkedom/esm/index.js
var parseHTML = (html, globals = null) => new DOMParser2().parseFromString(
  html,
  "text/html",
  globals
).defaultView;
function Document4() {
  illegalConstructor();
}
setPrototypeOf(Document4, Document2).prototype = Document2.prototype;

// src/main.ts
await init_LexicalHtml_node();

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/link@0.32.1/node_modules/@lexical/link/LexicalLink.node.mjs
var mod5 = await (process.env.NODE_ENV !== "production" ? init_LexicalLink_dev().then(() => LexicalLink_dev_exports) : init_LexicalLink_prod().then(() => LexicalLink_prod_exports));
var $createAutoLinkNode2 = mod5.$createAutoLinkNode;
var $createLinkNode2 = mod5.$createLinkNode;
var $isAutoLinkNode2 = mod5.$isAutoLinkNode;
var $isLinkNode2 = mod5.$isLinkNode;
var $toggleLink2 = mod5.$toggleLink;
var AutoLinkNode2 = mod5.AutoLinkNode;
var LinkNode2 = mod5.LinkNode;
var TOGGLE_LINK_COMMAND2 = mod5.TOGGLE_LINK_COMMAND;
var formatUrl2 = mod5.formatUrl;
var toggleLink2 = mod5.toggleLink;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/list@0.32.1/node_modules/@lexical/list/LexicalList.node.mjs
var mod6 = await (process.env.NODE_ENV !== "production" ? init_LexicalList_dev().then(() => LexicalList_dev_exports) : init_LexicalList_prod().then(() => LexicalList_prod_exports));
var $createListItemNode2 = mod6.$createListItemNode;
var $createListNode2 = mod6.$createListNode;
var $getListDepth2 = mod6.$getListDepth;
var $handleListInsertParagraph2 = mod6.$handleListInsertParagraph;
var $insertList2 = mod6.$insertList;
var $isListItemNode2 = mod6.$isListItemNode;
var $isListNode2 = mod6.$isListNode;
var $removeList2 = mod6.$removeList;
var INSERT_CHECK_LIST_COMMAND2 = mod6.INSERT_CHECK_LIST_COMMAND;
var INSERT_ORDERED_LIST_COMMAND2 = mod6.INSERT_ORDERED_LIST_COMMAND;
var INSERT_UNORDERED_LIST_COMMAND2 = mod6.INSERT_UNORDERED_LIST_COMMAND;
var ListItemNode2 = mod6.ListItemNode;
var ListNode2 = mod6.ListNode;
var REMOVE_LIST_COMMAND2 = mod6.REMOVE_LIST_COMMAND;
var insertList2 = mod6.insertList;
var registerCheckList2 = mod6.registerCheckList;
var registerList2 = mod6.registerList;
var registerListStrictIndentTransform2 = mod6.registerListStrictIndentTransform;
var removeList2 = mod6.removeList;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/rich-text@0.32.1/node_modules/@lexical/rich-text/LexicalRichText.node.mjs
var mod8 = await (process.env.NODE_ENV !== "production" ? init_LexicalRichText_dev().then(() => LexicalRichText_dev_exports) : init_LexicalRichText_prod().then(() => LexicalRichText_prod_exports));
var $createHeadingNode2 = mod8.$createHeadingNode;
var $createQuoteNode2 = mod8.$createQuoteNode;
var $isHeadingNode2 = mod8.$isHeadingNode;
var $isQuoteNode2 = mod8.$isQuoteNode;
var DRAG_DROP_PASTE2 = mod8.DRAG_DROP_PASTE;
var HeadingNode2 = mod8.HeadingNode;
var QuoteNode2 = mod8.QuoteNode;
var eventFiles2 = mod8.eventFiles;
var registerRichText2 = mod8.registerRichText;

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/table@0.32.1/node_modules/@lexical/table/LexicalTable.node.mjs
var mod9 = await (process.env.NODE_ENV !== "production" ? init_LexicalTable_dev().then(() => LexicalTable_dev_exports) : init_LexicalTable_prod().then(() => LexicalTable_prod_exports));
var $computeTableMap2 = mod9.$computeTableMap;
var $computeTableMapSkipCellCheck2 = mod9.$computeTableMapSkipCellCheck;
var $createTableCellNode2 = mod9.$createTableCellNode;
var $createTableNode2 = mod9.$createTableNode;
var $createTableNodeWithDimensions2 = mod9.$createTableNodeWithDimensions;
var $createTableRowNode2 = mod9.$createTableRowNode;
var $createTableSelection2 = mod9.$createTableSelection;
var $createTableSelectionFrom2 = mod9.$createTableSelectionFrom;
var $deleteTableColumn2 = mod9.$deleteTableColumn;
var $deleteTableColumnAtSelection2 = mod9.$deleteTableColumnAtSelection;
var $deleteTableColumn__EXPERIMENTAL2 = mod9.$deleteTableColumn__EXPERIMENTAL;
var $deleteTableRowAtSelection2 = mod9.$deleteTableRowAtSelection;
var $deleteTableRow__EXPERIMENTAL2 = mod9.$deleteTableRow__EXPERIMENTAL;
var $findCellNode2 = mod9.$findCellNode;
var $findTableNode2 = mod9.$findTableNode;
var $getElementForTableNode2 = mod9.$getElementForTableNode;
var $getNodeTriplet2 = mod9.$getNodeTriplet;
var $getTableAndElementByKey2 = mod9.$getTableAndElementByKey;
var $getTableCellNodeFromLexicalNode2 = mod9.$getTableCellNodeFromLexicalNode;
var $getTableCellNodeRect2 = mod9.$getTableCellNodeRect;
var $getTableColumnIndexFromTableCellNode2 = mod9.$getTableColumnIndexFromTableCellNode;
var $getTableNodeFromLexicalNodeOrThrow2 = mod9.$getTableNodeFromLexicalNodeOrThrow;
var $getTableRowIndexFromTableCellNode2 = mod9.$getTableRowIndexFromTableCellNode;
var $getTableRowNodeFromTableCellNodeOrThrow2 = mod9.$getTableRowNodeFromTableCellNodeOrThrow;
var $insertTableColumn2 = mod9.$insertTableColumn;
var $insertTableColumnAtSelection2 = mod9.$insertTableColumnAtSelection;
var $insertTableColumn__EXPERIMENTAL2 = mod9.$insertTableColumn__EXPERIMENTAL;
var $insertTableRow2 = mod9.$insertTableRow;
var $insertTableRowAtSelection2 = mod9.$insertTableRowAtSelection;
var $insertTableRow__EXPERIMENTAL2 = mod9.$insertTableRow__EXPERIMENTAL;
var $isScrollableTablesActive2 = mod9.$isScrollableTablesActive;
var $isTableCellNode2 = mod9.$isTableCellNode;
var $isTableNode2 = mod9.$isTableNode;
var $isTableRowNode2 = mod9.$isTableRowNode;
var $isTableSelection2 = mod9.$isTableSelection;
var $mergeCells2 = mod9.$mergeCells;
var $removeTableRowAtIndex2 = mod9.$removeTableRowAtIndex;
var $unmergeCell2 = mod9.$unmergeCell;
var INSERT_TABLE_COMMAND2 = mod9.INSERT_TABLE_COMMAND;
var TableCellHeaderStates2 = mod9.TableCellHeaderStates;
var TableCellNode2 = mod9.TableCellNode;
var TableNode2 = mod9.TableNode;
var TableObserver2 = mod9.TableObserver;
var TableRowNode2 = mod9.TableRowNode;
var applyTableHandlers2 = mod9.applyTableHandlers;
var getDOMCellFromTarget2 = mod9.getDOMCellFromTarget;
var getTableElement2 = mod9.getTableElement;
var getTableObserverFromTableElement2 = mod9.getTableObserverFromTableElement;
var registerTableCellUnmergeTransform2 = mod9.registerTableCellUnmergeTransform;
var registerTablePlugin2 = mod9.registerTablePlugin;
var registerTableSelectionObserver2 = mod9.registerTableSelectionObserver;
var setScrollableTablesActive2 = mod9.setScrollableTablesActive;

// src/nodes/ImageNode.tsx
await init_Lexical_node();
function $convertImageElement(domNode) {
  const img = domNode;
  if (img.src.startsWith("file:///")) {
    return null;
  }
  const { alt: altText, src, width, height } = img;
  const node = $createImageNode({ altText, height, src, width });
  return { node };
}
var ImageNode = class _ImageNode extends DecoratorNode2 {
  __src;
  __altText;
  __width;
  __height;
  __maxWidth;
  __showCaption;
  // Captions cannot yet be used within editor cells
  __captionsEnabled;
  static getType() {
    return "image";
  }
  static clone(node) {
    return new _ImageNode(
      node.__src,
      node.__altText,
      node.__maxWidth,
      node.__width,
      node.__height,
      node.__showCaption,
      node.__captionsEnabled,
      node.__key
    );
  }
  static importJSON(serializedNode) {
    const { altText, height, width, maxWidth, src, showCaption } = serializedNode;
    return $createImageNode({
      altText,
      height,
      maxWidth,
      showCaption,
      src,
      width
    }).updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    const node = super.updateFromJSON(serializedNode);
    return node;
  }
  exportDOM() {
    const element = document.createElement("img");
    element.setAttribute("src", this.__src);
    element.setAttribute("alt", this.__altText);
    element.setAttribute("width", this.__width.toString());
    element.setAttribute("height", this.__height.toString());
    return { element };
  }
  static importDOM() {
    return {
      img: (_node) => ({
        conversion: $convertImageElement,
        priority: 0
      })
    };
  }
  constructor(src, altText, maxWidth, width, height, showCaption, captionsEnabled, key2) {
    super(key2);
    this.__src = src;
    this.__altText = altText;
    this.__maxWidth = maxWidth;
    this.__width = width || "inherit";
    this.__height = height || "inherit";
    this.__showCaption = showCaption || false;
    this.__captionsEnabled = captionsEnabled || captionsEnabled === void 0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      altText: this.getAltText(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  setWidthAndHeight(width, height) {
    const writable = this.getWritable();
    writable.__width = width;
    writable.__height = height;
  }
  setShowCaption(showCaption) {
    const writable = this.getWritable();
    writable.__showCaption = showCaption;
  }
  // View
  createDOM(config) {
    const span = document.createElement("span");
    const theme = config.theme;
    const className = theme.image;
    if (className !== void 0) {
      span.className = className;
    }
    return span;
  }
  updateDOM() {
    return false;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  decorate() {
    return /* @__PURE__ */ React.createElement("img", { src: this.__src, alt: this.__altText });
  }
};
function $createImageNode({
  altText,
  height,
  maxWidth = 500,
  captionsEnabled,
  src,
  width,
  showCaption,
  caption: _caption,
  key: key2
}) {
  return $applyNodeReplacement2(
    new ImageNode(
      src,
      altText,
      maxWidth,
      width,
      height,
      showCaption,
      captionsEnabled,
      key2
    )
  );
}

// src/nodes/InlineImageNode.tsx
await init_Lexical_node();
await init_LexicalUtils_node();
function $convertInlineImageElement(domNode) {
  if (isHTMLElement2(domNode) && domNode.nodeName === "IMG") {
    const { alt: altText, src, width, height } = domNode;
    const node = $createInlineImageNode({ altText, height, src, width });
    return { node };
  }
  return null;
}
function getPositionClass(position) {
  return typeof position === "string" ? `position-${position}` : void 0;
}
var InlineImageNode = class _InlineImageNode extends DecoratorNode2 {
  __src;
  __altText;
  __width;
  __height;
  __showCaption;
  __caption;
  __position;
  static getType() {
    return "inline-image";
  }
  static clone(node) {
    return new _InlineImageNode(
      node.__src,
      node.__altText,
      node.__position,
      node.__width,
      node.__height,
      node.__showCaption,
      node.__caption,
      node.__key
    );
  }
  static importJSON(serializedNode) {
    const { altText, height, width, src, showCaption, position } = serializedNode;
    return $createInlineImageNode({
      altText,
      height,
      position,
      showCaption,
      src,
      width
    }).updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    const { caption } = serializedNode;
    const node = super.updateFromJSON(serializedNode);
    const nestedEditor = node.__caption;
    const editorState = nestedEditor.parseEditorState(caption.editorState);
    if (!editorState.isEmpty()) {
      nestedEditor.setEditorState(editorState);
    }
    return node;
  }
  static importDOM() {
    return {
      img: (_node) => ({
        conversion: $convertInlineImageElement,
        priority: 0
      })
    };
  }
  constructor(src, altText, position, width, height, showCaption, caption, key2) {
    super(key2);
    this.__src = src;
    this.__altText = altText;
    this.__width = width || "inherit";
    this.__height = height || "inherit";
    this.__showCaption = showCaption || false;
    this.__caption = caption || createEditor2();
    this.__position = position;
  }
  exportDOM() {
    const element = document.createElement("img");
    element.setAttribute("src", this.__src);
    element.setAttribute("alt", this.__altText);
    element.setAttribute("width", this.__width.toString());
    element.setAttribute("height", this.__height.toString());
    return { element };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      position: this.__position,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  setAltText(altText) {
    const writable = this.getWritable();
    writable.__altText = altText;
  }
  setWidthAndHeight(width, height) {
    const writable = this.getWritable();
    writable.__width = width;
    writable.__height = height;
  }
  getShowCaption() {
    return this.__showCaption;
  }
  setShowCaption(showCaption) {
    const writable = this.getWritable();
    writable.__showCaption = showCaption;
  }
  getPosition() {
    return this.__position;
  }
  setPosition(position) {
    const writable = this.getWritable();
    writable.__position = position;
  }
  update(payload) {
    const writable = this.getWritable();
    const { altText, showCaption, position } = payload;
    if (altText !== void 0) {
      writable.__altText = altText;
    }
    if (showCaption !== void 0) {
      writable.__showCaption = showCaption;
    }
    if (position !== void 0) {
      writable.__position = position;
    }
  }
  // View
  createDOM(config) {
    const span = document.createElement("span");
    for (const cls of [
      config.theme.inlineImage,
      getPositionClass(this.__position)
    ]) {
      if (cls) {
        addClassNamesToElement2(span, cls);
      }
    }
    return span;
  }
  updateDOM(prevNode, dom2, _config) {
    const position = this.__position;
    if (position !== prevNode.__position) {
      removeClassNamesFromElement2(dom2, getPositionClass(prevNode.__position));
      addClassNamesToElement2(dom2, getPositionClass(position));
    }
    return false;
  }
  decorate() {
    return /* @__PURE__ */ React.createElement("img", { src: this.__src, alt: this.__altText });
  }
};
function $createInlineImageNode({
  altText,
  position,
  height,
  src,
  width,
  showCaption,
  caption,
  key: key2
}) {
  return $applyNodeReplacement2(
    new InlineImageNode(
      src,
      altText,
      position,
      width,
      height,
      showCaption,
      caption,
      key2
    )
  );
}

// ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/@lexical/headless@0.32.1/node_modules/@lexical/headless/LexicalHeadless.node.mjs
var mod10 = await (process.env.NODE_ENV !== "production" ? init_LexicalHeadless_dev().then(() => LexicalHeadless_dev_exports) : init_LexicalHeadless_prod().then(() => LexicalHeadless_prod_exports));
var createHeadlessEditor2 = mod10.createHeadlessEditor;

// src/main.ts
var dom = parseHTML(`<html><body></body></html>`);
globalThis.window = dom.window;
globalThis.document = dom.window.document;
var toHtml = async (stateStr) => {
  const editor = createHeadlessEditor2({
    nodes: [
      HeadingNode2,
      ListNode2,
      ListItemNode2,
      QuoteNode2,
      TableNode2,
      TableCellNode2,
      TableRowNode2,
      AutoLinkNode2,
      LinkNode2,
      ImageNode,
      InlineImageNode
    ]
  });
  const state = editor.parseEditorState(stateStr);
  await new Promise(
    (resolve) => editor.update(() => {
      editor.setEditorState(state);
      resolve();
    })
  );
  return new Promise((resolve) => {
    editor.read(() => {
      resolve($generateHtmlFromNodes2(editor));
    });
  });
};
Deno.serve(async (req) => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }
  const rawBody = await req.text();
  if (rawBody.startsWith("<"))
    return new Response("<div>redacted</div>", {
      headers: { "Content-Type": "text/html" }
    });
  const stateStr = JSON.parse(rawBody);
  const stateObj = JSON.parse(stateStr);
  const state = stateObj.editorState;
  if (!state) {
    return new Response("Bad Request: No body provided", { status: 400 });
  }
  return new Response(await toHtml(state), {
    headers: { "Content-Type": "text/html" }
  });
});
export {
  toHtml
};
